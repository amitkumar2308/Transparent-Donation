/**
 * Oracle methods - routines to interact with the Ã¦ternity oracle system
 *
 * The high-level description of the oracle system is
 * https://github.com/aeternity/protocol/blob/master/ORACLE.md in the protocol
 * repository.
 */
import { mapObject, pause } from "./utils/other.mjs";
import { oracleQueryId } from "./tx/builder/helpers.mjs";
import { unpackTx, buildTxAsync } from "./tx/builder/index.mjs";
import { ORACLE_TTL, QUERY_TTL, RESPONSE_TTL } from "./tx/builder/schema.mjs";
import { Tag } from "./tx/builder/constants.mjs";
import { RequestTimedOutError } from "./utils/errors.mjs";
import { decode, encode, Encoding } from "./utils/encoder.mjs";
import { _getPollInterval, getHeight, sendTransaction } from "./chain.mjs";
/**
 * Poll for oracle queries
 * @category oracle
 * @param oracleId - Oracle public key
 * @param onQuery - OnQuery callback
 * @param options - Options object
 * @param options.interval - Poll interval(default: 5000)
 * @param options.onNode - Node to use
 * @returns Callback to stop polling function
 */
export function pollForQueries(oracleId, onQuery, _ref) {
  var _interval;
  let {
    interval,
    onNode,
    ...options
  } = _ref;
  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);
  const knownQueryIds = new Set();
  const checkNewQueries = async () => {
    var _await$onNode$getOrac;
    const queries = ((_await$onNode$getOrac = (await onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries) !== null && _await$onNode$getOrac !== void 0 ? _await$onNode$getOrac : []).filter(_ref2 => {
      let {
        id
      } = _ref2;
      return !knownQueryIds.has(id);
    });
    queries.forEach(query => {
      knownQueryIds.add(query.id);
      onQuery(query);
    });
  };
  let stopped = false;

  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  (async () => {
    while (!stopped) {
      // eslint-disable-line no-unmodified-loop-condition
      // TODO: allow to handle this error somehow
      await checkNewQueries().catch(console.error);
      await pause(interval);
    }
  })();
  return () => {
    stopped = true;
  };
}

/**
 * Poll for oracle query response
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle Query id
 * @param options - Options object
 * @param options.interval - Poll interval
 * @param options.onNode - Node to use
 * @returns OracleQuery object
 */
export async function pollForQueryResponse(oracleId, queryId, _ref3) {
  var _interval2;
  let {
    interval,
    onNode,
    ...options
  } = _ref3;
  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('microblock', options);
  let height;
  let ttl;
  let response;
  do {
    ({
      response,
      ttl
    } = await onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId));
    const responseBuffer = decode(response);
    if (responseBuffer.length > 0) return responseBuffer.toString();
    await pause(interval);
    height = await getHeight({
      onNode
    });
  } while (ttl >= height);
  throw new RequestTimedOutError(height);
}

/**
 * Constructor for OracleQuery Object (helper object for using OracleQuery)
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle Query id
 * @param options - Options
 * @returns OracleQuery object
 */
export async function getQueryObject(oracleId, queryId, options) {
  const record = await options.onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId);
  return {
    ...record,
    decodedQuery: decode(record.query).toString(),
    decodedResponse: decode(record.response).toString(),
    respond: async (response, opt) =>
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    respondToQuery(queryId, response, {
      ...options,
      ...opt
    }),
    pollForResponse: async opt => pollForQueryResponse(oracleId, queryId, {
      ...options,
      ...opt
    })
  };
}
/**
 * Post query to oracle
 * @category oracle
 * @param oracleId - Oracle public key
 * @param query - Oracle query object
 * @param options - Options object
 * @param options.queryTtl - queryTtl Oracle query time to leave
 * @param options.responseTtl - queryFee Oracle query response time to leave
 * @param options.queryFee - queryFee Oracle query fee
 * @param options.fee - fee Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Query object
 */
export async function postQueryToOracle(oracleId, query, options) {
  var _options$queryFee;
  (_options$queryFee = options.queryFee) !== null && _options$queryFee !== void 0 ? _options$queryFee : options.queryFee = (await options.onNode.getOracleByPubkey(oracleId)).queryFee.toString();
  const senderId = options.onAccount.address;
  const oracleQueryTx = await buildTxAsync({
    queryTtlType: QUERY_TTL.type,
    queryTtlValue: QUERY_TTL.value,
    responseTtlType: RESPONSE_TTL.type,
    responseTtlValue: RESPONSE_TTL.value,
    ...options,
    tag: Tag.OracleQueryTx,
    oracleId,
    senderId,
    query
  });
  const {
    nonce
  } = unpackTx(oracleQueryTx, Tag.OracleQueryTx);
  const queryId = oracleQueryId(senderId, nonce, oracleId);
  return {
    ...(await sendTransaction(oracleQueryTx, options)),
    ...(await getQueryObject(oracleId, queryId, options))
  };
}
/**
 * Extend oracle ttl
 * @category oracle
 * @param options - Options object
 * @param options.fee - fee Transaction fee
 * @param options.ttl - Transaction time to leave
 * @param options.oracleTtlType - Oracle time to leave for extend
 * @param options.oracleTtlValue - Oracle time to leave for extend
 * @returns Oracle object
 */
export async function extendOracleTtl(options) {
  const oracleId = encode(decode(options.onAccount.address), Encoding.OracleAddress);
  const oracleExtendTx = await buildTxAsync({
    oracleTtlType: ORACLE_TTL.type,
    oracleTtlValue: ORACLE_TTL.value,
    ...options,
    tag: Tag.OracleExtendTx,
    oracleId
  });
  return {
    ...(await sendTransaction(oracleExtendTx, options)),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    ...(await getOracleObject(oracleId, options))
  };
}
/**
 * Extend oracle ttl
 * @category oracle
 * @param queryId - Oracle query id
 * @param response - Oracle query response
 * @param options - Options object
 * @param options.responseTtl - responseTtl Query response time to leave
 * @param options.fee - Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Oracle object
 */
export async function respondToQuery(queryId, response, options) {
  const oracleId = encode(decode(options.onAccount.address), Encoding.OracleAddress);
  const oracleRespondTx = await buildTxAsync({
    responseTtlType: RESPONSE_TTL.type,
    responseTtlValue: RESPONSE_TTL.value,
    ...options,
    tag: Tag.OracleResponseTx,
    oracleId,
    queryId,
    response
  });
  return {
    ...(await sendTransaction(oracleRespondTx, options)),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    ...(await getOracleObject(oracleId, options))
  };
}
/**
 * Constructor for Oracle Object (helper object for using Oracle)
 * @category oracle
 * @param oracleId - Oracle public key
 * @param options - Options
 * @returns Oracle object
 */
export async function getOracleObject(oracleId, options) {
  return {
    ...(await options.onNode.getOracleByPubkey(oracleId)),
    queries: (await options.onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries,
    ...mapObject({
      pollQueries: pollForQueries,
      postQuery: postQueryToOracle,
      respondToQuery,
      extendOracle: extendOracleTtl,
      getQuery: getQueryObject
    }, _ref4 => {
      let [name, handler] = _ref4;
      return [name, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const lastArg = args[args.length - 1];
        if (lastArg != null && typeof lastArg === 'object' && lastArg.constructor === Object) {
          Object.assign(lastArg, {
            ...options,
            ...lastArg
          });
        } else args.push(options);
        return handler(...(['extendOracle', 'respondToQuery'].includes(name) ? [] : [oracleId]), ...args);
      }];
    })
  };
}
/**
 * Register oracle
 * @category oracle
 * @param queryFormat - Format of query
 * @param responseFormat - Format of query response
 * @param options - Options
 * @param options.queryFee - Oracle query Fee
 * @param options - Options object
 * @param options.abiVersion - Always 0 (do not use virtual machine)
 * @param options.fee - Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Oracle object
 */
export async function registerOracle(queryFormat, responseFormat, options) {
  const accountId = options.onAccount.address;
  const oracleRegisterTx = await buildTxAsync({
    oracleTtlValue: ORACLE_TTL.value,
    oracleTtlType: ORACLE_TTL.type,
    ...options,
    tag: Tag.OracleRegisterTx,
    accountId,
    queryFormat,
    responseFormat
  });
  return {
    ...(await sendTransaction(oracleRegisterTx, options)),
    ...(await getOracleObject(encode(decode(accountId), Encoding.OracleAddress), options))
  };
}
//# sourceMappingURL=oracle.mjs.map