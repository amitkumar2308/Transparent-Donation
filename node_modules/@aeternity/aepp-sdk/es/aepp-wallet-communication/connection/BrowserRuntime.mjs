import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";
import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
import BrowserConnection from "./Browser.mjs";
import { UnexpectedTsError } from "../../utils/errors.mjs";
/**
 * BrowserRuntimeConnection
 * Handle browser runtime communication
 * @category aepp wallet communication
 */
var _listeners = /*#__PURE__*/new WeakMap();
export default class BrowserRuntimeConnection extends BrowserConnection {
  constructor(_ref) {
    let {
      port,
      ...options
    } = _ref;
    super(options);
    _classPrivateFieldInitSpec(this, _listeners, {
      writable: true,
      value: void 0
    });
    this.port = port;
  }
  disconnect() {
    super.disconnect();
    this.port.disconnect();
    if (_classPrivateFieldGet(this, _listeners) == null) throw new UnexpectedTsError();
    this.port.onMessage.removeListener(_classPrivateFieldGet(this, _listeners)[0]);
    this.port.onDisconnect.removeListener(_classPrivateFieldGet(this, _listeners)[1]);
    _classPrivateFieldSet(this, _listeners, undefined);
  }
  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);
    _classPrivateFieldSet(this, _listeners, [(message, port) => {
      var _port$sender$url, _port$sender;
      this.receiveMessage(message);
      // TODO: make `origin` optional because sender url is not available on aepp side
      onMessage(message, (_port$sender$url = (_port$sender = port.sender) === null || _port$sender === void 0 ? void 0 : _port$sender.url) !== null && _port$sender$url !== void 0 ? _port$sender$url : '', port);
    }, onDisconnect]);
    this.port.onMessage.addListener(_classPrivateFieldGet(this, _listeners)[0]);
    this.port.onDisconnect.addListener(_classPrivateFieldGet(this, _listeners)[1]);
  }
  sendMessage(message) {
    super.sendMessage(message);
    this.port.postMessage(message);
  }
  isConnected() {
    return _classPrivateFieldGet(this, _listeners) != null;
  }
}
//# sourceMappingURL=BrowserRuntime.mjs.map