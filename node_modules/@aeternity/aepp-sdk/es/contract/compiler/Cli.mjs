import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }
function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
import _child_process from 'child_process';
const {
  execFile
} = _child_process;
import _os from 'os';
const {
  tmpdir
} = _os;
import _path from 'path';
const {
  resolve,
  dirname,
  basename
} = _path;
import _fsPromises from 'fs/promises';
const {
  mkdir,
  writeFile,
  rm
} = _fsPromises;
import _url from 'url';
const {
  fileURLToPath
} = _url;
import CompilerBase from "./Base.mjs";
import { CompilerError, InternalError, UnsupportedVersionError } from "../../utils/errors.mjs";
import semverSatisfies from "../../utils/semver-satisfies.mjs";
import { ensureError } from "../../utils/other.mjs";
const getPackagePath = () => {
  const path = dirname(fileURLToPath(import.meta.url));
  if (basename(path) === 'dist') return resolve(path, '..');
  if (basename(path) === 'compiler') return resolve(path, '../../..');
  throw new InternalError('Can\'t get package path');
};

/**
 * A wrapper around aesophia_cli, available only in Node.js.
 * Requires Erlang installed, assumes that `escript` is available in PATH.
 */
var _path2 = /*#__PURE__*/new WeakMap();
var _ensureCompatibleVersion = /*#__PURE__*/new WeakMap();
var _run = /*#__PURE__*/new WeakSet();
export default class CompilerCli extends CompilerBase {
  /**
   * @param compilerPath - A path to aesophia_cli binary, by default uses the integrated one
   * @param options - Options
   * @param options.ignoreVersion - Don't ensure that the compiler is supported
   */
  constructor() {
    let compilerPath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : resolve(getPackagePath(), './bin/aesophia_cli');
    let {
      ignoreVersion
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    super();
    _classPrivateMethodInitSpec(this, _run);
    _classPrivateFieldInitSpec(this, _path2, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _ensureCompatibleVersion, {
      writable: true,
      value: Promise.resolve()
    });
    _classPrivateFieldSet(this, _path2, compilerPath);
    if (ignoreVersion !== true) {
      _classPrivateFieldSet(this, _ensureCompatibleVersion, this.version().then(version => {
        const versions = [version, '7.2.1', '8.0.0'];
        if (!semverSatisfies(...versions)) throw new UnsupportedVersionError('compiler', ...versions);
      }));
    }
  }
  async compile(path) {
    await _classPrivateFieldGet(this, _ensureCompatibleVersion);
    try {
      const [bytecode, aci] = await Promise.all([_classPrivateMethodGet(this, _run, _run2).call(this, path), _classPrivateMethodGet(this, _run, _run2).call(this, '--create_json_aci', path).then(res => JSON.parse(res))]);
      return {
        bytecode: bytecode.trimEnd(),
        aci
      };
    } catch (error) {
      ensureError(error);
      throw new CompilerError(error.message);
    }
  }
  async compileBySourceCode(sourceCode, fileSystem) {
    const tmp = await _classStaticPrivateMethodGet(CompilerCli, CompilerCli, _saveContractToTmpDir).call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.compile(tmp);
    } finally {
      await rm(dirname(tmp), {
        recursive: true
      });
    }
  }
  async generateAci(path) {
    await _classPrivateFieldGet(this, _ensureCompatibleVersion);
    try {
      return JSON.parse(await _classPrivateMethodGet(this, _run, _run2).call(this, '--no_code', '--create_json_aci', path));
    } catch (error) {
      ensureError(error);
      throw new CompilerError(error.message);
    }
  }
  async generateAciBySourceCode(sourceCode, fileSystem) {
    const tmp = await _classStaticPrivateMethodGet(CompilerCli, CompilerCli, _saveContractToTmpDir).call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.generateAci(tmp);
    } finally {
      await rm(dirname(tmp), {
        recursive: true
      });
    }
  }
  async validate(bytecode, path) {
    await _classPrivateFieldGet(this, _ensureCompatibleVersion);
    try {
      return (await _classPrivateMethodGet(this, _run, _run2).call(this, path, '--validate', bytecode)).includes('Validation successful.');
    } catch (error) {
      return false;
    }
  }
  async validateBySourceCode(bytecode, sourceCode, fileSystem) {
    const tmp = await _classStaticPrivateMethodGet(CompilerCli, CompilerCli, _saveContractToTmpDir).call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.validate(bytecode, tmp);
    } finally {
      await rm(dirname(tmp), {
        recursive: true
      });
    }
  }
  async version() {
    var _verMessage$match;
    const verMessage = await _classPrivateMethodGet(this, _run, _run2).call(this, '--version');
    const ver = (_verMessage$match = verMessage.match(/Sophia compiler version ([\d.]+)\n/)) === null || _verMessage$match === void 0 ? void 0 : _verMessage$match[1];
    if (ver == null) throw new CompilerError('Can\'t get compiler version');
    return ver;
  }
}
async function _run2() {
  for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {
    parameters[_key] = arguments[_key];
  }
  return new Promise((pResolve, pReject) => {
    execFile('escript', [_classPrivateFieldGet(this, _path2), ...parameters], (error, stdout, stderr) => {
      if (error != null) pReject(error);else if (stderr !== '') pReject(new CompilerError(stderr));else pResolve(stdout);
    });
  });
}
async function _saveContractToTmpDir(sourceCode) {
  let fileSystem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const randomName = () => Math.random().toString(36).slice(2);
  const path = resolve(tmpdir(), `aepp-sdk-js-${randomName()}`);
  await mkdir(path);
  const sourceCodePath = resolve(path, `${randomName()}.aes`);
  await writeFile(sourceCodePath, sourceCode);
  await Promise.all(Object.entries(fileSystem).map(async _ref => {
    let [name, src] = _ref;
    const p = resolve(path, name);
    await mkdir(dirname(p), {
      recursive: true
    });
    return writeFile(p, src);
  }));
  return sourceCodePath;
}
//# sourceMappingURL=Cli.mjs.map