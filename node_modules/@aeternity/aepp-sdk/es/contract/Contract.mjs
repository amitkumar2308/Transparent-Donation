import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";
import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
/**
 * Contract module - routines to interact with the Ã¦ternity contract
 *
 * High level documentation of the contracts are available at
 * https://github.com/aeternity/protocol/tree/master/contracts and
 */

import _aeternityAeppCalldata from '@aeternity/aepp-calldata';
const {
  Encoder: Calldata
} = _aeternityAeppCalldata;
import { DRY_RUN_ACCOUNT } from "../tx/builder/schema.mjs";
import { Tag } from "../tx/builder/constants.mjs";
import { buildContractIdByContractTx, unpackTx, buildTxAsync, buildTxHash } from "../tx/builder/index.mjs";
import { decode } from "../utils/encoder.mjs";
import { MissingContractDefError, MissingContractAddressError, InactiveContractError, BytecodeMismatchError, DuplicateContractError, MissingFunctionNameError, InvalidMethodInvocationError, NotPayableFunctionError, TypeError as _TypeError, NodeInvocationError, IllegalArgumentError, NoSuchContractFunctionError, MissingEventDefinitionError, AmbiguousEventDefinitionError, UnexpectedTsError, InternalError, NoWalletConnectedError, ContractError } from "../utils/errors.mjs";
import { hash as calcHash } from "../utils/crypto.mjs";
import { getAccount, getContract, getContractByteCode, resolveName, txDryRun, sendTransaction } from "../chain.mjs";
import { isAccountNotFoundError } from "../utils/other.mjs";
var _getCallResult = /*#__PURE__*/new WeakSet();
var _sendAndProcess = /*#__PURE__*/new WeakSet();
var _getFunctionAci = /*#__PURE__*/new WeakSet();
var _getContractNameByEvent = /*#__PURE__*/new WeakSet();
var _aciContract = /*#__PURE__*/new WeakMap();
/**
 * Generate contract ACI object with predefined js methods for contract usage - can be used for
 * creating a reference to already deployed contracts
 * @category contract
 * @param options - Options object
 * @returns JS Contract API
 * @example
 * ```js
 * const contractIns = await aeSdk.initializeContract({ sourceCode })
 * await contractIns.$deploy([321]) or await contractIns.init(321)
 * const callResult = await contractIns.$call('setState', [123])
 * const staticCallResult = await contractIns.$call('setState', [123], { callStatic: true })
 * ```
 * Also you can call contract like: `await contractIns.setState(123, options)`
 * Then sdk decide to make on-chain or static call (dry-run API) transaction based on function is
 * stateful or not
 */
class Contract {
  /**
   * Compile contract
   * @returns bytecode
   */
  async $compile() {
    if (this.$options.bytecode != null) return this.$options.bytecode;
    if (this.$options.onCompiler == null) throw new IllegalArgumentError('Can\'t compile without compiler');
    if (this.$options.sourceCode != null) {
      const {
        bytecode
      } = await this.$options.onCompiler.compileBySourceCode(this.$options.sourceCode, this.$options.fileSystem);
      this.$options.bytecode = bytecode;
    }
    if (this.$options.sourceCodePath != null) {
      const {
        bytecode
      } = await this.$options.onCompiler.compile(this.$options.sourceCodePath);
      this.$options.bytecode = bytecode;
    }
    if (this.$options.bytecode == null) {
      throw new IllegalArgumentError('Can\'t compile without sourceCode and sourceCodePath');
    }
    return this.$options.bytecode;
  }
  async $getCallResultByTxHash(hash, fnName, options) {
    const {
      callInfo
    } = await this.$options.onNode.getTransactionInfoByHash(hash);
    if (callInfo == null) {
      throw new ContractError(`callInfo is not available for transaction ${hash}`);
    }
    const callInfoTyped = callInfo;
    return {
      ..._classPrivateMethodGet(this, _getCallResult, _getCallResult2).call(this, callInfoTyped, fnName, undefined, options),
      result: callInfoTyped
    };
  }
  async _estimateGas(name, params) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      result
    } = await this.$call(name, params, {
      ...options,
      callStatic: true
    });
    if (result == null) throw new UnexpectedTsError();
    const {
      gasUsed
    } = result;
    // taken from https://github.com/aeternity/aepp-sdk-js/issues/1286#issuecomment-977814771
    return Math.floor(gasUsed * 1.25);
  }

  /**
   * Deploy contract
   * @param params - Contract init function arguments array
   * @param options - Options
   * @returns deploy info
   */
  async $deploy(params, options) {
    var _opt$gasLimit, _other$result;
    const {
      callStatic,
      ...opt
    } = {
      ...this.$options,
      ...options
    };
    if (this.$options.bytecode == null) await this.$compile();
    if (callStatic === true) return this.$call('init', params, {
      ...opt,
      callStatic
    });
    if (this.$options.address != null) throw new DuplicateContractError();
    if (opt.onAccount == null) throw new IllegalArgumentError('Can\'t deploy without account');
    const ownerId = opt.onAccount.address;
    if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\'t deploy without bytecode');
    const tx = await buildTxAsync({
      ...opt,
      tag: Tag.ContractCreateTx,
      gasLimit: (_opt$gasLimit = opt.gasLimit) !== null && _opt$gasLimit !== void 0 ? _opt$gasLimit : await this._estimateGas('init', params, opt),
      callData: this._calldata.encode(this._name, 'init', params),
      code: this.$options.bytecode,
      ownerId
    });
    const {
      hash,
      ...other
    } = await _classPrivateMethodGet(this, _sendAndProcess, _sendAndProcess2).call(this, tx, 'init', {
      ...opt,
      onAccount: opt.onAccount
    });
    this.$options.address = buildContractIdByContractTx(tx);
    return {
      ...other,
      ...(((_other$result = other.result) === null || _other$result === void 0 ? void 0 : _other$result.log) != null && {
        decodedEvents: this.$decodeEvents(other.result.log, opt)
      }),
      owner: ownerId,
      transaction: hash,
      address: this.$options.address
    };
  }

  /**
   * Get function schema from contract ACI object
   * @param name - Function name
   * @returns function ACI
   */

  /**
   * Call contract function
   * @param fn - Function name
   * @param params - Array of function arguments
   * @param options - Array of function arguments
   * @returns CallResult
   */
  async $call(fn, params) {
    var _opt$gasLimit2;
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      callStatic,
      top,
      ...opt
    } = {
      ...this.$options,
      ...options
    };
    const fnAci = _classPrivateMethodGet(this, _getFunctionAci, _getFunctionAci2).call(this, fn);
    const contractId = this.$options.address;
    const {
      onNode
    } = opt;
    if (fn == null) throw new MissingFunctionNameError();
    if (fn === 'init' && callStatic !== true) throw new InvalidMethodInvocationError('"init" can be called only via dryRun');
    if (fn !== 'init' && opt.amount != null && Number(opt.amount) > 0 && !fnAci.payable) {
      throw new NotPayableFunctionError(opt.amount, fn);
    }
    let callerId;
    try {
      if (opt.onAccount == null) throw new InternalError('Use fallback account');
      callerId = opt.onAccount.address;
    } catch (error) {
      const useFallbackAccount = callStatic === true && (error instanceof _TypeError && error.message === 'Account should be an address (ak-prefixed string), or instance of AccountBase, got undefined instead' || error instanceof NoWalletConnectedError || error instanceof InternalError && error.message === 'Use fallback account');
      if (!useFallbackAccount) throw error;
      callerId = DRY_RUN_ACCOUNT.pub;
    }
    const callData = this._calldata.encode(this._name, fn, params);
    if (callStatic === true) {
      if (opt.nonce == null) {
        const topOption = top != null && {
          [typeof top === 'number' ? 'height' : 'hash']: top
        };
        const account = await getAccount(callerId, {
          ...topOption,
          onNode
        }).catch(error => {
          if (!isAccountNotFoundError(error)) throw error;
          return {
            kind: 'basic',
            nonce: 0
          };
        });
        opt.nonce = account.kind === 'generalized' ? 0 : account.nonce + 1;
      }
      const txOpt = {
        ...opt,
        onNode,
        callData
      };
      let tx;
      if (fn === 'init') {
        if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\'t dry-run "init" without bytecode');
        tx = await buildTxAsync({
          ...txOpt,
          tag: Tag.ContractCreateTx,
          code: this.$options.bytecode,
          ownerId: callerId
        });
      } else {
        if (contractId == null) throw new MissingContractAddressError('Can\'t dry-run contract without address');
        tx = await buildTxAsync({
          ...txOpt,
          tag: Tag.ContractCallTx,
          callerId,
          contractId
        });
      }
      const {
        callObj,
        ...dryRunOther
      } = await txDryRun(tx, callerId, {
        ...opt,
        top
      });
      if (callObj == null) {
        throw new InternalError(`callObj is not available for transaction ${tx}`);
      }
      const callInfoTyped = callObj;
      return {
        ...dryRunOther,
        ..._classPrivateMethodGet(this, _getCallResult, _getCallResult2).call(this, callInfoTyped, fn, tx, opt),
        tx: unpackTx(tx),
        result: callInfoTyped,
        rawTx: tx,
        hash: buildTxHash(tx),
        txData: undefined
      };
    }
    if (top != null) throw new IllegalArgumentError('Can\'t handle `top` option in on-chain contract call');
    if (contractId == null) throw new MissingContractAddressError('Can\'t call contract without address');
    const tx = await buildTxAsync({
      ...opt,
      tag: Tag.ContractCallTx,
      gasLimit: (_opt$gasLimit2 = opt.gasLimit) !== null && _opt$gasLimit2 !== void 0 ? _opt$gasLimit2 : await this._estimateGas(fn, params, opt),
      callerId,
      contractId,
      callData
    });
    if (opt.onAccount == null) throw new IllegalArgumentError('Can\'t call contract on chain without account');
    return _classPrivateMethodGet(this, _sendAndProcess, _sendAndProcess2).call(this, tx, fn, {
      ...opt,
      onAccount: opt.onAccount
    });
  }

  /**
   * @param ctAddress - Contract address that emitted event
   * @param nameHash - Hash of emitted event name
   * @param options - Options
   * @returns Contract name
   * @throws {@link MissingEventDefinitionError}
   * @throws {@link AmbiguousEventDefinitionError}
   */

  /**
   * Decode Events
   * @param events - Array of encoded events (callRes.result.log)
   * @param options - Options
   * @returns DecodedEvents
   */
  $decodeEvents(events) {
    let {
      omitUnknown,
      ...opt
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return events.map(event => {
      const topics = event.topics.map(t => BigInt(t));
      let contractName;
      try {
        contractName = _classPrivateMethodGet(this, _getContractNameByEvent, _getContractNameByEvent2).call(this, event.address, topics[0], opt);
      } catch (error) {
        if ((omitUnknown !== null && omitUnknown !== void 0 ? omitUnknown : false) && error instanceof MissingEventDefinitionError) return null;
        throw error;
      }
      const decoded = this._calldata.decodeEvent(contractName, event.data, topics);
      const [name, args] = Object.entries(decoded)[0];
      return {
        name,
        args,
        contract: {
          name: contractName,
          address: event.address
        }
      };
    }).filter(e => e != null);
  }
  static async initialize(_ref) {
    let {
      onCompiler,
      onNode,
      bytecode,
      aci,
      address,
      sourceCodePath,
      sourceCode,
      fileSystem,
      validateBytecode,
      ...otherOptions
    } = _ref;
    if (aci == null && onCompiler != null) {
      let res;
      if (sourceCodePath != null) res = await onCompiler.compile(sourceCodePath);
      if (sourceCode != null) res = await onCompiler.compileBySourceCode(sourceCode, fileSystem);
      if (res != null) {
        var _bytecode;
        aci = res.aci;
        (_bytecode = bytecode) !== null && _bytecode !== void 0 ? _bytecode : bytecode = res.bytecode;
      }
    }
    if (aci == null) throw new MissingContractDefError();
    if (address != null) {
      address = await resolveName(address, 'contract_pubkey', {
        resolveByNode: true,
        onNode
      });
    }
    if (address == null && sourceCode == null && sourceCodePath == null && bytecode == null) {
      throw new MissingContractAddressError('Can\'t create instance by ACI without address');
    }
    if (address != null) {
      const contract = await getContract(address, {
        onNode
      });
      if (contract.active == null) throw new InactiveContractError(address);
    }
    if (validateBytecode === true) {
      if (address == null) throw new MissingContractAddressError('Can\'t validate bytecode without contract address');
      const onChanBytecode = (await getContractByteCode(address, {
        onNode
      })).bytecode;
      let isValid = false;
      if (bytecode != null) isValid = bytecode === onChanBytecode;else if (sourceCode != null) {
        if (onCompiler == null) throw new IllegalArgumentError('Can\'t validate bytecode without compiler');
        isValid = await onCompiler.validateBySourceCode(onChanBytecode, sourceCode, fileSystem);
      } else if (sourceCodePath != null) {
        if (onCompiler == null) throw new IllegalArgumentError('Can\'t validate bytecode without compiler');
        isValid = await onCompiler.validate(onChanBytecode, sourceCodePath);
      }
      if (!isValid) {
        throw new BytecodeMismatchError((sourceCode !== null && sourceCode !== void 0 ? sourceCode : sourceCodePath) != null ? 'source code' : 'bytecode');
      }
    }
    return new ContractWithMethods({
      onCompiler,
      onNode,
      sourceCode,
      sourceCodePath,
      bytecode,
      aci,
      address,
      fileSystem,
      ...otherOptions
    });
  }
  constructor(_ref2) {
    var _this = this;
    let {
      aci,
      ...otherOptions
    } = _ref2;
    _classPrivateMethodInitSpec(this, _getContractNameByEvent);
    _classPrivateMethodInitSpec(this, _getFunctionAci);
    _classPrivateMethodInitSpec(this, _sendAndProcess);
    _classPrivateMethodInitSpec(this, _getCallResult);
    _classPrivateFieldInitSpec(this, _aciContract, {
      writable: true,
      value: void 0
    });
    this._aci = aci;
    const aciLast = aci[aci.length - 1];
    if (aciLast.contract == null) {
      throw new IllegalArgumentError(`The last 'aci' item should have 'contract' key, got ${Object.keys(aciLast)} keys instead`);
    }
    _classPrivateFieldSet(this, _aciContract, aciLast.contract);
    this._name = _classPrivateFieldGet(this, _aciContract).name;
    this._calldata = new Calldata(aci);
    this.$options = otherOptions;

    /**
     * Generate proto function based on contract function using Contract ACI schema
     * All function can be called like:
     * ```js
     * await contract.testFunction()
     * ```
     * then sdk will decide to use dry-run or send tx
     * on-chain base on if function stateful or not.
     * Also, you can manually do that:
     * ```js
     * await contract.testFunction({ callStatic: true }) // use call-static (dry-run)
     * await contract.testFunction({ callStatic: false }) // send tx on-chain
     * ```
     */
    Object.assign(this, Object.fromEntries(_classPrivateFieldGet(this, _aciContract).functions.map(_ref3 => {
      let {
        name,
        arguments: aciArgs,
        stateful
      } = _ref3;
      const callStatic = name !== 'init' && !stateful;
      return [name, async function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const options = args.length === aciArgs.length + 1 ? args.pop() : {};
        if (typeof options !== 'object') throw new _TypeError(`Options should be an object: ${options}`);
        if (name === 'init') return _this.$deploy(args, {
          callStatic,
          ...options
        });
        return _this.$call(name, args, {
          callStatic,
          ...options
        });
      }];
    })));
  }
}
function _getCallResult2(_ref4, fnName, transaction, options) {
  let {
    returnType,
    returnValue,
    log
  } = _ref4;
  let message;
  switch (returnType) {
    case 'ok':
      {
        const fnAci = _classPrivateMethodGet(this, _getFunctionAci, _getFunctionAci2).call(this, fnName);
        return {
          decodedResult: this._calldata.decode(this._name, fnAci.name, returnValue),
          decodedEvents: this.$decodeEvents(log, options)
        };
      }
    case 'revert':
      message = this._calldata.decodeFateString(returnValue);
      break;
    case 'error':
      message = decode(returnValue).toString();
      break;
    default:
      throw new InternalError(`Unknown return type: ${returnType}`);
  }
  throw new NodeInvocationError(message, transaction);
}
async function _sendAndProcess2(tx, fnName, options) {
  const txData = await sendTransaction(tx, {
    ...this.$options,
    ...options
  });
  return {
    hash: txData.hash,
    tx: unpackTx(txData.rawTx),
    txData,
    rawTx: txData.rawTx,
    ...(txData.blockHeight != null && (await this.$getCallResultByTxHash(txData.hash, fnName, options)))
  };
}
function _getFunctionAci2(name) {
  const fn = _classPrivateFieldGet(this, _aciContract).functions.find(f => f.name === name);
  if (fn != null) {
    return fn;
  }
  if (name === 'init') {
    return {
      arguments: [],
      name: 'init',
      payable: false,
      returns: 'unit',
      stateful: true
    };
  }
  throw new NoSuchContractFunctionError(`Function ${name} doesn't exist in contract`);
}
function _getContractNameByEvent2(ctAddress, nameHash, _ref5) {
  let {
    contractAddressToName
  } = _ref5;
  const addressToName = {
    ...this.$options.contractAddressToName,
    ...contractAddressToName
  };
  if (addressToName[ctAddress] != null) return addressToName[ctAddress];

  // TODO: consider using a third-party library
  const isEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
  const contracts = this._aci.map(_ref6 => {
    let {
      contract
    } = _ref6;
    return contract;
  }).filter(contract => contract === null || contract === void 0 ? void 0 : contract.event);
  const matchedEvents = contracts.map(contract => [contract.name, contract.event.variant]).map(_ref7 => {
    let [name, events] = _ref7;
    return events.map(event => [name, Object.keys(event)[0], Object.values(event)[0]]);
  }).flat().filter(_ref8 => {
    let [, eventName] = _ref8;
    return BigInt(`0x${calcHash(eventName).toString('hex')}`) === nameHash;
  }).filter((_ref9, idx, arr) => {
    let [,, type] = _ref9;
    return !arr.slice(0, idx).some(el => isEqual(el[2], type));
  });
  switch (matchedEvents.length) {
    case 0:
      throw new MissingEventDefinitionError(nameHash.toString(), ctAddress);
    case 1:
      return matchedEvents[0][0];
    default:
      throw new AmbiguousEventDefinitionError(ctAddress, matchedEvents);
  }
}
// eslint-disable-next-line @typescript-eslint/no-redeclare
const ContractWithMethods = Contract;
export default ContractWithMethods;
//# sourceMappingURL=Contract.mjs.map