import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";
import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
import AccountBase from "./Base.mjs";
import { ArgumentError, InternalError, InvalidAuthDataError, NotImplementedError } from "../utils/errors.mjs";
import { decode } from "../utils/encoder.mjs";
import { getAccount } from "../chain.mjs";
import Contract from "../contract/Contract.mjs";
import { buildTxAsync, buildTx } from "../tx/builder/index.mjs";
import { Tag } from "../tx/builder/constants.mjs";
/**
 * Generalized account class
 */
var _authFun = /*#__PURE__*/new WeakMap();
export default class AccountGeneralized extends AccountBase {
  /**
   * @param address - Address of generalized account
   */
  constructor(address) {
    super();
    _classPrivateFieldInitSpec(this, _authFun, {
      writable: true,
      value: void 0
    });
    decode(address);
    this.address = address;
  }

  // eslint-disable-next-line class-methods-use-this
  async sign() {
    throw new NotImplementedError('Can\'t sign using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signMessage() {
    throw new NotImplementedError('Can\'t sign using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signTypedData() {
    throw new NotImplementedError('Can\'t sign using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signNameDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signOracleQueryDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using generalized account');
  }
  async signTransaction(tx, _ref) {
    let {
      authData,
      onCompiler,
      onNode
    } = _ref;
    if (authData == null || onCompiler == null || onNode == null) {
      throw new ArgumentError('authData, onCompiler, onNode', 'provided', null);
    }
    const {
      callData,
      sourceCode,
      args,
      fee,
      gasLimit,
      gasPrice
    } = typeof authData === 'function' ? await authData(tx) : authData;
    const authCallData = callData !== null && callData !== void 0 ? callData : await (async () => {
      if (_classPrivateFieldGet(this, _authFun) == null) {
        const account = await getAccount(this.address, {
          onNode
        });
        if (account.kind !== 'generalized') {
          throw new ArgumentError('account kind', 'generalized', account.kind);
        }
        _classPrivateFieldSet(this, _authFun, account.authFun);
      }
      if (_classPrivateFieldGet(this, _authFun) == null) {
        throw new InternalError('Account in generalised, but authFun not provided');
      }
      if (sourceCode == null || args == null) {
        throw new InvalidAuthDataError('Auth data must contain sourceCode and args or callData.');
      }
      const contract = await Contract.initialize({
        onCompiler,
        onNode,
        sourceCode
      });
      return contract._calldata.encode(contract._name, _classPrivateFieldGet(this, _authFun), args);
    })();
    const gaMetaTx = await buildTxAsync({
      tag: Tag.GaMetaTx,
      tx: {
        tag: Tag.SignedTx,
        encodedTx: decode(tx),
        signatures: []
      },
      gaId: this.address,
      authData: authCallData,
      fee,
      gasLimit,
      gasPrice,
      onNode
    });
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: decode(gaMetaTx),
      signatures: []
    });
  }
}
//# sourceMappingURL=Generalized.mjs.map