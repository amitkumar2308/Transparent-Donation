import _buffer from "buffer";
const {
  Buffer: _Buffer
} = _buffer;
import AccountBase from "./Base.mjs";
import { generateKeyPairFromSecret, sign, generateKeyPair, hash, messageToHash } from "../utils/crypto.mjs";
import { ArgumentError } from "../utils/errors.mjs";
import { decode, encode, Encoding } from "../utils/encoder.mjs";
import { concatBuffers } from "../utils/other.mjs";
import { hashTypedData } from "../utils/typed-data.mjs";
import { buildTx } from "../tx/builder/index.mjs";
import { Tag } from "../tx/builder/constants.mjs";
import { produceNameId } from "../tx/builder/helpers.mjs";
const secretKeys = new WeakMap();
export function getBufferToSign(transaction, networkId, innerTx) {
  const prefixes = [networkId];
  if (innerTx) prefixes.push('inner_tx');
  const rlpBinaryTx = decode(transaction);
  return concatBuffers([_Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)]);
}

/**
 * In-memory account class
 */
export default class AccountMemory extends AccountBase {
  /**
   * @param secretKey - Secret key
   */
  constructor(secretKey) {
    super();
    secretKey = typeof secretKey === 'string' ? _Buffer.from(secretKey, 'hex') : secretKey;
    if (secretKey.length !== 64) {
      throw new ArgumentError('secretKey', '64 bytes', secretKey.length);
    }
    secretKeys.set(this, secretKey);
    this.address = encode(generateKeyPairFromSecret(secretKeys.get(this)).publicKey, Encoding.AccountAddress);
  }

  /**
   * Generates a new AccountMemory using a random secret key
   */
  static generate() {
    return new AccountMemory(generateKeyPair().secretKey);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async sign(data, options) {
    return sign(data, secretKeys.get(this));
  }
  async signTransaction(transaction) {
    let {
      innerTx,
      networkId,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (networkId == null) {
      throw new ArgumentError('networkId', 'provided', networkId);
    }
    const rlpBinaryTx = decode(transaction);
    const txWithNetworkId = getBufferToSign(transaction, networkId, innerTx === true);
    const signatures = [await this.sign(txWithNetworkId, options)];
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: rlpBinaryTx,
      signatures
    });
  }
  async signMessage(message, options) {
    return this.sign(messageToHash(message), options);
  }
  async signTypedData(data, aci) {
    let {
      name,
      version,
      networkId,
      contractAddress,
      ...options
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const dHash = hashTypedData(data, aci, {
      name,
      version,
      networkId,
      contractAddress
    });
    const signature = await this.sign(dHash, options);
    return encode(signature, Encoding.Signature);
  }
  async signDelegationToContract(contractAddress) {
    let {
      networkId
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const payload = concatBuffers([_Buffer.from(networkId), decode(this.address), decode(contractAddress)]);
    const signature = await this.sign(payload);
    return encode(signature, Encoding.Signature);
  }
  async signNameDelegationToContract(contractAddress, name) {
    let {
      networkId
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const payload = concatBuffers([_Buffer.from(networkId), decode(this.address), decode(produceNameId(name)), decode(contractAddress)]);
    const signature = await this.sign(payload);
    return encode(signature, Encoding.Signature);
  }
  async signOracleQueryDelegationToContract(contractAddress, oracleQueryId) {
    let {
      networkId
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const oracleQueryIdDecoded = decode(oracleQueryId);
    const addressDecoded = decode(this.address);
    // TODO: remove after fixing https://github.com/aeternity/aesophia/issues/475
    if (oracleQueryIdDecoded.compare(addressDecoded) === 0) {
      throw new ArgumentError('oracleQueryId', 'not equal to account address', oracleQueryId);
    }
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const payload = concatBuffers([_Buffer.from(networkId), oracleQueryIdDecoded, decode(contractAddress)]);
    const signature = await this.sign(payload);
    return encode(signature, Encoding.Signature);
  }
}
//# sourceMappingURL=Memory.mjs.map