import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import { CompilerError, DuplicateNodeError, NodeNotFoundError, NotImplementedError, TypeError } from "./utils/errors.mjs";
import AeSdkMethods, { getValueOrErrorProxy } from "./AeSdkMethods.mjs";
/**
 * Basic AeSdk class implements:
 * - node selector,
 * - integrated compiler support,
 * - wrappers of account methods mapped to the current account.
 */
export default class AeSdkBase extends AeSdkMethods {
  /**
   * @param options - Options
   * @param options.nodes - Array of nodes
   */
  constructor() {
    let {
      nodes = [],
      ...options
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(options);
    _defineProperty(this, "pool", new Map());
    nodes.forEach((_ref, i) => {
      let {
        name,
        instance
      } = _ref;
      return this.addNode(name, instance, i === 0);
    });
  }

  // TODO: consider dropping this getter, because:
  // compiler is not intended to be used separately any more (functionality limited to sdk needs)
  // and user creates its instance by himself
  get compilerApi() {
    if (this._options.onCompiler == null) {
      throw new CompilerError('You can\'t use Compiler API. Compiler is not ready!');
    }
    return this._options.onCompiler;
  }
  get api() {
    this.ensureNodeConnected();
    return this.pool.get(this.selectedNodeName);
  }

  /**
   * Add Node
   * @param name - Node name
   * @param node - Node instance
   * @param select - Select this node as current
   * @example
   * ```js
   * // add and select new node with name 'testNode'
   * aeSdkBase.addNode('testNode', new Node({ url }), true)
   * ```
   */
  addNode(name, node) {
    let select = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    if (this.pool.has(name)) throw new DuplicateNodeError(name);
    this.pool.set(name, node);
    if (select || this.selectedNodeName == null) {
      this.selectNode(name);
    }
  }

  /**
   * Select Node
   * @param name - Node name
   * @example
   * nodePool.selectNode('testNode')
   */
  selectNode(name) {
    if (!this.pool.has(name)) throw new NodeNotFoundError(`Node with name ${name} not in pool`);
    this.selectedNodeName = name;
  }

  /**
   * Check if you have selected node
   * @example
   * nodePool.isNodeConnected()
   */
  isNodeConnected() {
    return this.selectedNodeName != null;
  }
  ensureNodeConnected() {
    if (!this.isNodeConnected()) {
      throw new NodeNotFoundError('You can\'t use Node API. Node is not connected or not defined!');
    }
  }

  /**
   * Get information about node
   * @example
   * ```js
   * nodePool.getNodeInfo() // { name, version, networkId, protocol, ... }
   * ```
   */
  async getNodeInfo() {
    this.ensureNodeConnected();
    return {
      name: this.selectedNodeName,
      ...(await this.api.getNodeInfo())
    };
  }

  /**
   * Get array of available nodes
   * @example
   * nodePool.getNodesInPool()
   */
  async getNodesInPool() {
    return Promise.all(Array.from(this.pool.entries()).map(async _ref2 => {
      let [name, node] = _ref2;
      return {
        name,
        ...(await node.getNodeInfo())
      };
    }));
  }

  // eslint-disable-next-line class-methods-use-this
  addresses() {
    return [];
  }

  /**
   * Resolves an account
   * @param account - ak-address, instance of AccountBase, or keypair
   */
  _resolveAccount() {
    let account = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._options.onAccount;
    if (typeof account === 'string') throw new NotImplementedError('Address in AccountResolver');
    if (typeof account === 'object') return account;
    throw new TypeError('Account should be an address (ak-prefixed string), ' + `or instance of AccountBase, got ${String(account)} instead`);
  }
  get address() {
    return this._resolveAccount().address;
  }
  async sign(data) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this._resolveAccount(onAccount).sign(data, options);
  }
  async signTransaction(tx) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    const networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signTransaction(tx, {
      networkId,
      ...options
    });
  }
  async signMessage(message) {
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return this._resolveAccount(onAccount).signMessage(message, options);
  }
  async signTypedData(data, aci) {
    let {
      onAccount,
      ...options
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return this._resolveAccount(onAccount).signTypedData(data, aci, options);
  }
  async signDelegationToContract(contractAddress) {
    var _options$networkId;
    let {
      onAccount,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    (_options$networkId = options.networkId) !== null && _options$networkId !== void 0 ? _options$networkId : options.networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signDelegationToContract(contractAddress, options);
  }
  async signNameDelegationToContract(contractAddress, name) {
    var _options$networkId2;
    let {
      onAccount,
      ...options
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (_options$networkId2 = options.networkId) !== null && _options$networkId2 !== void 0 ? _options$networkId2 : options.networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signNameDelegationToContract(contractAddress, name, options);
  }
  async signOracleQueryDelegationToContract(contractAddress, oracleQueryId) {
    var _options$networkId3;
    let {
      onAccount,
      ...options
    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (_options$networkId3 = options.networkId) !== null && _options$networkId3 !== void 0 ? _options$networkId3 : options.networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signOracleQueryDelegationToContract(contractAddress, oracleQueryId, options);
  }
  _getOptions() {
    let callOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return {
      ...this._options,
      onNode: getValueOrErrorProxy(() => this.api),
      onCompiler: getValueOrErrorProxy(() => this.compilerApi),
      ...callOptions,
      onAccount: getValueOrErrorProxy(() => this._resolveAccount(callOptions.onAccount))
    };
  }
}
//# sourceMappingURL=AeSdkBase.mjs.map