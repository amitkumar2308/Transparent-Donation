{"version":3,"file":"crypto.mjs","names":["nacl","_blakejsBlake2bJs","blake2b","_varuintBitcoin","encode","varuintEncode","concatBuffers","decode","Encoding","ArgumentError","getAddressFromPriv","secret","secretBuffer","_Buffer","from","keys","sign","keyPair","fromSecretKey","publicKey","AccountAddress","isAddressValid","address","prefix","arguments","length","undefined","actualPrefix","split","e","genSalt","random","BigUint64Array","randomBytes","buffer","Number","BigInt","MAX_SAFE_INTEGER","encodeUnsigned","value","binary","allocUnsafe","writeUInt32BE","slice","findIndex","i","hash","input","encodeContractAddress","owner","nonce","ContractAddress","generateKeyPairFromSecret","generateKeyPair","raw","publicBuffer","secretKey","toString","data","privateKey","detached","verify","signature","messagePrefix","messagePrefixLength","messageToHash","message","msg","signMessage","verifyMessage","isValidKeypair","publicKeyBuffer"],"sources":["../../src/utils/crypto.ts"],"sourcesContent":["import nacl, { SignKeyPair } from 'tweetnacl';\n// js extension is required for mjs build, not importing the whole package to reduce bundle size\n// eslint-disable-next-line import/extensions\nimport { blake2b } from 'blakejs/blake2b.js';\nimport { encode as varuintEncode } from 'varuint-bitcoin';\n\nimport { concatBuffers } from './other';\nimport {\n  decode, encode, Encoded, Encoding,\n} from './encoder';\nimport { ArgumentError } from './errors';\n\n/**\n * Generate address from secret key\n * @param secret - Private key as hex string\n * @returns Public key encoded as address\n */\nexport function getAddressFromPriv(secret: string | Uint8Array): Encoded.AccountAddress {\n  const secretBuffer = typeof secret === 'string' ? Buffer.from(secret, 'hex') : secret;\n  const keys = nacl.sign.keyPair.fromSecretKey(secretBuffer);\n  return encode(keys.publicKey, Encoding.AccountAddress);\n}\n\n/**\n * Check if address is valid\n * @param address - Address\n * @param prefix - Transaction prefix. Default: 'ak'\n * @returns is valid\n */\nexport function isAddressValid(\n  address: string,\n  prefix: Encoding = Encoding.AccountAddress,\n): boolean {\n  try {\n    decode(address as Encoded.Generic<typeof prefix>);\n    const actualPrefix = address.split('_')[0];\n    if (actualPrefix !== prefix) {\n      throw new ArgumentError('Encoded string type', prefix, actualPrefix);\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\n/**\n * Generate a random salt (positive integer)\n * @returns random salt\n */\nexport function genSalt(): number {\n  const [random] = new BigUint64Array(nacl.randomBytes(8).buffer);\n  return Number(random % BigInt(Number.MAX_SAFE_INTEGER));\n}\n\n/**\n * Converts a positive integer to the smallest possible\n * representation in a binary digit representation\n * @param value - Value to encode\n * @returns Encoded number\n */\nexport function encodeUnsigned(value: number): Buffer {\n  const binary = Buffer.allocUnsafe(4);\n  binary.writeUInt32BE(value);\n  return binary.slice(binary.findIndex((i) => i !== 0));\n}\n\n/**\n * Calculate 256bits Blake2b hash of `input`\n * @param input - Data to hash\n * @returns Hash\n */\nexport function hash(input: string | Uint8Array): Buffer {\n  return Buffer.from(blake2b(input, undefined, 32)); // 256 bits\n}\n\n// Todo Duplicated in tx builder. remove\n/**\n * Compute contract address\n * @category contract\n * @param owner - Address of contract owner\n * @param nonce - Round when contract was created\n * @returns Contract address\n */\nexport function encodeContractAddress(\n  owner: Encoded.AccountAddress,\n  nonce: number,\n): Encoded.ContractAddress {\n  const publicKey = decode(owner);\n  const binary = concatBuffers([publicKey, encodeUnsigned(nonce)]);\n  return encode(hash(binary), Encoding.ContractAddress);\n}\n\n// KEY-PAIR HELPERS\n\n/**\n * Generate keyPair from secret key\n * @param secret - secret key\n * @returns Object with Private(privateKey) and Public(publicKey) keys\n */\nexport function generateKeyPairFromSecret(secret: Uint8Array): SignKeyPair {\n  return nacl.sign.keyPair.fromSecretKey(secret);\n}\n\n/**\n * Generate a random ED25519 keypair\n * @param raw - Whether to return raw (binary) keys\n * @returns Key pair\n */\nexport function generateKeyPair(raw: true): { publicKey: Buffer; secretKey: Buffer };\nexport function generateKeyPair(raw?: false): {\n  publicKey: Encoded.AccountAddress; secretKey: string;\n};\nexport function generateKeyPair(raw = false): {\n  publicKey: Encoded.AccountAddress | Buffer;\n  secretKey: string | Buffer;\n} {\n  const keyPair = nacl.sign.keyPair();\n  const publicBuffer = Buffer.from(keyPair.publicKey);\n  const secretBuffer = Buffer.from(keyPair.secretKey);\n\n  if (raw) {\n    return {\n      publicKey: publicBuffer,\n      secretKey: secretBuffer,\n    };\n  }\n  return {\n    publicKey: encode(publicBuffer, Encoding.AccountAddress),\n    secretKey: secretBuffer.toString('hex'),\n  };\n}\n\n// SIGNATURES\n\n/**\n * Generate signature\n * @param data - Data to sign\n * @param privateKey - Key to sign with\n * @returns Signature\n */\nexport function sign(data: string | Uint8Array, privateKey: string | Uint8Array): Uint8Array {\n  return nacl.sign.detached(Buffer.from(data), Buffer.from(privateKey));\n}\n\n/**\n * Verify that signature was signed by public key\n * @param data - Data that was signed\n * @param signature - Signature of data\n * @param address - Address to verify against\n * @returns is data was signed by address\n */\nexport function verify(\n  data: Uint8Array,\n  signature: Uint8Array,\n  address: Encoded.AccountAddress,\n): boolean {\n  return nacl.sign.detached.verify(data, signature, decode(address));\n}\n\nconst messagePrefix = Buffer.from('aeternity Signed Message:\\n', 'utf8');\nexport const messagePrefixLength = varuintEncode(messagePrefix.length);\n\n// TODO: consider rename to hashMessage\nexport function messageToHash(message: string): Buffer {\n  const msg = Buffer.from(message, 'utf8');\n  return hash(concatBuffers([messagePrefixLength, messagePrefix, varuintEncode(msg.length), msg]));\n}\n\nexport function signMessage(message: string, privateKey: string | Buffer): Uint8Array {\n  return sign(messageToHash(message), privateKey);\n}\n\n/**\n * Verify that message was signed by address\n * @param message - Message that was signed\n * @param signature - Signature of message\n * @param address - Address to verify against\n * @returns is data was signed by address\n */\n// TODO: deprecate in favour of `verify(messageToHash(message), ...`, also the name is confusing\n// it should contain \"signature\"\nexport function verifyMessage(\n  message: string,\n  signature: Uint8Array,\n  address: Encoded.AccountAddress,\n): boolean {\n  return verify(messageToHash(message), signature, address);\n}\n\n/**\n * Check key pair for validity\n *\n * Signs a message, and then verifies that signature\n * @param privateKey - Private key to verify\n * @param publicKey - Public key to verify as hex string\n * @returns Valid?\n */\nexport function isValidKeypair(\n  privateKey: string | Uint8Array,\n  publicKey: string | Uint8Array,\n): boolean {\n  const message = Buffer.from('TheMessage');\n  const signature = sign(message, privateKey);\n  const publicKeyBuffer = typeof publicKey === 'string' ? Buffer.from(publicKey, 'hex') : publicKey;\n  return verify(message, signature, encode(publicKeyBuffer, Encoding.AccountAddress));\n}\n"],"mappings":"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"}