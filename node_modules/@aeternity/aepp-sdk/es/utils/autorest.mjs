import { RestError } from '@azure/core-rest-pipeline';
import { pause } from "./other.mjs";
import semverSatisfies from "./semver-satisfies.mjs";
import { UnsupportedVersionError } from "./errors.mjs";
export const genRequestQueuesPolicy = () => {
  const requestQueues = new Map();
  return {
    policy: {
      name: 'request-queues',
      async sendRequest(request, next) {
        var _requestQueues$get;
        const key = request.headers.get('__queue');
        request.headers.delete('__queue');
        const getResponse = async () => next(request);
        if (key == null) return getResponse();
        const req = ((_requestQueues$get = requestQueues.get(key)) !== null && _requestQueues$get !== void 0 ? _requestQueues$get : Promise.resolve()).then(getResponse);
        // TODO: remove pause after fixing https://github.com/aeternity/aeternity/issues/3803
        // gap to ensure that node won't reject the nonce
        requestQueues.set(key, req.then(async () => pause(750), () => {}));
        return req;
      }
    },
    position: 'perCall'
  };
};
export const genCombineGetRequestsPolicy = () => {
  const pendingGetRequests = new Map();
  return {
    policy: {
      name: 'combine-get-requests',
      async sendRequest(request, next) {
        var _pendingGetRequests$g;
        if (request.method !== 'GET') return next(request);
        const key = JSON.stringify([request.url, request.body]);
        const response = (_pendingGetRequests$g = pendingGetRequests.get(key)) !== null && _pendingGetRequests$g !== void 0 ? _pendingGetRequests$g : next(request);
        pendingGetRequests.set(key, response);
        try {
          return await response;
        } finally {
          pendingGetRequests.delete(key);
        }
      }
    },
    position: 'perCall'
  };
};
export const genAggressiveCacheGetResponsesPolicy = () => {
  const getRequests = new Map();
  return {
    policy: {
      name: 'aggressive-cache-get-responses',
      async sendRequest(request, next) {
        var _getRequests$get;
        if (request.method !== 'GET') return next(request);
        const key = JSON.stringify([request.url, request.body]);
        const response = (_getRequests$get = getRequests.get(key)) !== null && _getRequests$get !== void 0 ? _getRequests$get : next(request);
        getRequests.set(key, response);
        return response;
      }
    },
    position: 'perCall'
  };
};
export const genErrorFormatterPolicy = getMessage => ({
  policy: {
    name: 'error-formatter',
    async sendRequest(request, next) {
      try {
        return await next(request);
      } catch (error) {
        var _error$response;
        if (!(error instanceof RestError) || error.request == null) throw error;
        if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.bodyAsText) == null) throw error;
        let body;
        try {
          body = JSON.parse(error.response.bodyAsText);
        } catch (e) {
          throw error;
        }
        error.message = `${new URL(error.request.url).pathname.slice(1)} error`;
        const message = getMessage(body);
        if (message !== '') error.message += `:${message}`;
        throw error;
      }
    }
  },
  position: 'perCall'
});
export const genVersionCheckPolicy = (name, ignorePath, versionPromise, geVersion, ltVersion) => ({
  name: 'version-check',
  async sendRequest(request, next) {
    if (new URL(request.url).pathname === ignorePath) return next(request);
    const version = await versionPromise;
    if (version instanceof Error) throw version;
    const args = [version, geVersion, ltVersion];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError(name, ...args);
    return next(request);
  }
});
export const genRetryOnFailurePolicy = (retryCount, retryOverallDelay) => ({
  policy: {
    name: 'retry-on-failure',
    async sendRequest(request, next) {
      const statusesToNotRetry = [200, 400, 403, 500];
      const intervals = new Array(retryCount).fill(0).map((_, idx) => ((idx + 1) / retryCount) ** 2);
      const intervalSum = intervals.reduce((a, b) => a + b);
      const intervalsInMs = intervals.map(el => el / intervalSum * retryOverallDelay);
      let error = new RestError('Not expected to be thrown');
      for (let attempt = 0; attempt <= retryCount; attempt += 1) {
        if (attempt !== 0) await pause(intervalsInMs[attempt - 1]);
        try {
          return await next(request);
        } catch (e) {
          var _e$response$status, _e$response;
          if (!(e instanceof RestError)) throw e;
          if (statusesToNotRetry.includes((_e$response$status = (_e$response = e.response) === null || _e$response === void 0 ? void 0 : _e$response.status) !== null && _e$response$status !== void 0 ? _e$response$status : 0)) throw e;
          error = e;
        }
      }
      throw error;
    }
  },
  position: 'perCall'
});
//# sourceMappingURL=autorest.mjs.map