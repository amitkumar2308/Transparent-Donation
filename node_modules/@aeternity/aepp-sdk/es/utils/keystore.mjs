import _buffer from "buffer";
const {
  Buffer: _Buffer
} = _buffer;
import nacl from 'tweetnacl';
import { v4 as uuid } from '@aeternity/uuid';
import _aeternityArgon from '@aeternity/argon2';
const {
  hash,
  argon2id
} = _aeternityArgon;
import { getAddressFromPriv } from "./crypto.mjs";
import { InvalidPasswordError } from "./errors.mjs";
const DERIVED_KEY_FUNCTIONS = {
  async argon2id(pass, salt, params) {
    const {
      memlimit_kib: memoryCost,
      opslimit: timeCost
    } = params;
    return hash(pass, {
      hashLength: 32,
      salt,
      timeCost,
      memoryCost,
      type: argon2id
    });
  }
};
const CRYPTO_FUNCTIONS = {
  'xsalsa20-poly1305': {
    encrypt: nacl.secretbox,
    decrypt() {
      const res = nacl.secretbox.open(...arguments);
      if (res == null) throw new InvalidPasswordError();
      return res;
    }
  }
};
const CRYPTO_DEFAULTS = {
  secret_type: 'ed25519',
  symmetric_alg: 'xsalsa20-poly1305',
  kdf: 'argon2id',
  kdf_params: {
    memlimit_kib: 65536,
    opslimit: 3,
    parallelism: 1
  }
};

/**
 * Symmetric private key encryption using secret (derived) key.
 * @category keystore
 * @param plaintext - Data to be encrypted.
 * @param key - Secret key.
 * @param nonce - Randomly generated nonce.
 * @param algo - Encryption algorithm.
 * @returns Encrypted data.
 */
function encrypt(plaintext, key, nonce) {
  let algo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CRYPTO_DEFAULTS.symmetric_alg;
  return CRYPTO_FUNCTIONS[algo].encrypt(plaintext, nonce, key);
}

/**
 * Symmetric private key decryption using secret (derived) key.
 * @category keystore
 * @param ciphertext - Data to be decrypted.
 * @param key - Secret key.
 * @param nonce - Nonce from key-object.
 * @param algo - Encryption algorithm.
 * @returns Decrypted data.
 */
function decrypt(ciphertext, key, nonce) {
  let algo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CRYPTO_DEFAULTS.symmetric_alg;
  return CRYPTO_FUNCTIONS[algo].decrypt(ciphertext, nonce, key);
}

/**
 * Derive secret key from password with key derivation function.
 * @category keystore
 * @param password - User-supplied password.
 * @param nonce - Randomly generated nonce.
 * @param kdf - Key derivation function.
 * @param kdfParams - KDF parameters.
 * @returns Secret key derived from password.
 */
async function deriveKey(password, nonce, kdf, kdfParams) {
  return DERIVED_KEY_FUNCTIONS[kdf](password, nonce, kdfParams);
}

/**
 * Recover plaintext private key from secret-storage key object.
 * @category keystore
 * @param password - Keystore object password.
 * @param keystore - Keystore object.
 * @returns Plaintext private key.
 */
export async function recover(password, _ref) {
  let {
    crypto
  } = _ref;
  const salt = _Buffer.from(crypto.kdf_params.salt, 'hex');
  return _Buffer.from(decrypt(_Buffer.from(crypto.ciphertext, 'hex'), await deriveKey(password, salt, crypto.kdf, crypto.kdf_params), _Buffer.from(crypto.cipher_params.nonce, 'hex'), crypto.symmetric_alg)).toString('hex');
}

/**
 * Export private key to keystore secret-storage format.
 * @category keystore
 * @param name - Key name.
 * @param password - User-supplied password.
 * @param privateKey - Private key as hex-string or a Buffer.
 * @param nonce - Randomly generated 24byte nonce.
 * @param salt - Randomly generated 16byte salt.
 * @param options - Encryption parameters.
 * @param options.kdf - Key derivation function.
 * @param options.kdf_params - KDF parameters.
 */
export async function dump(name, password, privateKey) {
  let nonce = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : nacl.randomBytes(24);
  let salt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : nacl.randomBytes(16);
  let options = arguments.length > 5 ? arguments[5] : undefined;
  const opt = {
    ...CRYPTO_DEFAULTS,
    ...options
  };
  const derivedKey = await deriveKey(password, salt, opt.kdf, opt.kdf_params);
  const payload = typeof privateKey === 'string' ? _Buffer.from(privateKey, 'hex') : privateKey;
  return {
    name,
    version: 1,
    public_key: getAddressFromPriv(payload),
    id: uuid(),
    crypto: {
      secret_type: opt.secret_type,
      symmetric_alg: opt.symmetric_alg,
      ciphertext: _Buffer.from(encrypt(payload, derivedKey, nonce, opt.symmetric_alg)).toString('hex'),
      cipher_params: {
        nonce: _Buffer.from(nonce).toString('hex')
      },
      kdf: opt.kdf,
      kdf_params: {
        ...opt.kdf_params,
        salt: _Buffer.from(salt).toString('hex')
      }
    }
  };
}
//# sourceMappingURL=keystore.mjs.map