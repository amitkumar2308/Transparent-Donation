import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";
import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
/* eslint-disable max-classes-per-file */
import WebSocket from 'isomorphic-ws';
import { BaseError, UnexpectedTsError, InternalError } from "./utils/errors.mjs";
var Source = /*#__PURE__*/function (Source) {
  Source["Middleware"] = "mdw";
  Source["Node"] = "node";
  Source["All"] = "all";
  return Source;
}(Source || {});
export class MiddlewareSubscriberError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'MiddlewareSubscriberError';
  }
}
export class MiddlewareSubscriberDisconnected extends MiddlewareSubscriberError {
  constructor(closeEvent) {
    super('Connection closed');
    this.closeEvent = closeEvent;
    this.name = 'MiddlewareSubscriberDisconnected';
  }
}
var _subscriptions = /*#__PURE__*/new WeakMap();
var _requestQueue = /*#__PURE__*/new WeakMap();
var _webSocket = /*#__PURE__*/new WeakMap();
var _targets = /*#__PURE__*/new WeakMap();
var _sendMessage = /*#__PURE__*/new WeakSet();
var _sendSubscribe = /*#__PURE__*/new WeakSet();
var _emit = /*#__PURE__*/new WeakSet();
var _disconnect = /*#__PURE__*/new WeakSet();
var _messageHandler = /*#__PURE__*/new WeakSet();
var _subscribe = /*#__PURE__*/new WeakSet();
export default class MiddlewareSubscriber {
  get webSocket() {
    return _classPrivateFieldGet(this, _webSocket);
  }
  constructor(url) {
    _classPrivateMethodInitSpec(this, _subscribe);
    _classPrivateMethodInitSpec(this, _messageHandler);
    _classPrivateMethodInitSpec(this, _disconnect);
    _classPrivateMethodInitSpec(this, _emit);
    _classPrivateMethodInitSpec(this, _sendSubscribe);
    _classPrivateMethodInitSpec(this, _sendMessage);
    _classPrivateFieldInitSpec(this, _targets, {
      get: _get_targets,
      set: void 0
    });
    _classPrivateFieldInitSpec(this, _subscriptions, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec(this, _requestQueue, {
      writable: true,
      value: []
    });
    _classPrivateFieldInitSpec(this, _webSocket, {
      writable: true,
      value: void 0
    });
    this.url = url;
  }
  async reconnect() {
    _classPrivateMethodGet(this, _disconnect, _disconnect2).call(this);
    _classPrivateFieldSet(this, _webSocket, await new Promise(resolve => {
      const webSocket = new WebSocket(this.url);
      Object.assign(webSocket, {
        onopen: () => resolve(webSocket),
        onerror: errorEvent => {
          _classPrivateMethodGet(this, _emit, _emit2).call(this, () => true, undefined, errorEvent.error);
        },
        onmessage: event => {
          if (typeof event.data !== 'string') {
            throw new InternalError(`Unknown incoming message type: ${typeof event.data}`);
          }
          _classPrivateMethodGet(this, _messageHandler, _messageHandler2).call(this, JSON.parse(event.data));
        },
        onclose: event => {
          _classPrivateMethodGet(this, _emit, _emit2).call(this, () => true, undefined, new MiddlewareSubscriberDisconnected(event));
          _classPrivateMethodGet(this, _disconnect, _disconnect2).call(this, true);
        }
      });
    }));
    await Promise.all([..._classPrivateFieldGet(this, _targets)].map(target => _classPrivateMethodGet(this, _sendSubscribe, _sendSubscribe2).call(this, true, target)));
  }
  // TODO: replace p?: any with a proper type definition

  subscribeKeyBlocks(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'KeyBlocks', Source.Middleware, cb);
  }
  subscribeKeyBlocksNode(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'KeyBlocks', Source.Node, cb);
  }
  subscribeKeyBlocksAll(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'KeyBlocks', Source.All, cb);
  }
  subscribeMicroBlocks(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'MicroBlocks', Source.Middleware, cb);
  }
  subscribeMicroBlocksNode(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'MicroBlocks', Source.Node, cb);
  }
  subscribeMicroBlocksAll(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'MicroBlocks', Source.All, cb);
  }
  subscribeTransactions(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'Transactions', Source.Middleware, cb);
  }
  subscribeTransactionsNode(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'Transactions', Source.Node, cb);
  }
  subscribeTransactionsAll(cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'Transactions', Source.All, cb);
  }
  subscribeObject(target, cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, target, Source.Middleware, cb);
  }
  subscribeObjectNode(target, cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, target, Source.Node, cb);
  }
  subscribeObjectAll(target, cb) {
    return _classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, target, Source.All, cb);
  }
}
function _get_targets() {
  return new Set(_classPrivateFieldGet(this, _subscriptions).map(_ref => {
    let [target] = _ref;
    return target;
  }));
}
function _sendMessage2(message) {
  if (_classPrivateFieldGet(this, _webSocket) == null) throw new UnexpectedTsError();
  _classPrivateFieldGet(this, _webSocket).send(JSON.stringify(message));
}
function _sendSubscribe2(isSubscribe, target) {
  if (_classPrivateFieldGet(this, _webSocket) == null) return;
  const payload = ['KeyBlocks', 'MicroBlocks', 'Transactions'].includes(target) ? target : 'Object';
  _classPrivateMethodGet(this, _sendMessage, _sendMessage2).call(this, {
    op: isSubscribe ? 'Subscribe' : 'Unsubscribe',
    payload,
    ...(payload === 'Object' && {
      target
    })
  });
  _classPrivateFieldGet(this, _requestQueue).push([isSubscribe, target]);
}
function _emit2(condition, p, e) {
  _classPrivateFieldGet(this, _subscriptions).filter(_ref2 => {
    let [target, source] = _ref2;
    return condition(target, source);
  }).forEach(_ref3 => {
    let [,, cb] = _ref3;
    return cb(p, e);
  });
}
function _disconnect2() {
  let onlyReset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  if (_classPrivateFieldGet(this, _webSocket) == null) return;
  if (!onlyReset) _classPrivateFieldGet(this, _webSocket).close();
  Object.assign(_classPrivateFieldGet(this, _webSocket), {
    onopen: undefined,
    onerror: undefined,
    onmessage: undefined
  });
  _classPrivateFieldSet(this, _webSocket, undefined);
}
function _messageHandler2(message) {
  if (typeof message === 'string' || Array.isArray(message)) {
    const request = _classPrivateFieldGet(this, _requestQueue).shift();
    if (request == null) throw new InternalError('Request queue is empty');
    const [isSubscribe, target] = request;
    let error;
    if (typeof message === 'string') error = new MiddlewareSubscriberError(message);
    if (message.includes(target) !== isSubscribe) {
      error = new InternalError(`Expected ${target} to be${isSubscribe ? '' : ' not'} included into ${message}`);
    }
    if (error != null) _classPrivateMethodGet(this, _emit, _emit2).call(this, t => target === t, undefined, error);
    return;
  }
  _classPrivateMethodGet(this, _emit, _emit2).call(this, (target, source) => (target === message.subscription || target === message.target) && (source === message.source || source === Source.All), message.payload);
}
function _subscribe2(target, source, cb) {
  const subscription = [target, source, cb];
  if (_classPrivateFieldGet(this, _targets).size === 0) this.reconnect();
  if (!_classPrivateFieldGet(this, _targets).has(target)) _classPrivateMethodGet(this, _sendSubscribe, _sendSubscribe2).call(this, true, target);
  _classPrivateFieldGet(this, _subscriptions).push(subscription);
  return () => {
    _classPrivateFieldSet(this, _subscriptions, _classPrivateFieldGet(this, _subscriptions).filter(item => item !== subscription));
    if (!_classPrivateFieldGet(this, _targets).has(target)) _classPrivateMethodGet(this, _sendSubscribe, _sendSubscribe2).call(this, false, target);
    if (_classPrivateFieldGet(this, _targets).size === 0) _classPrivateMethodGet(this, _disconnect, _disconnect2).call(this);
  };
}
//# sourceMappingURL=MiddlewareSubscriber.mjs.map