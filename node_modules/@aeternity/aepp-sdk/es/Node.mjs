import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
// eslint-disable-next-line max-classes-per-file
import BigNumber from 'bignumber.js';
import { genRequestQueuesPolicy, genCombineGetRequestsPolicy, genErrorFormatterPolicy, genVersionCheckPolicy, genRetryOnFailurePolicy } from "./utils/autorest.mjs";
import { Node as NodeApi } from "./apis/node/index.mjs";
import { mapObject } from "./utils/other.mjs";
import { UnsupportedVersionError } from "./utils/errors.mjs";
import { ConsensusProtocolVersion } from "./tx/builder/constants.mjs";
const bigIntPropertyNames = ['balance', 'queryFee', 'fee', 'amount', 'nameFee', 'channelAmount', 'initiatorAmount', 'responderAmount', 'channelReserve', 'initiatorAmountFinal', 'responderAmountFinal', 'gasPrice', 'deposit'];
const numberPropertyNames = ['time', 'gas', 'gasUsed', 'nameSalt', 'nonce', 'nextNonce', 'height', 'blockHeight', 'topBlockHeight', 'ttl', 'nameTtl', 'clientTtl', 'inbound', 'outbound', 'peerCount', 'pendingTransactionsCount', 'effectiveAtHeight', 'version', 'solutions', 'round'];
var _mapData = /*#__PURE__*/new WeakSet();
var _encodeArg = /*#__PURE__*/new WeakSet();
var _decodeRes = /*#__PURE__*/new WeakSet();
class NodeTransformed extends NodeApi {
  constructor() {
    super(...arguments);
    _classPrivateMethodInitSpec(this, _decodeRes);
    _classPrivateMethodInitSpec(this, _encodeArg);
    _classPrivateMethodInitSpec(this, _mapData);
  }
  async sendOperationRequest(operationArguments, operationSpec) {
    const args = mapObject(operationArguments, _ref => {
      let [key, value] = _ref;
      return [key, _classPrivateMethodGet(this, _encodeArg, _encodeArg2).call(this, value)];
    });
    return _classPrivateMethodGet(this, _decodeRes, _decodeRes2).call(this, await super.sendOperationRequest(args, operationSpec));
  }
}
function _mapData2(data, transform) {
  if (Array.isArray(data)) return data.map(d => _classPrivateMethodGet(this, _mapData, _mapData2).call(this, d, transform));
  if (data != null && typeof data === 'object') {
    return mapObject(data, _ref6 => {
      let [key, value] = _ref6;
      if (value == null) return [key, value];
      if (bigIntPropertyNames.some(k => k === key)) return [key, transform.bigInt(value)];
      if (numberPropertyNames.some(k => k === key)) return [key, transform.number(value)];
      return [key, _classPrivateMethodGet(this, _mapData, _mapData2).call(this, value, transform)];
    });
  }
  return data;
}
function _encodeArg2(data) {
  return _classPrivateMethodGet(this, _mapData, _mapData2).call(this, data, {
    bigInt: value => {
      if (value instanceof BigNumber) return value.toFixed();
      return value.toString();
    },
    number: value => value.toString()
  });
}
function _decodeRes2(data) {
  return _classPrivateMethodGet(this, _mapData, _mapData2).call(this, data, {
    bigInt: value => BigInt(value),
    number: value => +value
  });
}
var _networkIdPromise = /*#__PURE__*/new WeakMap();
export default class Node extends NodeTransformed {
  /**
   * @param url - Url for node API
   * @param options - Options
   * @param options.ignoreVersion - Don't ensure that the node is supported
   * @param options.retryCount - Amount of extra requests to do in case of failure
   * @param options.retryOverallDelay - Time in ms to wait between all retries
   */
  constructor(url) {
    let {
      ignoreVersion = false,
      retryCount = 3,
      retryOverallDelay = 800,
      ...options
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genRetryOnFailurePolicy(retryCount, retryOverallDelay), genErrorFormatterPolicy(body => ` ${body.reason}`)],
      ...options
    });
    _classPrivateFieldInitSpec(this, _networkIdPromise, {
      writable: true,
      value: void 0
    });
    if (!ignoreVersion) {
      const statusPromise = this.getStatus();
      const versionPromise = statusPromise.then(_ref2 => {
        let {
          nodeVersion
        } = _ref2;
        return nodeVersion;
      }, error => error);
      _classPrivateFieldSet(this, _networkIdPromise, statusPromise.then(_ref3 => {
        let {
          networkId
        } = _ref3;
        return networkId;
      }, error => error));
      this.pipeline.addPolicy(genVersionCheckPolicy('node', '/v3/status', versionPromise, '6.2.0', '7.0.0'));
    }
    this.intAsString = true;
  }
  async getNetworkId() {
    var _classPrivateFieldGet2;
    (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _networkIdPromise)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(this, _networkIdPromise, this.getStatus().then(_ref4 => {
      let {
        networkId
      } = _ref4;
      return networkId;
    }));
    const networkId = await _classPrivateFieldGet(this, _networkIdPromise);
    if (networkId instanceof Error) throw networkId;
    return networkId;
  }
  async getNodeInfo() {
    const {
      nodeVersion,
      networkId: nodeNetworkId,
      protocols,
      topBlockHeight
    } = await this.getStatus();
    const consensusProtocolVersion = protocols.filter(_ref5 => {
      let {
        effectiveAtHeight
      } = _ref5;
      return topBlockHeight >= effectiveAtHeight;
    }).reduce((acc, p) => p.effectiveAtHeight > acc.effectiveAtHeight ? p : acc, {
      effectiveAtHeight: -1,
      version: 0
    }).version;
    if (ConsensusProtocolVersion[consensusProtocolVersion] == null) {
      const version = consensusProtocolVersion.toString();
      const versions = Object.values(ConsensusProtocolVersion).filter(el => typeof el === 'number').map(el => +el);
      const geVersion = Math.min(...versions).toString();
      const ltVersion = (Math.max(...versions) + 1).toString();
      throw new UnsupportedVersionError('consensus protocol', version, geVersion, ltVersion);
    }
    return {
      url: this.$host,
      nodeNetworkId,
      version: nodeVersion,
      consensusProtocolVersion
    };
  }
}
//# sourceMappingURL=Node.mjs.map