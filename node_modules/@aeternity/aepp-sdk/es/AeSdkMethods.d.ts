import * as chainMethods from './chain';
import * as aensMethods from './aens';
import * as spendMethods from './spend';
import * as oracleMethods from './oracle';
import Contract, { ContractMethodsBase } from './contract/Contract';
import createDelegationSignature from './contract/delegation-signature';
import * as contractGaMethods from './contract/ga';
import { UnionToIntersection } from './utils/other';
import Node from './Node';
import { TxParamsAsync } from './tx/builder/schema.generated';
import AccountBase from './account/Base';
import { Encoded } from './utils/encoder';
import CompilerBase from './contract/compiler/Base';
export type OnAccount = Encoded.AccountAddress | AccountBase | undefined;
export declare function getValueOrErrorProxy<Value extends object | undefined>(valueCb: () => Value): NonNullable<Value>;
declare const methods: {
    readonly createGeneralizedAccount: typeof contractGaMethods.createGeneralizedAccount;
    readonly buildAuthTxHash: typeof contractGaMethods.buildAuthTxHash;
    readonly buildAuthTxHashByGaMetaTx: typeof contractGaMethods.buildAuthTxHashByGaMetaTx;
    readonly createDelegationSignature: typeof createDelegationSignature;
    readonly pollForQueries: typeof oracleMethods.pollForQueries;
    readonly pollForQueryResponse: typeof oracleMethods.pollForQueryResponse;
    readonly getQueryObject: typeof oracleMethods.getQueryObject;
    readonly postQueryToOracle: typeof oracleMethods.postQueryToOracle;
    readonly extendOracleTtl: typeof oracleMethods.extendOracleTtl;
    readonly respondToQuery: typeof oracleMethods.respondToQuery;
    readonly getOracleObject: typeof oracleMethods.getOracleObject;
    readonly registerOracle: typeof oracleMethods.registerOracle;
    readonly spend: typeof spendMethods.spend;
    readonly transferFunds: typeof spendMethods.transferFunds;
    readonly payForTransaction: typeof spendMethods.payForTransaction;
    readonly aensRevoke: typeof aensMethods.aensRevoke;
    readonly aensUpdate: typeof aensMethods.aensUpdate;
    readonly aensTransfer: typeof aensMethods.aensTransfer;
    readonly aensQuery: typeof aensMethods.aensQuery;
    readonly aensClaim: typeof aensMethods.aensClaim;
    readonly aensPreclaim: typeof aensMethods.aensPreclaim;
    readonly aensBid: typeof aensMethods.aensBid;
    readonly _getPollInterval: typeof chainMethods._getPollInterval;
    readonly getHeight: typeof chainMethods.getHeight;
    readonly poll: typeof chainMethods.poll;
    readonly awaitHeight: typeof chainMethods.awaitHeight;
    readonly waitForTxConfirm: typeof chainMethods.waitForTxConfirm;
    readonly sendTransaction: typeof chainMethods.sendTransaction;
    readonly getAccount: typeof chainMethods.getAccount;
    readonly getBalance: typeof chainMethods.getBalance;
    readonly getCurrentGeneration: typeof chainMethods.getCurrentGeneration;
    readonly getGeneration: typeof chainMethods.getGeneration;
    readonly getMicroBlockTransactions: typeof chainMethods.getMicroBlockTransactions;
    readonly getKeyBlock: typeof chainMethods.getKeyBlock;
    readonly getMicroBlockHeader: typeof chainMethods.getMicroBlockHeader;
    readonly txDryRun: typeof chainMethods.txDryRun;
    readonly getContractByteCode: typeof chainMethods.getContractByteCode;
    readonly getContract: typeof chainMethods.getContract;
    readonly getName: typeof chainMethods.getName;
    readonly resolveName: typeof chainMethods.resolveName;
};
type Decrement<Number extends number> = [-1, 0, 1, 2, 3, 4, 5][Number];
type GetMethodsOptions<Methods extends {
    [key: string]: Function;
}> = {
    [Name in keyof Methods]: Methods[Name] extends (...args: infer Args) => any ? Args[Decrement<Args['length']>] : never;
};
type MethodsOptions = GetMethodsOptions<typeof methods>;
export interface AeSdkMethodsOptions extends Partial<UnionToIntersection<MethodsOptions[keyof MethodsOptions]>> {
}
/**
 * AeSdkMethods is the composition of:
 * - chain methods
 * - tx methods
 * - aens methods
 * - spend methods
 * - oracle methods
 * - contract methods
 * - contract ga methods
 *
 * While these methods can be used separately, this class provides a handy way to store
 * their context (current account, network, and compiler to use).
 */
declare class AeSdkMethods {
    _options: AeSdkMethodsOptions;
    /**
     * @param options - Options
     */
    constructor(options?: AeSdkMethodsOptions);
    _getOptions(callOptions?: AeSdkMethodsOptions): AeSdkMethodsOptions & {
        onAccount: AccountBase;
        onCompiler: CompilerBase;
        onNode: Node;
    };
    buildTx(options: TxParamsAsync): Promise<Encoded.Transaction>;
    initializeContract<Methods extends ContractMethodsBase>(options?: Omit<Parameters<typeof Contract.initialize>[0], 'onNode'> & {
        onNode?: Node;
    }): Promise<Contract<Methods>>;
}
type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Pick<T, K> ? never : K;
}[keyof T];
type OptionalIfNotRequired<T extends [any]> = RequiredKeys<T[0]> extends never ? T | [] : T;
type ReplaceOnAccount<Options> = Options extends {
    onAccount: any;
} ? Omit<Options, 'onAccount'> & {
    onAccount: OnAccount;
} : Options;
type MakeOptional<Options> = OptionalIfNotRequired<[
    Omit<Options, 'onNode' | 'onCompiler' | 'onAccount'> & Partial<ReplaceOnAccount<Options>>
]>;
type TransformMethods<Methods extends {
    [key: string]: Function;
}> = {
    [Name in keyof Methods]: Methods[Name] extends (...args: [...infer Args, infer Options]) => infer Ret ? (...args: [...Args, ...MakeOptional<Options>]) => Ret : never;
};
interface AeSdkMethodsTransformed extends TransformMethods<typeof methods> {
}
type AeSdkMethodsTyped = AeSdkMethods & AeSdkMethodsTransformed;
declare const AeSdkMethodsTyped: new (options?: AeSdkMethodsOptions) => AeSdkMethodsTyped;
export default AeSdkMethodsTyped;
