import _buffer from "buffer";
const {
  Buffer: _Buffer
} = _buffer;
import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import { v4 as uuid } from '@aeternity/uuid';
import AeSdk from "./AeSdk.mjs";
import verifyTransaction from "./tx/validator.mjs";
import RpcClient from "./aepp-wallet-communication/rpc/RpcClient.mjs";
import { METHODS, RPC_STATUS, SUBSCRIPTION_TYPES, RpcInvalidTransactionError, RpcNotAuthorizeError, RpcPermissionDenyError, RpcUnsupportedProtocolError } from "./aepp-wallet-communication/schema.mjs";
import { InternalError, UnknownRpcClientError } from "./utils/errors.mjs";
import { RPC_VERSION } from "./aepp-wallet-communication/rpc/types.mjs";
import jsonBig from "./utils/json-big.mjs";
/**
 * Contain functionality for aepp interaction and managing multiple aepps
 * @category aepp wallet communication
 */
export default class AeSdkWallet extends AeSdk {
  /**
   * @param options - Options
   * @param options.name - Wallet name
   * @param options.id - Wallet id
   * @param options.type - Wallet type
   * @param options.onConnection - Call-back function for incoming AEPP connection
   * @param options.onSubscription - Call-back function for incoming AEPP account subscription
   * @param options.onAskAccounts - Call-back function for incoming AEPP get address request
   * @param options.onDisconnect - Call-back function for disconnect event
   */
  constructor(_ref) {
    let {
      name,
      id,
      type,
      onConnection,
      onSubscription,
      onDisconnect,
      onAskAccounts,
      ...options
    } = _ref;
    super(options);
    _defineProperty(this, "_clients", new Map());
    this.onConnection = onConnection;
    this.onSubscription = onSubscription;
    this.onDisconnect = onDisconnect;
    this.onAskAccounts = onAskAccounts;
    this.name = name;
    this.id = id;
    this._type = type;
  }
  _getAccountsForClient(_ref2) {
    let {
      addressSubscription
    } = _ref2;
    const {
      current,
      connected
    } = this.getAccounts();
    return {
      current: addressSubscription.has('current') || addressSubscription.has('connected') ? current : {},
      connected: addressSubscription.has('connected') ? connected : {}
    };
  }
  _pushAccountsToApps() {
    if (this._clients == null) return;
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).filter(client => client.addressSubscription.size !== 0).forEach(client => client.rpc.notify(METHODS.updateAddress, this._getAccountsForClient(client)));
  }
  selectAccount(address) {
    super.selectAccount(address);
    this._pushAccountsToApps();
  }
  addAccount(account, options) {
    super.addAccount(account, options);
    this._pushAccountsToApps();
  }
  _getNode() {
    this.ensureNodeConnected();
    return {
      node: {
        url: this.api.$host,
        name: this.selectedNodeName
      }
    };
  }
  async selectNode(name) {
    super.selectNode(name);
    const networkId = await this.api.getNetworkId();
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).forEach(client => {
      client.rpc.notify(METHODS.updateNetwork, {
        networkId,
        ...(client.connectNode && this._getNode())
      });
    });
  }
  _getClient(clientId) {
    const client = this._clients.get(clientId);
    if (client == null) throw new UnknownRpcClientError(clientId);
    return client;
  }
  _isRpcClientConnected(clientId) {
    return RPC_STATUS.CONNECTED === this._getClient(clientId).status && this._getClient(clientId).rpc.connection.isConnected();
  }
  _disconnectRpcClient(clientId) {
    const client = this._getClient(clientId);
    client.rpc.connection.disconnect();
    client.status = RPC_STATUS.DISCONNECTED;
    client.addressSubscription = new Set();
  }

  /**
   * Remove specific RpcClient by ID
   * @param id - Client ID
   */
  removeRpcClient(id) {
    this._disconnectRpcClient(id);
    this._clients.delete(id);
  }

  /**
   * Add new client by AEPP connection
   * @param clientConnection - AEPP connection object
   * @returns Client ID
   */
  addRpcClient(clientConnection) {
    // @TODO  detect if aepp has some history based on origin????
    // if yes use this instance for connection
    const id = uuid();
    let disconnectParams;
    const client = {
      id,
      status: RPC_STATUS.WAITING_FOR_CONNECTION_REQUEST,
      addressSubscription: new Set(),
      connectNode: false,
      rpc: new RpcClient(clientConnection, () => {
        this._clients.delete(id);
        this.onDisconnect(id, disconnectParams); // also related info
      }, {
        [METHODS.closeConnection]: params => {
          disconnectParams = params;
          this._disconnectRpcClient(id);
        },
        // Store client info and prepare two fn for each client `connect` and `denyConnection`
        // which automatically prepare and send response for that client
        [METHODS.connect]: async (_ref3, origin) => {
          let {
            name,
            version,
            icons,
            connectNode
          } = _ref3;
          if (version !== RPC_VERSION) throw new RpcUnsupportedProtocolError();
          await this.onConnection(id, {
            name,
            icons,
            connectNode
          }, origin);
          client.status = RPC_STATUS.CONNECTED;
          client.connectNode = connectNode;
          return {
            ...(await this.getWalletInfo()),
            ...(connectNode && this._getNode())
          };
        },
        [METHODS.subscribeAddress]: async (_ref4, origin) => {
          let {
            type,
            value
          } = _ref4;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          switch (type) {
            case SUBSCRIPTION_TYPES.subscribe:
              // TODO: remove `type` as it always subscribe
              await this.onSubscription(id, {
                type,
                value
              }, origin);
              client.addressSubscription.add(value);
              break;
            case SUBSCRIPTION_TYPES.unsubscribe:
              client.addressSubscription.delete(value);
              break;
            default:
              throw new InternalError(`Unknown subscription type: ${type}`);
          }
          return {
            subscription: Array.from(client.addressSubscription),
            address: this._getAccountsForClient(client)
          };
        },
        [METHODS.address]: async (params, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          await this.onAskAccounts(id, params, origin);
          return this.addresses();
        },
        [METHODS.sign]: async (_ref5, origin) => {
          let {
            tx,
            onAccount = this.address,
            returnSigned,
            innerTx
          } = _ref5;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id,
            innerTx
          };
          if (returnSigned || innerTx === true) {
            return {
              signedTransaction: await this.signTransaction(tx, parameters)
            };
          }
          try {
            return jsonBig.parse(jsonBig.stringify({
              transactionHash: await this.sendTransaction(tx, {
                ...parameters,
                verify: false
              })
            }));
          } catch (error) {
            const validation = await verifyTransaction(tx, this.api);
            if (validation.length > 0) throw new RpcInvalidTransactionError(validation);
            throw error;
          }
        },
        [METHODS.signMessage]: async (_ref6, origin) => {
          let {
            message,
            onAccount = this.address
          } = _ref6;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          return {
            signature: _Buffer.from(await this.signMessage(message, parameters)).toString('hex')
          };
        },
        [METHODS.signTypedData]: async (_ref7, origin) => {
          let {
            domain,
            aci,
            data,
            onAccount = this.address
          } = _ref7;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            ...domain,
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          return {
            signature: await this.signTypedData(data, aci, parameters)
          };
        },
        [METHODS.signDelegationToContract]: async (_ref8, origin) => {
          var _ref9, _ref10;
          let {
            contractAddress,
            name,
            oracleQueryId,
            onAccount = this.address
          } = _ref8;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          const signature = await ((_ref9 = (_ref10 = name == null ? null : this.signNameDelegationToContract(contractAddress, name, parameters)) !== null && _ref10 !== void 0 ? _ref10 : oracleQueryId == null ? null : this.signOracleQueryDelegationToContract(contractAddress, oracleQueryId, parameters)) !== null && _ref9 !== void 0 ? _ref9 : this.signDelegationToContract(contractAddress, parameters));
          return {
            signature
          };
        }
      })
    };
    this._clients.set(id, client);
    return id;
  }

  /**
   * Send shareWalletInfo message to notify AEPP about wallet
   * @param clientId - ID of RPC client send message to
   */
  async shareWalletInfo(clientId) {
    this._getClient(clientId).rpc.notify(METHODS.readyToConnect, await this.getWalletInfo());
  }

  /**
   * Get Wallet info object
   * @returns Object with wallet information
   */
  async getWalletInfo() {
    return {
      id: this.id,
      name: this.name,
      networkId: await this.api.getNetworkId(),
      origin: window.location.origin,
      type: this._type
    };
  }

  /**
   * Get Wallet accounts
   * @returns Object with accounts information (\{ connected: Object, current: Object \})
   */
  getAccounts() {
    return {
      current: this.selectedAddress != null ? {
        [this.selectedAddress]: {}
      } : {},
      connected: this.addresses().filter(a => a !== this.selectedAddress).reduce((acc, a) => ({
        ...acc,
        [a]: {}
      }), {})
    };
  }
}
//# sourceMappingURL=AeSdkWallet.mjs.map