import _websocket from 'websocket';
const {
  w3cwebsocket: W3CWebSocket
} = _websocket;
import JsonBig from "../utils/json-big.mjs";
import { pascalToSnake } from "../utils/string.mjs";
import { ChannelCallError, ChannelPingTimedOutError, UnexpectedTsError, UnknownChannelStateError, ChannelIncomingMessageError, ChannelError } from "../utils/errors.mjs";
import { encodeContractAddress } from "../utils/crypto.mjs";
import { buildTx } from "../tx/builder/index.mjs";
import { ensureError } from "../utils/other.mjs"; // TODO: SignTx shouldn't return number or null
// Send ping message every 10 seconds
const PING_TIMEOUT_MS = 10000;
// Close connection if pong message is not received within 15 seconds
const PONG_TIMEOUT_MS = 15000;
export function emit(channel) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  const [eventName, ...rest] = args;
  channel._eventEmitter.emit(eventName, ...rest);
}
function enterState(channel, nextState) {
  var _nextState$handler;
  if (nextState == null) {
    throw new UnknownChannelStateError();
  }
  channel._fsm = nextState;
  if ((nextState === null || nextState === void 0 || (_nextState$handler = nextState.handler) === null || _nextState$handler === void 0 ? void 0 : _nextState$handler.enter) != null) {
    nextState.handler.enter(channel);
  }
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  void dequeueAction(channel);
}

// TODO: rewrite to enum

export function changeStatus(channel, newStatus) {
  if (newStatus === channel._status) return;
  channel._status = newStatus;
  emit(channel, 'statusChanged', newStatus);
}
export function changeState(channel, newState) {
  channel._state = newState;
  emit(channel, 'stateChanged', newState);
}
function send(channel, message) {
  if (channel._options.debug) console.log('Send message: ', message);
  channel._websocket.send(JsonBig.stringify({
    jsonrpc: '2.0',
    ...message
  }));
}
export function notify(channel, method) {
  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  send(channel, {
    method,
    params
  });
}
async function dequeueAction(channel) {
  if (channel._isActionQueueLocked) return;
  const queue = channel._actionQueue;
  if (queue.length === 0) return;
  const index = queue.findIndex(action => action.guard(channel, channel._fsm));
  if (index === -1) return;
  channel._actionQueue = queue.filter((_, i) => index !== i);
  channel._isActionQueueLocked = true;
  const nextState = await queue[index].action(channel, channel._fsm);
  channel._isActionQueueLocked = false;
  enterState(channel, nextState);
}
export async function enqueueAction(channel, guard, action) {
  const promise = new Promise((resolve, reject) => {
    channel._actionQueue.push({
      guard,
      action() {
        const res = action();
        return {
          ...res,
          state: {
            ...res.state,
            resolve,
            reject
          }
        };
      }
    });
  });
  void dequeueAction(channel);
  return promise;
}
async function handleMessage(channel, message) {
  var _message$params;
  const {
    handler,
    state: st
  } = channel._fsm;
  const nextState = await Promise.resolve(handler(channel, message, st));
  enterState(channel, nextState);
  // TODO: emit message and handler name (?) to move this code to Contract constructor
  if ((message === null || message === void 0 || (_message$params = message.params) === null || _message$params === void 0 || (_message$params = _message$params.data) === null || _message$params === void 0 || (_message$params = _message$params.updates) === null || _message$params === void 0 || (_message$params = _message$params[0]) === null || _message$params === void 0 ? void 0 : _message$params.op) === 'OffChainNewContract'
  // if name is channelOpen, the contract was created by other participant
  && (nextState === null || nextState === void 0 ? void 0 : nextState.handler.name) === 'channelOpen') {
    var _message$params2;
    const round = channel.round();
    if (round == null) throw new UnexpectedTsError('Round is null');
    const owner = message === null || message === void 0 || (_message$params2 = message.params) === null || _message$params2 === void 0 || (_message$params2 = _message$params2.data) === null || _message$params2 === void 0 || (_message$params2 = _message$params2.updates) === null || _message$params2 === void 0 || (_message$params2 = _message$params2[0]) === null || _message$params2 === void 0 ? void 0 : _message$params2.owner;
    emit(channel, 'newContract', encodeContractAddress(owner, round + 1));
  }
}
async function dequeueMessage(channel) {
  if (channel._isMessageQueueLocked) return;
  channel._isMessageQueueLocked = true;
  while (channel._messageQueue.length > 0) {
    const message = channel._messageQueue.shift();
    if (message == null) throw new UnexpectedTsError();
    try {
      await handleMessage(channel, message);
    } catch (error) {
      ensureError(error);
      emit(channel, 'error', new ChannelIncomingMessageError(error, message));
    }
  }
  channel._isMessageQueueLocked = false;
}
export function disconnect(channel) {
  channel._websocket.close();
  clearTimeout(channel._pingTimeoutId);
}
function ping(channel) {
  clearTimeout(channel._pingTimeoutId);
  channel._pingTimeoutId = setTimeout(() => {
    notify(channel, 'channels.system', {
      action: 'ping'
    });
    channel._pingTimeoutId = setTimeout(() => {
      disconnect(channel);
      emit(channel, 'error', new ChannelPingTimedOutError());
    }, PONG_TIMEOUT_MS);
  }, PING_TIMEOUT_MS);
}
function onMessage(channel, data) {
  const message = JsonBig.parse(data);
  if (channel._options.debug) console.log('Receive message: ', message);
  if (message.id != null) {
    const callback = channel._rpcCallbacks.get(message.id);
    if (callback == null) {
      emit(channel, 'error', new ChannelError(`Can't find callback by id: ${message.id}`));
      return;
    }
    try {
      callback(message);
    } finally {
      channel._rpcCallbacks.delete(message.id);
    }
    return;
  }
  if (message.method === 'channels.message') {
    emit(channel, 'message', message.params.data.message);
    return;
  }
  if (message.method === 'channels.system.pong') {
    if (message.params.channel_id === channel._channelId || channel._channelId == null) {
      ping(channel);
    }
    return;
  }
  channel._messageQueue.push(message);
  void dequeueMessage(channel);
}
export async function call(channel, method, params) {
  return new Promise((resolve, reject) => {
    const id = channel._nextRpcMessageId;
    channel._nextRpcMessageId += 1;
    channel._rpcCallbacks.set(id, message => {
      if (message.error != null) {
        var _message$error$data$;
        const details = (_message$error$data$ = message.error.data[0].message) !== null && _message$error$data$ !== void 0 ? _message$error$data$ : '';
        reject(new ChannelCallError(message.error.message + details));
      } else resolve(message.result);
    });
    send(channel, {
      method,
      id,
      params
    });
  });
}
export async function initialize(channel, connectionHandler, openHandler, _ref) {
  let {
    url,
    ...channelOptions
  } = _ref;
  channel._options = {
    url,
    ...channelOptions
  };
  channel._fsm = {
    handler: connectionHandler
  };
  const wsUrl = new URL(url);
  Object.entries(channelOptions).filter(_ref2 => {
    let [key] = _ref2;
    return !['sign', 'debug'].includes(key);
  }).forEach(_ref3 => {
    let [key, value] = _ref3;
    return wsUrl.searchParams.set(pascalToSnake(key), value.toString());
  });
  wsUrl.searchParams.set('protocol', 'json-rpc');
  changeStatus(channel, 'connecting');
  channel._websocket = new W3CWebSocket(wsUrl.toString());
  await new Promise((resolve, reject) => {
    Object.assign(channel._websocket, {
      onerror: reject,
      onopen: async () => {
        resolve();
        changeStatus(channel, 'connected');
        if (channelOptions.reconnectTx != null) {
          enterState(channel, {
            handler: openHandler
          });
          const {
            signedTx
          } = await channel.state();
          if (signedTx == null) {
            throw new ChannelError('`signedTx` missed in state while reconnection');
          }
          changeState(channel, buildTx(signedTx));
        }
        ping(channel);
      },
      onclose: () => {
        changeStatus(channel, 'disconnected');
        clearTimeout(channel._pingTimeoutId);
      },
      onmessage: _ref4 => {
        let {
          data
        } = _ref4;
        return onMessage(channel, data);
      }
    });
  });
}
//# sourceMappingURL=internal.mjs.map