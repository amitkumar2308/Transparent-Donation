import _defineProperty from "@babel/runtime-corejs3/helpers/defineProperty";
import * as chainMethods from "./chain.mjs";
import * as aensMethods from "./aens.mjs";
import * as spendMethods from "./spend.mjs";
import * as oracleMethods from "./oracle.mjs";
import Contract from "./contract/Contract.mjs";
import createDelegationSignature from "./contract/delegation-signature.mjs";
import * as contractGaMethods from "./contract/ga.mjs";
import { buildTxAsync } from "./tx/builder/index.mjs";
import { mapObject } from "./utils/other.mjs";
export function getValueOrErrorProxy(valueCb) {
  return new Proxy({}, Object.fromEntries(['apply', 'construct', 'defineProperty', 'deleteProperty', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf', 'get', 'has'].map(name => [name, function (t) {
    const target = valueCb(); // to get a native exception in case it missed
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    const res = Reflect[name](target, ...args);
    return typeof res === 'function' && name === 'get' ? res.bind(target) // otherwise it fails with attempted to get private field on non-instance
    : res;
  }])));
}
const {
  InvalidTxError: _2,
  ...chainMethodsOther
} = chainMethods;
const methods = {
  ...chainMethodsOther,
  ...aensMethods,
  ...spendMethods,
  ...oracleMethods,
  createDelegationSignature,
  ...contractGaMethods
};
/**
 * AeSdkMethods is the composition of:
 * - chain methods
 * - tx methods
 * - aens methods
 * - spend methods
 * - oracle methods
 * - contract methods
 * - contract ga methods
 *
 * While these methods can be used separately, this class provides a handy way to store
 * their context (current account, network, and compiler to use).
 */
class AeSdkMethods {
  /**
   * @param options - Options
   */
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _defineProperty(this, "_options", {});
    Object.assign(this._options, options);
  }
  _getOptions() {
    let callOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return {
      ...this._options,
      onAccount: getValueOrErrorProxy(() => this._options.onAccount),
      onNode: getValueOrErrorProxy(() => this._options.onNode),
      onCompiler: getValueOrErrorProxy(() => this._options.onCompiler),
      ...callOptions
    };
  }
  async buildTx(options) {
    return buildTxAsync({
      ...this._getOptions(),
      ...options
    });
  }
  async initializeContract(options) {
    return Contract.initialize(this._getOptions(options));
  }
}
Object.assign(AeSdkMethods.prototype, mapObject(methods, _ref => {
  let [name, handler] = _ref;
  return [name, function methodWrapper() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    args.length = handler.length;
    const options = args[args.length - 1];
    args[args.length - 1] = this._getOptions(options);
    return handler(...args);
  }];
}));
// eslint-disable-next-line @typescript-eslint/no-redeclare
const AeSdkMethodsTyped = AeSdkMethods;
export default AeSdkMethodsTyped;
//# sourceMappingURL=AeSdkMethods.mjs.map