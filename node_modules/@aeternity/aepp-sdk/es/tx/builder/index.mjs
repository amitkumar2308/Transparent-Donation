import _rlp from 'rlp';
const {
  decode: rlpDecode,
  encode: rlpEncode
} = _rlp;
import { decode, encode, Encoding } from "../../utils/encoder.mjs";
import { hash } from "../../utils/crypto.mjs";
import { txSchema } from "./schema.mjs";
import { Tag } from "./constants.mjs";
import { buildContractId, readInt } from "./helpers.mjs";
import { ArgumentError, DecodeError, SchemaNotFoundError } from "../../utils/errors.mjs";
/**
 * JavaScript-based Transaction builder
 */
export function getSchema(tag, version) {
  var _version;
  const schemas = txSchema.filter(s => s.tag.constValue === tag);
  if (schemas.length === 0) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, 0);
  (_version = version) !== null && _version !== void 0 ? _version : version = Math.max(...schemas.map(schema => schema.version.constValue));
  const schema = schemas.find(s => s.version.constValue === version);
  if (schema == null) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, version);
  return Object.entries(schema);
}
/**
 * Build transaction hash
 * @category transaction builder
 * @param params - Object with tx params
 * @param options - options
 * @param options.prefix - Prefix of transaction
 * @returns object Base64Check transaction hash with 'tx_' prefix
 */
export function buildTx(params) {
  let {
    prefix
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const schema = getSchema(params.tag, params.version);
  const binary = schema.map(_ref => {
    let [key, field] = _ref;
    return field.serialize(
    // @ts-expect-error the type of `params[key]` can't be determined accurately
    params[key], {
      ...params,
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      unpackTx,
      buildTx,
      rebuildTx: overrideParams => buildTx({
        ...params,
        ...overrideParams
      })
    }, params);
  });

  // @ts-expect-error looks like a TypeScript edge case
  return encode(rlpEncode(binary), prefix !== null && prefix !== void 0 ? prefix : Encoding.Transaction);
}
/**
 * @category transaction builder
 */
export async function buildTxAsync(params) {
  await Promise.all(getSchema(params.tag, params.version).map(async _ref2 => {
    let [key, field] = _ref2;
    if (field.prepare == null) return;
    // @ts-expect-error the type of `params[key]` can't be determined accurately
    params[key] = await field.prepare(params[key], params, params);
  }));

  // @ts-expect-error after preparation properties should be compatible with sync tx builder
  return buildTx(params);
}

/**
 * Unpack transaction encoded as string
 * @category transaction builder
 * @param encodedTx - Transaction to unpack
 * @param txType - Expected transaction type
 * @returns Object with transaction param's
 */
export function unpackTx(encodedTx, txType) {
  const binary = rlpDecode(decode(encodedTx));
  const tag = +readInt(binary[0]);
  const version = +readInt(binary[1]);
  const schema = getSchema(tag, version);
  if (txType != null && txType !== tag) throw new DecodeError(`Expected transaction to have ${Tag[txType]} tag, got ${Tag[tag]} instead`);
  if (binary.length !== schema.length) {
    throw new ArgumentError('Transaction RLP length', schema.length, binary.length);
  }
  return schema.reduce((acc, _ref3, index) => {
    let [name, field] = _ref3;
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    const deserialized = field.deserialize(binary[index], {
      unpackTx
    });
    return {
      ...acc,
      [name]: deserialized
    };
  }, {});
}

/**
 * Build a transaction hash
 * @category transaction builder
 * @param rawTx - base64 or rlp encoded transaction
 * @returns Transaction hash
 */
export function buildTxHash(rawTx) {
  const data = typeof rawTx === 'string' && rawTx.startsWith('tx_') ? decode(rawTx) : rawTx;
  return encode(hash(data), Encoding.TxHash);
}

/**
 * Build a contract public key by contractCreateTx or gaAttach
 * @category contract
 * @param contractTx - Transaction
 * @returns Contract public key
 */
export function buildContractIdByContractTx(contractTx) {
  const params = unpackTx(contractTx);
  if (Tag.ContractCreateTx !== params.tag && Tag.GaAttachTx !== params.tag) {
    throw new ArgumentError('contractTx', 'a contractCreateTx or gaAttach', params.tag);
  }
  return buildContractId(params.ownerId, params.nonce);
}
//# sourceMappingURL=index.mjs.map