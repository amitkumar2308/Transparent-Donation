/**
 * Transaction Schema for TxBuilder
 */
/// <reference types="node" />
import { Tag } from './constants';
import SchemaTypes from './SchemaTypes';
import { Encoded } from '../../utils/encoder';
export declare enum ORACLE_TTL_TYPES {
    delta = 0,
    block = 1
}
export declare const ORACLE_TTL: {
    type: ORACLE_TTL_TYPES;
    value: number;
};
export declare const QUERY_TTL: {
    type: ORACLE_TTL_TYPES;
    value: number;
};
export declare const RESPONSE_TTL: {
    type: ORACLE_TTL_TYPES;
    value: number;
};
export declare const DRY_RUN_ACCOUNT: {
    readonly pub: "ak_11111111111111111111111111111111273Yts";
    readonly amount: 100000000000000000000000000000000000n;
};
export declare enum CallReturnType {
    Ok = 0,
    Error = 1,
    Revert = 2
}
interface EntryAny {
    serialize: (value: TxParams | Uint8Array | Encoded.Transaction) => Buffer;
    deserialize: (value: Buffer) => TxUnpacked;
    recursiveType: true;
}
interface EntrySignedTx {
    serialize: (value: TxParams & {
        tag: Tag.SignedTx;
    } | Uint8Array | Encoded.Transaction) => Buffer;
    deserialize: (value: Buffer) => TxUnpacked & {
        tag: Tag.SignedTx;
    };
    recursiveType: true;
}
interface EntryMtreeValueArray {
    serialize: (value: Array<TxParams & {
        tag: Tag.MtreeValue;
    } | Uint8Array | Encoded.Transaction>) => Buffer[];
    deserialize: (value: Buffer[]) => Array<TxUnpacked & {
        tag: Tag.MtreeValue;
    }>;
    recursiveType: true;
}
interface EntryTreesPoi {
    serialize: (value: TxParams & {
        tag: Tag.TreesPoi;
    } | Uint8Array | Encoded.Transaction) => Buffer;
    deserialize: (value: Buffer) => TxUnpacked & {
        tag: Tag.TreesPoi;
    };
    recursiveType: true;
}
interface MapContracts {
    serialize: (value: Record<Encoded.ContractAddress, TxParams & {
        tag: Tag.Contract;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.ContractAddress, TxUnpacked & {
        tag: Tag.Contract;
    }>;
    recursiveType: true;
}
interface MapAccounts {
    serialize: (value: Record<Encoded.AccountAddress, TxParams & {
        tag: Tag.Account;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.AccountAddress, TxUnpacked & {
        tag: Tag.Account;
    }>;
    recursiveType: true;
}
interface MapCalls {
    serialize: (value: Record<Encoded.Bytearray, TxParams & {
        tag: Tag.ContractCall;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.Bytearray, TxUnpacked & {
        tag: Tag.ContractCall;
    }>;
    recursiveType: true;
}
interface MapChannels {
    serialize: (value: Record<Encoded.Channel, TxParams & {
        tag: Tag.Channel;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.Channel, TxUnpacked & {
        tag: Tag.Channel;
    }>;
    recursiveType: true;
}
interface MapNames {
    serialize: (value: Record<Encoded.Name, TxParams & {
        tag: Tag.Name;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.Name, TxUnpacked & {
        tag: Tag.Name;
    }>;
    recursiveType: true;
}
interface MapOracles {
    serialize: (value: Record<Encoded.OracleAddress, TxParams & {
        tag: Tag.Oracle;
    }>) => Buffer;
    deserialize: (value: Buffer) => Record<Encoded.OracleAddress, TxUnpacked & {
        tag: Tag.Oracle;
    }>;
    recursiveType: true;
}
/**
 * @see {@link https://github.com/aeternity/protocol/blob/c007deeac4a01e401238412801ac7084ac72d60e/serializations.md#accounts-version-1-basic-accounts}
 */
export declare const txSchema: readonly [{
    readonly tag: {
        serialize: (value: Tag.Account) => Buffer;
        deserialize: (value: Buffer) => Tag.Account;
        constValue: Tag.Account;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value: 1) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly nonce: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly balance: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.Account) => Buffer;
        deserialize: (value: Buffer) => Tag.Account;
        constValue: Tag.Account;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly flags: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly balance: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gaContract: {
        serialize: (value: `ct_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}` | `nm_${string}`;
    };
    readonly gaAuthFun: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.SignedTx) => Buffer;
        deserialize: (value: Buffer) => Tag.SignedTx;
        constValue: Tag.SignedTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly signatures: {
        serialize: (value: readonly Uint8Array[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => Buffer[];
    };
    readonly encodedTx: EntryAny;
}, {
    readonly tag: {
        serialize: (value: Tag.SpendTx) => Buffer;
        deserialize: (value: Buffer) => Tag.SpendTx;
        constValue: Tag.SpendTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly senderId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly recipientId: {
        serialize: (value: `ak_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}` | `nm_${string}`;
    };
    readonly amount: {
        serializeAettos(value: string | undefined, params: {}): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            senderId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly payload: {
        serialize: (value?: `ba_${string}` | undefined) => Buffer;
        deserialize: (value: Buffer) => `ba_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.Name) => Buffer;
        deserialize: (value: Buffer) => Tag.Name;
        constValue: Tag.Name;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nameTtl: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly status: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
    readonly clientTtl: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly pointers: {
        serialize(pointers: (import("../../apis/node").NamePointer & {
            id: `ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`;
        })[]): Buffer[][];
        deserialize(pointers: [key: Buffer, id: Buffer][]): (import("../../apis/node").NamePointer & {
            id: `ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`;
        })[];
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NamePreclaimTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NamePreclaimTx;
        constValue: Tag.NamePreclaimTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly commitmentId: {
        serialize: (value: `cm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cm_${string}`;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameClaimTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameClaimTx;
        constValue: Tag.NameClaimTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly name: {
        serialize(value: `${string}.chain`): Buffer;
        deserialize(value: Buffer): `${string}.chain`;
    };
    readonly nameSalt: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nameFee: {
        serializeAettos(_value: string | undefined, txFields: {
            name: `${string}.chain`;
        }): string;
        serialize(value: import("./constants").Int | undefined, txFields: {
            name: `${string}.chain`;
        }, parameters: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameUpdateTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameUpdateTx;
        constValue: Tag.NameUpdateTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly nameId: {
        serialize(value: `${string}.chain` | `nm_${string}`): Buffer;
        deserialize: (value: Buffer) => `nm_${string}`;
    };
    readonly nameTtl: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly pointers: {
        serialize(pointers: (import("../../apis/node").NamePointer & {
            id: `ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`;
        })[]): Buffer[][];
        deserialize(pointers: [key: Buffer, id: Buffer][]): (import("../../apis/node").NamePointer & {
            id: `ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`;
        })[];
    };
    readonly clientTtl: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameTransferTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameTransferTx;
        constValue: Tag.NameTransferTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly nameId: {
        serialize(value: `${string}.chain` | `nm_${string}`): Buffer;
        deserialize: (value: Buffer) => `nm_${string}`;
    };
    readonly recipientId: {
        serialize: (value: `ak_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}` | `nm_${string}`;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.NameRevokeTx) => Buffer;
        deserialize: (value: Buffer) => Tag.NameRevokeTx;
        constValue: Tag.NameRevokeTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly nameId: {
        serialize(value: `${string}.chain` | `nm_${string}`): Buffer;
        deserialize: (value: Buffer) => `nm_${string}`;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.Contract) => Buffer;
        deserialize: (value: Buffer) => Tag.Contract;
        constValue: Tag.Contract;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly owner: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly ctVersion: {
        serialize(value: import("./field-types/ct-version").CtVersion | undefined, params: {}, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./field-types/ct-version").CtVersion | undefined, params: {}, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./field-types/ct-version").CtVersion | undefined>;
        deserialize(buffer: Buffer): import("./field-types/ct-version").CtVersion;
    };
    readonly code: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly log: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly active: {
        serialize(value: boolean): Buffer;
        deserialize(buffer: Buffer): boolean;
    };
    readonly referers: {
        serialize: (value: readonly `ak_${string}`[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => `ak_${string}`[];
    };
    readonly deposit: {
        serialize(value: import("./constants").Int | undefined, options: {}, parameters: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        serializeAettos(value: string | undefined, params: {}): string;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ContractCreateTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ContractCreateTx;
        constValue: Tag.ContractCreateTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly ownerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            ownerId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly code: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly ctVersion: {
        serialize(value: import("./field-types/ct-version").CtVersion | undefined, params: {}, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./field-types/ct-version").CtVersion | undefined, params: {}, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./field-types/ct-version").CtVersion | undefined>;
        deserialize(buffer: Buffer): import("./field-types/ct-version").CtVersion;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly deposit: {
        serialize(value: import("./constants").Int | undefined, options: {}, parameters: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        serializeAettos(value: string | undefined, params: {}): string;
        deserialize(value: Buffer): string;
    };
    readonly amount: {
        serializeAettos(value: string | undefined, params: {}): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingGasLimit?: number | undefined;
        }, { gasMax }: {
            gasMax?: number | undefined;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly gasPrice: {
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ContractCallTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ContractCallTx;
        constValue: Tag.ContractCallTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly callerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            callerId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly contractId: {
        serialize: (value: `ct_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}` | `nm_${string}`;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("./constants").ConsensusProtocolVersion, tag: Tag): import("./constants").AbiVersion;
        serialize(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./constants").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("./constants").AbiVersion;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly amount: {
        serializeAettos(value: string | undefined, params: {}): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingGasLimit?: number | undefined;
        }, { gasMax }: {
            gasMax?: number | undefined;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly gasPrice: {
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ContractCall) => Buffer;
        deserialize: (value: Buffer) => Tag.ContractCall;
        constValue: Tag.ContractCall;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly callerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly callerNonce: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly height: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly contractId: {
        serialize: (value: `ct_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}`;
    };
    readonly gasPrice: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasUsed: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly returnValue: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly returnType: {
        serialize: (value: CallReturnType) => Buffer;
        deserialize: (value: Buffer) => CallReturnType;
    };
    readonly log: {
        serialize: (value: readonly Uint8Array[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => Buffer[];
    };
}, {
    readonly tag: {
        serialize: (value: Tag.Oracle) => Buffer;
        deserialize: (value: Buffer) => Tag.Oracle;
        constValue: Tag.Oracle;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly queryFormat: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly responseFormat: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly queryFee: {
        serializeAettos(value: string | undefined, params: {}): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly oracleTtlValue: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("./constants").ConsensusProtocolVersion, tag: Tag): import("./constants").AbiVersion;
        serialize(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./constants").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("./constants").AbiVersion;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.OracleRegisterTx) => Buffer;
        deserialize: (value: Buffer) => Tag.OracleRegisterTx;
        constValue: Tag.OracleRegisterTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accountId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            accountId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly queryFormat: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly responseFormat: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly queryFee: {
        serializeAettos(value: string | undefined, params: {}): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly oracleTtlType: {
        serialize: (value: ORACLE_TTL_TYPES) => Buffer;
        deserialize: (value: Buffer) => ORACLE_TTL_TYPES;
    };
    readonly oracleTtlValue: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("./constants").ConsensusProtocolVersion, tag: Tag): import("./constants").AbiVersion;
        serialize(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./constants").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("./constants").AbiVersion;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.OracleExtendTx) => Buffer;
        deserialize: (value: Buffer) => Tag.OracleExtendTx;
        constValue: Tag.OracleExtendTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly oracleId: {
        serialize: (value: `ok_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ok_${string}` | `nm_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            oracleId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly oracleTtlType: {
        serialize: (value: ORACLE_TTL_TYPES) => Buffer;
        deserialize: (value: Buffer) => ORACLE_TTL_TYPES;
    };
    readonly oracleTtlValue: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.OracleQueryTx) => Buffer;
        deserialize: (value: Buffer) => Tag.OracleQueryTx;
        constValue: Tag.OracleQueryTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly senderId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            senderId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly oracleId: {
        serialize: (value: `ok_${string}` | `nm_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ok_${string}` | `nm_${string}`;
    };
    readonly query: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly queryFee: {
        serializeAettos(value: string | undefined, params: {}): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly queryTtlType: {
        serialize: (value: ORACLE_TTL_TYPES) => Buffer;
        deserialize: (value: Buffer) => ORACLE_TTL_TYPES;
    };
    readonly queryTtlValue: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly responseTtlType: {
        serialize: (value: ORACLE_TTL_TYPES) => Buffer;
        deserialize: (value: Buffer) => ORACLE_TTL_TYPES;
    };
    readonly responseTtlValue: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.OracleResponseTx) => Buffer;
        deserialize: (value: Buffer) => Tag.OracleResponseTx;
        constValue: Tag.OracleResponseTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly oracleId: {
        serialize: (value: `ok_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ok_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            oracleId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly queryId: {
        serialize: (value: `oq_${string}`) => Buffer;
        deserialize: (value: Buffer) => `oq_${string}`;
    };
    readonly response: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly responseTtlType: {
        serialize: (value: ORACLE_TTL_TYPES) => Buffer;
        deserialize: (value: Buffer) => ORACLE_TTL_TYPES;
    };
    readonly responseTtlValue: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelCreateTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelCreateTx;
        constValue: Tag.ChannelCreateTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly initiator: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly initiatorAmount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly responder: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly responderAmount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly channelReserve: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly lockPeriod: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly initiatorDelegateIds: {
        serialize: (value: readonly (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[];
    };
    readonly responderDelegateIds: {
        serialize: (value: readonly (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[];
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            initiator: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelCloseMutualTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelCloseMutualTx;
        constValue: Tag.ChannelCloseMutualTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly initiatorAmountFinal: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly responderAmountFinal: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelCloseSoloTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelCloseSoloTx;
        constValue: Tag.ChannelCloseSoloTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly payload: {
        serialize: (value: `tx_${string}`) => Buffer;
        deserialize: (value: Buffer) => `tx_${string}`;
    };
    readonly poi: EntryTreesPoi;
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelSlashTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelSlashTx;
        constValue: Tag.ChannelSlashTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly payload: {
        serialize: (value: `tx_${string}`) => Buffer;
        deserialize: (value: Buffer) => `tx_${string}`;
    };
    readonly poi: EntryTreesPoi;
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelDepositTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelDepositTx;
        constValue: Tag.ChannelDepositTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelWithdrawTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelWithdrawTx;
        constValue: Tag.ChannelWithdrawTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly toId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelSettleTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelSettleTx;
        constValue: Tag.ChannelSettleTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly initiatorAmountFinal: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly responderAmountFinal: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelForceProgressTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelForceProgressTx;
        constValue: Tag.ChannelForceProgressTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly payload: {
        serialize: (value: `tx_${string}`) => Buffer;
        deserialize: (value: Buffer) => `tx_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly update: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly offChainTrees: {
        serialize: (value: `ss_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ss_${string}`;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelOffChainTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelOffChainTx;
        constValue: Tag.ChannelOffChainTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.Channel) => Buffer;
        deserialize: (value: Buffer) => Tag.Channel;
        constValue: Tag.Channel;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 3 | undefined) => Buffer;
        deserialize: (value: Buffer) => 3;
        constValue: 3;
        constValueOptional: boolean;
    };
    readonly initiator: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly responder: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly channelAmount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly initiatorAmount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly responderAmount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly channelReserve: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly initiatorDelegateIds: {
        serialize: (value: readonly (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[];
    };
    readonly responderDelegateIds: {
        serialize: (value: readonly (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[], params: unknown) => Buffer[];
        deserialize: (value: Buffer[], params: unknown) => (`ch_${string}` | `ct_${string}` | `ok_${string}` | `ak_${string}` | `cm_${string}` | `nm_${string}`)[];
    };
    readonly stateHash: {
        serialize: (value: `st_${string}`) => Buffer;
        deserialize: (value: Buffer) => `st_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly soloRound: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly lockPeriod: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly lockedUntil: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly initiatorAuth: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly responderAuth: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelSnapshotSoloTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelSnapshotSoloTx;
        constValue: Tag.ChannelSnapshotSoloTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly fromId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly payload: {
        serialize: (value: `tx_${string}`) => Buffer;
        deserialize: (value: Buffer) => `tx_${string}`;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            fromId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelOffChainUpdateTransfer) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelOffChainUpdateTransfer;
        constValue: Tag.ChannelOffChainUpdateTransfer;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly from: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly to: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelOffChainUpdateDeposit) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelOffChainUpdateDeposit;
        constValue: Tag.ChannelOffChainUpdateDeposit;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly from: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelOffChainUpdateWithdraw) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelOffChainUpdateWithdraw;
        constValue: Tag.ChannelOffChainUpdateWithdraw;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly from: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly amount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelOffChainUpdateCreateContract) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelOffChainUpdateCreateContract;
        constValue: Tag.ChannelOffChainUpdateCreateContract;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly owner: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly ctVersion: {
        serialize(value: import("./field-types/ct-version").CtVersion | undefined, params: {}, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./field-types/ct-version").CtVersion | undefined, params: {}, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./field-types/ct-version").CtVersion | undefined>;
        deserialize(buffer: Buffer): import("./field-types/ct-version").CtVersion;
    };
    readonly code: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly deposit: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelOffChainUpdateCallContract) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelOffChainUpdateCallContract;
        constValue: Tag.ChannelOffChainUpdateCallContract;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly caller: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly contract: {
        serialize: (value: `ct_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ct_${string}`;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("./constants").ConsensusProtocolVersion, tag: Tag): import("./constants").AbiVersion;
        serialize(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./constants").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("./constants").AbiVersion;
    };
    readonly amount: {
        serialize(value: import("./constants").Int): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly callStack: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
    readonly gasPrice: {
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingGasLimit?: number | undefined;
        }, { gasMax }: {
            gasMax?: number | undefined;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelClientReconnectTx) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelClientReconnectTx;
        constValue: Tag.ChannelClientReconnectTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly channelId: {
        serialize: (value: `ch_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ch_${string}`;
    };
    readonly round: {
        serialize(value: number): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly role: {
        serialize(string: string): Buffer;
        deserialize(buffer: Buffer): string;
    };
    readonly pubkey: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.TreesPoi) => Buffer;
        deserialize: (value: Buffer) => Tag.TreesPoi;
        constValue: Tag.TreesPoi;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly accounts: {
        serialize: (value: readonly {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.AccountAddress;
            readonly "__#3@#tag": Tag.Account;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ak_${string}`): (import("./schema.generated").TxUnpackedAccount1 & {
                tag: Tag.Account;
            }) | (import("./schema.generated").TxUnpackedAccount2 & {
                tag: Tag.Account;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ak_${string}`, (import("./schema.generated").TxUnpackedAccount1 & {
                tag: Tag.Account;
            }) | (import("./schema.generated").TxUnpackedAccount2 & {
                tag: Tag.Account;
            })>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.AccountAddress;
            readonly "__#3@#tag": Tag.Account;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ak_${string}`): (import("./schema.generated").TxUnpackedAccount1 & {
                tag: Tag.Account;
            }) | (import("./schema.generated").TxUnpackedAccount2 & {
                tag: Tag.Account;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ak_${string}`, (import("./schema.generated").TxUnpackedAccount1 & {
                tag: Tag.Account;
            }) | (import("./schema.generated").TxUnpackedAccount2 & {
                tag: Tag.Account;
            })>;
        }[];
    };
    readonly calls: {
        serialize: (value: readonly {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.Bytearray;
            readonly "__#3@#tag": Tag.ContractCall;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ba_${string}`): (import("./schema.generated").TxUnpackedContractCall2 & {
                tag: Tag.ContractCall;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ba_${string}`, import("./schema.generated").TxUnpackedContractCall2 & {
                tag: Tag.ContractCall;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.Bytearray;
            readonly "__#3@#tag": Tag.ContractCall;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ba_${string}`): (import("./schema.generated").TxUnpackedContractCall2 & {
                tag: Tag.ContractCall;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ba_${string}`, import("./schema.generated").TxUnpackedContractCall2 & {
                tag: Tag.ContractCall;
            }>;
        }[];
    };
    readonly channels: {
        serialize: (value: readonly {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.Channel;
            readonly "__#3@#tag": Tag.Channel;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ch_${string}`): (import("./schema.generated").TxUnpackedChannel3 & {
                tag: Tag.Channel;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ch_${string}`, import("./schema.generated").TxUnpackedChannel3 & {
                tag: Tag.Channel;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.Channel;
            readonly "__#3@#tag": Tag.Channel;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ch_${string}`): (import("./schema.generated").TxUnpackedChannel3 & {
                tag: Tag.Channel;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ch_${string}`, import("./schema.generated").TxUnpackedChannel3 & {
                tag: Tag.Channel;
            }>;
        }[];
    };
    readonly contracts: {
        serialize: (value: readonly {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.ContractAddress;
            readonly "__#3@#tag": Tag.Contract;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ct_${string}`): (import("./schema.generated").TxUnpackedContract1 & {
                tag: Tag.Contract;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ct_${string}`, import("./schema.generated").TxUnpackedContract1 & {
                tag: Tag.Contract;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.ContractAddress;
            readonly "__#3@#tag": Tag.Contract;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ct_${string}`): (import("./schema.generated").TxUnpackedContract1 & {
                tag: Tag.Contract;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ct_${string}`, import("./schema.generated").TxUnpackedContract1 & {
                tag: Tag.Contract;
            }>;
        }[];
    };
    readonly ns: {
        serialize: (value: readonly {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.Name;
            readonly "__#3@#tag": Tag.Name;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `nm_${string}`): (import("./schema.generated").TxUnpackedName1 & {
                tag: Tag.Name;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`nm_${string}`, import("./schema.generated").TxUnpackedName1 & {
                tag: Tag.Name;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.Name;
            readonly "__#3@#tag": Tag.Name;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `nm_${string}`): (import("./schema.generated").TxUnpackedName1 & {
                tag: Tag.Name;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`nm_${string}`, import("./schema.generated").TxUnpackedName1 & {
                tag: Tag.Name;
            }>;
        }[];
    };
    readonly oracles: {
        serialize: (value: readonly {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.OracleAddress;
            readonly "__#3@#tag": Tag.Oracle;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ok_${string}`): (import("./schema.generated").TxUnpackedOracle1 & {
                tag: Tag.Oracle;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ok_${string}`, import("./schema.generated").TxUnpackedOracle1 & {
                tag: Tag.Oracle;
            }>;
        }[], params: unknown) => [Buffer, [Buffer, Buffer[]][]][];
        deserialize: (value: [Buffer, [Buffer, Buffer[]][]][], params: unknown) => {
            readonly "__#3@#rootHash": string;
            "__#3@#isComplete": boolean;
            readonly isComplete: boolean;
            readonly "__#3@#nodes": {
                [key: string]: Buffer[];
            };
            readonly "__#3@#encoding": Encoded.Encoding.OracleAddress;
            readonly "__#3@#tag": Tag.Oracle;
            readonly "__#3@#unpackTx": typeof import(".").unpackTx;
            isEqual(tree: any): boolean;
            serialize(): [Buffer, [Buffer, Buffer[]][]];
            "__#3@#getRaw"(_key: string): Buffer | undefined;
            get(key: `ok_${string}`): (import("./schema.generated").TxUnpackedOracle1 & {
                tag: Tag.Oracle;
            }) | undefined;
            "__#3@#entriesRaw"(): [string, Buffer][];
            toObject(): Record<`ok_${string}`, import("./schema.generated").TxUnpackedOracle1 & {
                tag: Tag.Oracle;
            }>;
        }[];
    };
}, {
    readonly tag: {
        serialize: (value: Tag.StateTrees) => Buffer;
        deserialize: (value: Buffer) => Tag.StateTrees;
        constValue: Tag.StateTrees;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 0 | undefined) => Buffer;
        deserialize: (value: Buffer) => 0;
        constValue: 0;
        constValueOptional: boolean;
    };
    readonly contracts: MapContracts;
    readonly calls: MapCalls;
    readonly channels: MapChannels;
    readonly ns: MapNames;
    readonly oracles: MapOracles;
    readonly accounts: MapAccounts;
}, {
    readonly tag: {
        serialize: (value: Tag.Mtree) => Buffer;
        deserialize: (value: Buffer) => Tag.Mtree;
        constValue: Tag.Mtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly values: EntryMtreeValueArray;
}, {
    readonly tag: {
        serialize: (value: Tag.MtreeValue) => Buffer;
        deserialize: (value: Buffer) => Tag.MtreeValue;
        constValue: Tag.MtreeValue;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly key: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
    readonly value: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.ContractsMtree) => Buffer;
        deserialize: (value: Buffer) => Tag.ContractsMtree;
        constValue: Tag.ContractsMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapContracts;
}, {
    readonly tag: {
        serialize: (value: Tag.CallsMtree) => Buffer;
        deserialize: (value: Buffer) => Tag.CallsMtree;
        constValue: Tag.CallsMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapCalls;
}, {
    readonly tag: {
        serialize: (value: Tag.ChannelsMtree) => Buffer;
        deserialize: (value: Buffer) => Tag.ChannelsMtree;
        constValue: Tag.ChannelsMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapChannels;
}, {
    readonly tag: {
        serialize: (value: Tag.NameserviceMtree) => Buffer;
        deserialize: (value: Buffer) => Tag.NameserviceMtree;
        constValue: Tag.NameserviceMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapNames;
}, {
    readonly tag: {
        serialize: (value: Tag.OraclesMtree) => Buffer;
        deserialize: (value: Buffer) => Tag.OraclesMtree;
        constValue: Tag.OraclesMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapOracles;
}, {
    readonly tag: {
        serialize: (value: Tag.AccountsMtree) => Buffer;
        deserialize: (value: Buffer) => Tag.AccountsMtree;
        constValue: Tag.AccountsMtree;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payload: MapAccounts;
}, {
    readonly tag: {
        serialize: (value: Tag.GaAttachTx) => Buffer;
        deserialize: (value: Buffer) => Tag.GaAttachTx;
        constValue: Tag.GaAttachTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly ownerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            ownerId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly code: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly authFun: {
        serialize(buffer: Uint8Array): Buffer;
        deserialize(buffer: Buffer): Buffer;
    };
    readonly ctVersion: {
        serialize(value: import("./field-types/ct-version").CtVersion | undefined, params: {}, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./field-types/ct-version").CtVersion | undefined, params: {}, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./field-types/ct-version").CtVersion | undefined>;
        deserialize(buffer: Buffer): import("./field-types/ct-version").CtVersion;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly ttl: {
        serialize(value: number | undefined): Buffer;
        prepare(value: number | undefined, params: {}, { onNode, absoluteTtl }: {
            onNode?: import("../..").Node | undefined;
            absoluteTtl?: boolean | undefined;
        }): Promise<number | undefined>;
        deserialize(value: Buffer): number;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingGasLimit?: number | undefined;
        }, { gasMax }: {
            gasMax?: number | undefined;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly gasPrice: {
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly callData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
}, {
    readonly tag: {
        serialize: (value: Tag.GaMetaTx) => Buffer;
        deserialize: (value: Buffer) => Tag.GaMetaTx;
        constValue: Tag.GaMetaTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 2 | undefined) => Buffer;
        deserialize: (value: Buffer) => 2;
        constValue: 2;
        constValueOptional: boolean;
    };
    readonly gaId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly authData: {
        serialize: (value: `cb_${string}`) => Buffer;
        deserialize: (value: Buffer) => `cb_${string}`;
    };
    readonly abiVersion: {
        _getProtocolDetails(c: import("./constants").ConsensusProtocolVersion, tag: Tag): import("./constants").AbiVersion;
        serialize(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, { consensusProtocolVersion }: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
        }): Buffer;
        prepare(value: import("./constants").AbiVersion | undefined, { tag }: {
            tag: Tag;
        }, options: {
            consensusProtocolVersion?: import("./constants").ConsensusProtocolVersion | undefined;
            onNode?: import("../..").Node | undefined;
        }): Promise<import("./constants").AbiVersion | undefined>;
        deserialize(buffer: Buffer): import("./constants").AbiVersion;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasLimit: {
        serialize(_value: number | undefined, { tag, rebuildTx, unpackTx, buildTx, _computingGasLimit, }: {
            tag: Tag;
            rebuildTx: (params: any) => any;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingGasLimit?: number | undefined;
        }, { gasMax }: {
            gasMax?: number | undefined;
        }): Buffer;
        deserialize(value: Buffer): number;
    };
    readonly gasPrice: {
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly tx: EntrySignedTx;
}, {
    readonly tag: {
        serialize: (value: Tag.PayingForTx) => Buffer;
        deserialize: (value: Buffer) => Tag.PayingForTx;
        constValue: Tag.PayingForTx;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly payerId: {
        serialize: (value: `ak_${string}`) => Buffer;
        deserialize: (value: Buffer) => `ak_${string}`;
    };
    readonly nonce: {
        serialize: (value: number) => Buffer;
        prepare: (value: number | undefined, params: {}, options: {
            payerId: string;
        } & {
            strategy?: import("../../apis/node").NextNonceStrategy | undefined;
            onNode?: import("../..").Node | undefined;
        }) => Promise<number>;
        deserialize: (value: Buffer) => number;
        senderKey: string;
    };
    readonly fee: {
        serializeAettos(_value: string | undefined, { rebuildTx, unpackTx, buildTx, _computingMinFee, _pickBiggerFee, }: {
            rebuildTx: (params: any) => `tx_${string}`;
            unpackTx: typeof import(".").unpackTx;
            buildTx: typeof import(".").buildTx;
            _computingMinFee?: import("bignumber.js").BigNumber | undefined;
            _pickBiggerFee?: boolean | undefined;
        }): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly tx: EntrySignedTx;
}, {
    readonly tag: {
        serialize: (value: Tag.GaMetaTxAuthData) => Buffer;
        deserialize: (value: Buffer) => Tag.GaMetaTxAuthData;
        constValue: Tag.GaMetaTxAuthData;
        constValueOptional: boolean;
    };
    readonly version: {
        serialize: (value?: 1 | undefined) => Buffer;
        deserialize: (value: Buffer) => 1;
        constValue: 1;
        constValueOptional: boolean;
    };
    readonly fee: {
        serializeAettos(value: string | undefined, params: {}): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly gasPrice: {
        serializeAettos(value?: string | undefined): string;
        serialize(value: import("./constants").Int | undefined, params: {}, { denomination }: {
            denomination?: import("../..").AE_AMOUNT_FORMATS | undefined;
        }): Buffer;
        deserialize(value: Buffer): string;
    };
    readonly txHash: {
        serialize: (value: `th_${string}`) => Buffer;
        deserialize: (value: Buffer) => `th_${string}`;
    };
}];
type TxSchema = SchemaTypes<typeof txSchema>;
export type TxParams = TxSchema['TxParams'];
export type TxParamsAsync = TxSchema['TxParamsAsync'];
export type TxUnpacked = TxSchema['TxUnpacked'];
export {};
