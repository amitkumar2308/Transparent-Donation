{"version":3,"file":"mptree.mjs","names":["_rlp","encode","rlpEncode","hash","MerkleTreeHashMismatchError","MissingNodeInTreeError","UnknownPathNibbleError","UnexpectedTsError","UnknownNodeLengthError","InternalError","decode","Encoding","NodeType","_rootHash","WeakMap","_isComplete","_nodes","_encoding","_tag","_unpackTx","_getRaw","WeakSet","_entriesRaw","MPTree","isComplete","_classPrivateFieldGet","constructor","binary","encoding","tag","unpTx","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","toString","Object","fromEntries","map","node","keys","length","entries","forEach","_ref","key","_classStaticPrivateMethodGet","_nodeHash","call","type","_parseNode","Branch","slice","filter","n","Extension","Leaf","isEqual","tree","serialize","_Buffer","from","_ref2","mptHash","get","d","_classPrivateMethodGet","_getRaw2","Transaction","toObject","_entriesRaw2","_ref3","k","ContractAddress","_ref4","v","nibble","includes","path","_key","searchFrom","undefined","substring","rec","t","idx","_ref6","_ref7","push","genMPTreeField","deserialize","_ref5","unpackTx"],"sources":["../../../../src/tx/builder/field-types/mptree.ts"],"sourcesContent":["import { encode as rlpEncode, Input } from 'rlp';\nimport { Tag } from '../constants';\nimport { hash } from '../../../utils/crypto';\nimport {\n  MerkleTreeHashMismatchError,\n  MissingNodeInTreeError,\n  UnknownPathNibbleError,\n  UnexpectedTsError,\n  UnknownNodeLengthError,\n  InternalError,\n} from '../../../utils/errors';\nimport {\n  decode, encode, Encoded, Encoding,\n} from '../../../utils/encoder';\nimport type { unpackTx } from '..';\nimport type { TxUnpacked } from '../schema.generated';\n\nenum NodeType {\n  Branch,\n  Extension,\n  Leaf,\n}\n\ntype MPTreeBinary = [Buffer, Array<[Buffer, Buffer[]]>];\n\nclass MPTree<E extends Encoding, T extends Tag> {\n  readonly #rootHash: string;\n\n  #isComplete = true;\n\n  get isComplete(): boolean {\n    return this.#isComplete;\n  }\n\n  readonly #nodes: { [key: string]: Buffer[] };\n\n  readonly #encoding: E;\n\n  readonly #tag: T;\n\n  readonly #unpackTx: typeof unpackTx;\n\n  static #nodeHash(node: Input): string {\n    return Buffer.from(hash(rlpEncode(node))).toString('hex');\n  }\n\n  /**\n   * Deserialize Merkle Patricia Tree\n   * @param binary - Binary\n   * @param tag - Tag to use to decode value\n   * @param unpTx - Implementation of unpackTx use to decode values\n   * @returns Merkle Patricia Tree\n   */\n  constructor(binary: MPTreeBinary, encoding: E, tag: T, unpTx: typeof unpackTx) {\n    this.#encoding = encoding;\n    this.#tag = tag;\n    this.#unpackTx = unpTx;\n    this.#rootHash = binary[0].toString('hex');\n    this.#nodes = Object.fromEntries(\n      binary[1].map((node) => [node[0].toString('hex'), node[1]]),\n    );\n\n    if (this.#nodes[this.#rootHash] == null) {\n      if (Object.keys(this.#nodes).length !== 0) {\n        throw new MissingNodeInTreeError('Can\\'t find a node by root hash');\n      }\n      this.#isComplete = false;\n      return;\n    }\n    Object.entries(this.#nodes).forEach(([key, node]) => {\n      if (MPTree.#nodeHash(node) !== key) throw new MerkleTreeHashMismatchError();\n      const { type } = MPTree.#parseNode(node);\n      switch (type) {\n        case NodeType.Branch:\n          node\n            .slice(0, 16)\n            .filter((n) => n.length)\n            .forEach((n) => {\n              // TODO: enable after resolving https://github.com/aeternity/aeternity/issues/4066\n              // if (n.length !== 32) {\n              //   throw new ArgumentError('MPTree branch item length', 32, n.length);\n              // }\n              if (this.#nodes[n.toString('hex')] == null) this.#isComplete = false;\n            });\n          break;\n        case NodeType.Extension:\n          if (this.#nodes[node[1].toString('hex')] == null) {\n            throw new MissingNodeInTreeError('Can\\'t find a node by hash in extension node');\n          }\n          break;\n        case NodeType.Leaf:\n          break;\n        default:\n          throw new InternalError(`Unknown MPTree node type: ${type}`);\n      }\n    });\n  }\n\n  isEqual(tree: MPTree<E, T>): boolean {\n    return this.#rootHash === tree.#rootHash;\n  }\n\n  static #parseNode(node: Buffer[]): { type: NodeType; value?: Buffer; path?: string } {\n    switch (node.length) {\n      case 17:\n        return {\n          type: NodeType.Branch,\n          ...node[16].length !== 0 && { value: node[16] },\n        };\n      case 2: {\n        const nibble = node[0][0] >> 4; // eslint-disable-line no-bitwise\n        if (nibble > 3) throw new UnknownPathNibbleError(nibble);\n        const type = nibble <= 1 ? NodeType.Extension : NodeType.Leaf;\n        const slice = [0, 2].includes(nibble) ? 2 : 1;\n        return {\n          type,\n          ...type === NodeType.Leaf && { value: node[1] },\n          path: node[0].toString('hex').slice(slice),\n        };\n      }\n      default:\n        throw new UnknownNodeLengthError(node.length);\n    }\n  }\n\n  /**\n   * Serialize Merkle Patricia Tree\n   * @returns Binary\n   */\n  serialize(): MPTreeBinary {\n    return [\n      Buffer.from(this.#rootHash, 'hex'),\n      Object.entries(this.#nodes).map(([mptHash, value]) => ([\n        Buffer.from(mptHash, 'hex'),\n        value,\n      ])),\n    ];\n  }\n\n  /**\n   * Retrieve value from Merkle Patricia Tree\n   * @param _key - The key of the element to retrieve\n   * @returns Value associated to the specified key\n   */\n  #getRaw(_key: string): Buffer | undefined {\n    let searchFrom = this.#rootHash;\n    let key = _key;\n    while (true) { // eslint-disable-line no-constant-condition\n      const node = this.#nodes[searchFrom];\n      if (node == null) {\n        if (!this.isComplete) return undefined;\n        throw new InternalError('Can\\'t find node in complete tree');\n      }\n      const { type, value, path } = MPTree.#parseNode(node);\n      switch (type) {\n        case NodeType.Branch:\n          if (key.length === 0) return value;\n          searchFrom = node[+`0x${key[0]}`].toString('hex');\n          key = key.substring(1);\n          break;\n        case NodeType.Extension:\n          if (key.substring(0, path?.length) !== path) return undefined;\n          searchFrom = node[1].toString('hex');\n          key = key.substring(path.length);\n          break;\n        case NodeType.Leaf:\n          if (path !== key) return undefined;\n          return value;\n        default:\n          throw new InternalError(`Unknown MPTree node type: ${type}`);\n      }\n    }\n  }\n\n  /**\n   * Retrieve value from Merkle Patricia Tree\n   * @param key - The key of the element to retrieve\n   * @returns Value associated to the specified key\n   */\n  get(key: Encoded.Generic<E>): TxUnpacked & { tag: T } | undefined {\n    const d = this.#getRaw(decode(key).toString('hex'));\n    if (d == null) return d;\n    return this.#unpackTx(encode(d, Encoding.Transaction), this.#tag);\n  }\n\n  #entriesRaw(): Array<[string, Buffer]> {\n    const entries: Array<[string, Buffer]> = [];\n    const rec = (searchFrom: string, key: string): void => {\n      const node = this.#nodes[searchFrom];\n      if (node == null) {\n        if (!this.isComplete) return;\n        throw new InternalError('Can\\'t find node in complete tree');\n      }\n      const { type, value, path } = MPTree.#parseNode(node);\n      switch (type) {\n        case NodeType.Branch:\n          node\n            .slice(0, 16)\n            .map((t, idx): [typeof t, number] => [t, idx])\n            .filter(([t]) => t.length)\n            .forEach(([t, idx]) => rec(t.toString('hex'), key + idx.toString(16)));\n          if (value != null) entries.push([key, value]);\n          break;\n        case NodeType.Extension:\n          rec(node[1].toString('hex'), key + path);\n          break;\n        case NodeType.Leaf:\n          if (value == null) throw new UnexpectedTsError();\n          entries.push([key + path, value]);\n          break;\n        default:\n          throw new InternalError(`Unknown MPTree node type: ${type}`);\n      }\n    };\n    rec(this.#rootHash, '');\n    return entries;\n  }\n\n  toObject(): Record<Encoded.Generic<E>, TxUnpacked & { tag: T }> {\n    return Object.fromEntries(this.#entriesRaw()\n      // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066\n      .filter(([k]) => this.#encoding !== Encoding.ContractAddress || k.length !== 66)\n      .map(([k, v]) => [\n        encode(Buffer.from(k, 'hex'), this.#encoding),\n        this.#unpackTx(encode(v, Encoding.Transaction), this.#tag),\n      ])) as Record<Encoded.Generic<E>, TxUnpacked & { tag: T }>;\n  }\n}\n\nexport default function genMPTreeField<E extends Encoding, T extends Tag>(encoding: E, tag: T): {\n  serialize: (value: MPTree<E, T>) => MPTreeBinary;\n  deserialize: (value: MPTreeBinary, o: { unpackTx: typeof unpackTx }) => MPTree<E, T>;\n} {\n  return {\n    serialize(value) {\n      return value.serialize();\n    },\n\n    deserialize(value, { unpackTx }) {\n      return new MPTree(value, encoding, tag, unpackTx);\n    },\n  };\n}\n"],"mappings":"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"}