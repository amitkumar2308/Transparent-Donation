import _buffer from "buffer";
const {
  Buffer: _Buffer
} = _buffer;
import _classPrivateFieldSet from "@babel/runtime-corejs3/helpers/classPrivateFieldSet";
import _classPrivateFieldGet from "@babel/runtime-corejs3/helpers/classPrivateFieldGet";
function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }
function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }
import _rlp from 'rlp';
const {
  encode: rlpEncode
} = _rlp;
import { hash } from "../../../utils/crypto.mjs";
import { MerkleTreeHashMismatchError, MissingNodeInTreeError, UnknownPathNibbleError, UnexpectedTsError, UnknownNodeLengthError, InternalError } from "../../../utils/errors.mjs";
import { decode, encode, Encoding } from "../../../utils/encoder.mjs";
var NodeType = /*#__PURE__*/function (NodeType) {
  NodeType[NodeType["Branch"] = 0] = "Branch";
  NodeType[NodeType["Extension"] = 1] = "Extension";
  NodeType[NodeType["Leaf"] = 2] = "Leaf";
  return NodeType;
}(NodeType || {});
var _rootHash = /*#__PURE__*/new WeakMap();
var _isComplete = /*#__PURE__*/new WeakMap();
var _nodes = /*#__PURE__*/new WeakMap();
var _encoding = /*#__PURE__*/new WeakMap();
var _tag = /*#__PURE__*/new WeakMap();
var _unpackTx = /*#__PURE__*/new WeakMap();
var _getRaw = /*#__PURE__*/new WeakSet();
var _entriesRaw = /*#__PURE__*/new WeakSet();
class MPTree {
  get isComplete() {
    return _classPrivateFieldGet(this, _isComplete);
  }
  /**
   * Deserialize Merkle Patricia Tree
   * @param binary - Binary
   * @param tag - Tag to use to decode value
   * @param unpTx - Implementation of unpackTx use to decode values
   * @returns Merkle Patricia Tree
   */
  constructor(binary, encoding, tag, unpTx) {
    _classPrivateMethodInitSpec(this, _entriesRaw);
    /**
     * Retrieve value from Merkle Patricia Tree
     * @param _key - The key of the element to retrieve
     * @returns Value associated to the specified key
     */
    _classPrivateMethodInitSpec(this, _getRaw);
    _classPrivateFieldInitSpec(this, _rootHash, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _isComplete, {
      writable: true,
      value: true
    });
    _classPrivateFieldInitSpec(this, _nodes, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _encoding, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _tag, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _unpackTx, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldSet(this, _encoding, encoding);
    _classPrivateFieldSet(this, _tag, tag);
    _classPrivateFieldSet(this, _unpackTx, unpTx);
    _classPrivateFieldSet(this, _rootHash, binary[0].toString('hex'));
    _classPrivateFieldSet(this, _nodes, Object.fromEntries(binary[1].map(node => [node[0].toString('hex'), node[1]])));
    if (_classPrivateFieldGet(this, _nodes)[_classPrivateFieldGet(this, _rootHash)] == null) {
      if (Object.keys(_classPrivateFieldGet(this, _nodes)).length !== 0) {
        throw new MissingNodeInTreeError('Can\'t find a node by root hash');
      }
      _classPrivateFieldSet(this, _isComplete, false);
      return;
    }
    Object.entries(_classPrivateFieldGet(this, _nodes)).forEach(_ref => {
      let [key, node] = _ref;
      if (_classStaticPrivateMethodGet(MPTree, MPTree, _nodeHash).call(MPTree, node) !== key) throw new MerkleTreeHashMismatchError();
      const {
        type
      } = _classStaticPrivateMethodGet(MPTree, MPTree, _parseNode).call(MPTree, node);
      switch (type) {
        case NodeType.Branch:
          node.slice(0, 16).filter(n => n.length).forEach(n => {
            // TODO: enable after resolving https://github.com/aeternity/aeternity/issues/4066
            // if (n.length !== 32) {
            //   throw new ArgumentError('MPTree branch item length', 32, n.length);
            // }
            if (_classPrivateFieldGet(this, _nodes)[n.toString('hex')] == null) _classPrivateFieldSet(this, _isComplete, false);
          });
          break;
        case NodeType.Extension:
          if (_classPrivateFieldGet(this, _nodes)[node[1].toString('hex')] == null) {
            throw new MissingNodeInTreeError('Can\'t find a node by hash in extension node');
          }
          break;
        case NodeType.Leaf:
          break;
        default:
          throw new InternalError(`Unknown MPTree node type: ${type}`);
      }
    });
  }
  isEqual(tree) {
    return _classPrivateFieldGet(this, _rootHash) === _classPrivateFieldGet(tree, _rootHash);
  }
  /**
   * Serialize Merkle Patricia Tree
   * @returns Binary
   */
  serialize() {
    return [_Buffer.from(_classPrivateFieldGet(this, _rootHash), 'hex'), Object.entries(_classPrivateFieldGet(this, _nodes)).map(_ref2 => {
      let [mptHash, value] = _ref2;
      return [_Buffer.from(mptHash, 'hex'), value];
    })];
  }
  /**
   * Retrieve value from Merkle Patricia Tree
   * @param key - The key of the element to retrieve
   * @returns Value associated to the specified key
   */
  get(key) {
    const d = _classPrivateMethodGet(this, _getRaw, _getRaw2).call(this, decode(key).toString('hex'));
    if (d == null) return d;
    return _classPrivateFieldGet(this, _unpackTx).call(this, encode(d, Encoding.Transaction), _classPrivateFieldGet(this, _tag));
  }
  toObject() {
    return Object.fromEntries(_classPrivateMethodGet(this, _entriesRaw, _entriesRaw2).call(this) // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066
    .filter(_ref3 => {
      let [k] = _ref3;
      return _classPrivateFieldGet(this, _encoding) !== Encoding.ContractAddress || k.length !== 66;
    }).map(_ref4 => {
      let [k, v] = _ref4;
      return [encode(_Buffer.from(k, 'hex'), _classPrivateFieldGet(this, _encoding)), _classPrivateFieldGet(this, _unpackTx).call(this, encode(v, Encoding.Transaction), _classPrivateFieldGet(this, _tag))];
    }));
  }
}
function _nodeHash(node) {
  return _Buffer.from(hash(rlpEncode(node))).toString('hex');
}
function _parseNode(node) {
  switch (node.length) {
    case 17:
      return {
        type: NodeType.Branch,
        ...(node[16].length !== 0 && {
          value: node[16]
        })
      };
    case 2:
      {
        const nibble = node[0][0] >> 4; // eslint-disable-line no-bitwise
        if (nibble > 3) throw new UnknownPathNibbleError(nibble);
        const type = nibble <= 1 ? NodeType.Extension : NodeType.Leaf;
        const slice = [0, 2].includes(nibble) ? 2 : 1;
        return {
          type,
          ...(type === NodeType.Leaf && {
            value: node[1]
          }),
          path: node[0].toString('hex').slice(slice)
        };
      }
    default:
      throw new UnknownNodeLengthError(node.length);
  }
}
function _getRaw2(_key) {
  let searchFrom = _classPrivateFieldGet(this, _rootHash);
  let key = _key;
  while (true) {
    // eslint-disable-line no-constant-condition
    const node = _classPrivateFieldGet(this, _nodes)[searchFrom];
    if (node == null) {
      if (!this.isComplete) return undefined;
      throw new InternalError('Can\'t find node in complete tree');
    }
    const {
      type,
      value,
      path
    } = _classStaticPrivateMethodGet(MPTree, MPTree, _parseNode).call(MPTree, node);
    switch (type) {
      case NodeType.Branch:
        if (key.length === 0) return value;
        searchFrom = node[+`0x${key[0]}`].toString('hex');
        key = key.substring(1);
        break;
      case NodeType.Extension:
        if (key.substring(0, path === null || path === void 0 ? void 0 : path.length) !== path) return undefined;
        searchFrom = node[1].toString('hex');
        key = key.substring(path.length);
        break;
      case NodeType.Leaf:
        if (path !== key) return undefined;
        return value;
      default:
        throw new InternalError(`Unknown MPTree node type: ${type}`);
    }
  }
}
function _entriesRaw2() {
  const entries = [];
  const rec = (searchFrom, key) => {
    const node = _classPrivateFieldGet(this, _nodes)[searchFrom];
    if (node == null) {
      if (!this.isComplete) return;
      throw new InternalError('Can\'t find node in complete tree');
    }
    const {
      type,
      value,
      path
    } = _classStaticPrivateMethodGet(MPTree, MPTree, _parseNode).call(MPTree, node);
    switch (type) {
      case NodeType.Branch:
        node.slice(0, 16).map((t, idx) => [t, idx]).filter(_ref6 => {
          let [t] = _ref6;
          return t.length;
        }).forEach(_ref7 => {
          let [t, idx] = _ref7;
          return rec(t.toString('hex'), key + idx.toString(16));
        });
        if (value != null) entries.push([key, value]);
        break;
      case NodeType.Extension:
        rec(node[1].toString('hex'), key + path);
        break;
      case NodeType.Leaf:
        if (value == null) throw new UnexpectedTsError();
        entries.push([key + path, value]);
        break;
      default:
        throw new InternalError(`Unknown MPTree node type: ${type}`);
    }
  };
  rec(_classPrivateFieldGet(this, _rootHash), '');
  return entries;
}
export default function genMPTreeField(encoding, tag) {
  return {
    serialize(value) {
      return value.serialize();
    },
    deserialize(value, _ref5) {
      let {
        unpackTx
      } = _ref5;
      return new MPTree(value, encoding, tag, unpackTx);
    }
  };
}
//# sourceMappingURL=mptree.mjs.map