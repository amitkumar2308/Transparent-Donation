{"version":3,"file":"wrapped.mjs","names":["encode","Encoding","decode","genWrappedField","tag","serialize","payload","_ref","buildTx","deserialize","buffer","_ref2","unpackTx","Transaction","recursiveType"],"sources":["../../../../src/tx/builder/field-types/wrapped.ts"],"sourcesContent":["import { Tag } from '../constants';\nimport { encode, Encoding, decode } from '../../../utils/encoder';\nimport type { unpackTx as unpackTxType, buildTx as buildTxType } from '../index';\n\ntype TagWrapping = Tag.AccountsMtree | Tag.CallsMtree | Tag.ChannelsMtree | Tag.ContractsMtree\n| Tag.NameserviceMtree | Tag.OraclesMtree;\n\nexport default function genWrappedField<T extends TagWrapping>(tag: T): {\n  serialize: (\n    // TODO: replace with `(TxParams & { tag: T })['payload']`,\n    //  but fix TS2502 value is referenced directly or indirectly in its own type annotation\n    value: any, options: { buildTx: typeof buildTxType }\n  ) => Buffer;\n  deserialize: (\n    value: Buffer, options: { unpackTx: typeof unpackTxType },\n    // TODO: replace with `(TxUnpacked & { tag: T })['payload']`,\n    //  TS2577 Return type annotation circularly references itself\n  ) => any;\n  recursiveType: true;\n} {\n  return {\n    serialize(payload, { buildTx }) {\n      return decode(buildTx({ tag, payload }));\n    },\n\n    deserialize(buffer, { unpackTx }) {\n      return unpackTx<TagWrapping>(encode(buffer, Encoding.Transaction), tag).payload;\n    },\n\n    recursiveType: true,\n  };\n}\n"],"mappings":"SACSA,MAAM,EAAEC,QAAQ,EAAEC,MAAM;AAMjC,eAAe,SAASC,eAAeA,CAAwBC,GAAM,EAYnE;EACA,OAAO;IACLC,SAASA,CAACC,OAAO,EAAAC,IAAA,EAAe;MAAA,IAAb;QAAEC;MAAQ,CAAC,GAAAD,IAAA;MAC5B,OAAOL,MAAM,CAACM,OAAO,CAAC;QAAEJ,GAAG;QAAEE;MAAQ,CAAC,CAAC,CAAC;IAC1C,CAAC;IAEDG,WAAWA,CAACC,MAAM,EAAAC,KAAA,EAAgB;MAAA,IAAd;QAAEC;MAAS,CAAC,GAAAD,KAAA;MAC9B,OAAOC,QAAQ,CAAcZ,MAAM,CAACU,MAAM,EAAET,QAAQ,CAACY,WAAW,CAAC,EAAET,GAAG,CAAC,CAACE,OAAO;IACjF,CAAC;IAEDQ,aAAa,EAAE;EACjB,CAAC;AACH"}