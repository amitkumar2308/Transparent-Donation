(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@azure/core-rest-pipeline"), require("rlp"), require("bs58"), require("buffer"), require("bignumber.js"), require("tweetnacl"), require("varuint-bitcoin"), require("@azure/core-client"), require("@aeternity/aepp-calldata"), require("canonicalize"), require("@aeternity/uuid"), require("@aeternity/argon2"), require("tweetnacl-auth"), require("bip32-path"), require("aes-js"), require("json-bigint"), require("events"), require("websocket"), require("isomorphic-ws"));
	else if(typeof define === 'function' && define.amd)
		define(["@azure/core-rest-pipeline", "rlp", "bs58", "buffer", "bignumber.js", "tweetnacl", "varuint-bitcoin", "@azure/core-client", "@aeternity/aepp-calldata", "canonicalize", "@aeternity/uuid", "@aeternity/argon2", "tweetnacl-auth", "bip32-path", "aes-js", "json-bigint", "events", "websocket", "isomorphic-ws"], factory);
	else if(typeof exports === 'object')
		exports["Aeternity"] = factory(require("@azure/core-rest-pipeline"), require("rlp"), require("bs58"), require("buffer"), require("bignumber.js"), require("tweetnacl"), require("varuint-bitcoin"), require("@azure/core-client"), require("@aeternity/aepp-calldata"), require("canonicalize"), require("@aeternity/uuid"), require("@aeternity/argon2"), require("tweetnacl-auth"), require("bip32-path"), require("aes-js"), require("json-bigint"), require("events"), require("websocket"), require("isomorphic-ws"));
	else
		root["Aeternity"] = factory(root["@azure/core-rest-pipeline"], root["rlp"], root["bs58"], root["buffer"], root["bignumber.js"], root["tweetnacl"], root["varuint-bitcoin"], root["@azure/core-client"], root["@aeternity/aepp-calldata"], root["canonicalize"], root["@aeternity/uuid"], root["@aeternity/argon2"], root["tweetnacl-auth"], root["bip32-path"], root["aes-js"], root["json-bigint"], root["events"], root["websocket"], root["isomorphic-ws"]);
})(global, (__WEBPACK_EXTERNAL_MODULE__5039__, __WEBPACK_EXTERNAL_MODULE__3485__, __WEBPACK_EXTERNAL_MODULE__3783__, __WEBPACK_EXTERNAL_MODULE__9408__, __WEBPACK_EXTERNAL_MODULE__5192__, __WEBPACK_EXTERNAL_MODULE__79__, __WEBPACK_EXTERNAL_MODULE__7480__, __WEBPACK_EXTERNAL_MODULE__4711__, __WEBPACK_EXTERNAL_MODULE__7946__, __WEBPACK_EXTERNAL_MODULE__6667__, __WEBPACK_EXTERNAL_MODULE__3983__, __WEBPACK_EXTERNAL_MODULE__7417__, __WEBPACK_EXTERNAL_MODULE__9882__, __WEBPACK_EXTERNAL_MODULE__1986__, __WEBPACK_EXTERNAL_MODULE__8236__, __WEBPACK_EXTERNAL_MODULE__2716__, __WEBPACK_EXTERNAL_MODULE__3735__, __WEBPACK_EXTERNAL_MODULE__8079__, __WEBPACK_EXTERNAL_MODULE__3153__) => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 8442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch

const util = __webpack_require__(9488)

// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA (v, a, b) {
  const o0 = v[a] + v[b]
  let o1 = v[a + 1] + v[b + 1]
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC (v, a, b0, b1) {
  let o0 = v[a] + b0
  if (b0 < 0) {
    o0 += 0x100000000
  }
  let o1 = v[a + 1] + b1
  if (o0 >= 0x100000000) {
    o1++
  }
  v[a] = o0
  v[a + 1] = o1
}

// Little-endian byte access
function B2B_GET32 (arr, i) {
  return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
}

// G Mixing function
// The ROTRs are inlined for speed
function B2B_G (a, b, c, d, ix, iy) {
  const x0 = m[ix]
  const x1 = m[ix + 1]
  const y0 = m[iy]
  const y1 = m[iy + 1]

  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
  let xor0 = v[d] ^ v[a]
  let xor1 = v[d + 1] ^ v[a + 1]
  v[d] = xor1
  v[d + 1] = xor0

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor0 >>> 24) ^ (xor1 << 8)
  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)

  ADD64AA(v, a, b)
  ADD64AC(v, a, y0, y1)

  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
  xor0 = v[d] ^ v[a]
  xor1 = v[d + 1] ^ v[a + 1]
  v[d] = (xor0 >>> 16) ^ (xor1 << 16)
  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)

  ADD64AA(v, c, d)

  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
  xor0 = v[b] ^ v[c]
  xor1 = v[b + 1] ^ v[c + 1]
  v[b] = (xor1 >>> 31) ^ (xor0 << 1)
  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)
}

// Initialization Vector
const BLAKE2B_IV32 = new Uint32Array([
  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372,
  0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,
  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
])

const SIGMA8 = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13,
  6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1,
  9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4,
  10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,
  15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7,
  14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2,
  13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0,
  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6,
  1, 12, 0, 2, 11, 7, 5, 3
]

// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
const SIGMA82 = new Uint8Array(
  SIGMA8.map(function (x) {
    return x * 2
  })
)

// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
const v = new Uint32Array(32)
const m = new Uint32Array(32)
function blake2bCompress (ctx, last) {
  let i = 0

  // init work variables
  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i]
    v[i + 16] = BLAKE2B_IV32[i]
  }

  // low 64 bits of offset
  v[24] = v[24] ^ ctx.t
  v[25] = v[25] ^ (ctx.t / 0x100000000)
  // high 64 bits not supported, offset may not be higher than 2**53-1

  // last block flag set ?
  if (last) {
    v[28] = ~v[28]
    v[29] = ~v[29]
  }

  // get little-endian words
  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i)
  }

  // twelve rounds of mixing
  // uncomment the DebugPrint calls to log the computation
  // and match the RFC sample documentation
  // util.debugPrint('          m[16]', m, 64)
  for (i = 0; i < 12; i++) {
    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])
  }
  // util.debugPrint('   (i=12) v[16]', v, 64)

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]
  }
  // util.debugPrint('h[8]', ctx.h, 64)
}

// reusable parameterBlock
const parameterBlock = new Uint8Array([
  0,
  0,
  0,
  0, //  0: outlen, keylen, fanout, depth
  0,
  0,
  0,
  0, //  4: leaf length, sequential mode
  0,
  0,
  0,
  0, //  8: node offset
  0,
  0,
  0,
  0, // 12: node offset
  0,
  0,
  0,
  0, // 16: node depth, inner length, rfu
  0,
  0,
  0,
  0, // 20: rfu
  0,
  0,
  0,
  0, // 24: rfu
  0,
  0,
  0,
  0, // 28: rfu
  0,
  0,
  0,
  0, // 32: salt
  0,
  0,
  0,
  0, // 36: salt
  0,
  0,
  0,
  0, // 40: salt
  0,
  0,
  0,
  0, // 44: salt
  0,
  0,
  0,
  0, // 48: personal
  0,
  0,
  0,
  0, // 52: personal
  0,
  0,
  0,
  0, // 56: personal
  0,
  0,
  0,
  0 // 60: personal
])

// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
// Takes an optinal Uint8Array salt
// Takes an optinal Uint8Array personal
function blake2bInit (outlen, key, salt, personal) {
  if (outlen === 0 || outlen > 64) {
    throw new Error('Illegal output length, expected 0 < length <= 64')
  }
  if (key && key.length > 64) {
    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
  }
  if (salt && salt.length !== 16) {
    throw new Error('Illegal salt, expected Uint8Array with length is 16')
  }
  if (personal && personal.length !== 16) {
    throw new Error('Illegal personal, expected Uint8Array with length is 16')
  }

  // state, 'param block'
  const ctx = {
    b: new Uint8Array(128),
    h: new Uint32Array(16),
    t: 0, // input count
    c: 0, // pointer within buffer
    outlen: outlen // output length in bytes
  }

  // initialize parameterBlock before usage
  parameterBlock.fill(0)
  parameterBlock[0] = outlen
  if (key) parameterBlock[1] = key.length
  parameterBlock[2] = 1 // fanout
  parameterBlock[3] = 1 // depth
  if (salt) parameterBlock.set(salt, 32)
  if (personal) parameterBlock.set(personal, 48)

  // initialize hash state
  for (let i = 0; i < 16; i++) {
    ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4)
  }

  // key the hash, if applicable
  if (key) {
    blake2bUpdate(ctx, key)
    // at the end
    ctx.c = 128
  }

  return ctx
}

// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate (ctx, input) {
  for (let i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      // buffer full ?
      ctx.t += ctx.c // add counters
      blake2bCompress(ctx, false) // compress (not last)
      ctx.c = 0 // counter to zero
    }
    ctx.b[ctx.c++] = input[i]
  }
}

// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal (ctx) {
  ctx.t += ctx.c // mark last block offset

  while (ctx.c < 128) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0
  }
  blake2bCompress(ctx, true) // final block flag = 1

  // little endian convert and store
  const out = new Uint8Array(ctx.outlen)
  for (let i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))
  }
  return out
}

// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2b (input, key, outlen, salt, personal) {
  // preprocess inputs
  outlen = outlen || 64
  input = util.normalizeInput(input)
  if (salt) {
    salt = util.normalizeInput(salt)
  }
  if (personal) {
    personal = util.normalizeInput(personal)
  }

  // do the math
  const ctx = blake2bInit(outlen, key, salt, personal)
  blake2bUpdate(ctx, input)
  return blake2bFinal(ctx)
}

// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2bHex (input, key, outlen, salt, personal) {
  const output = blake2b(input, key, outlen, salt, personal)
  return util.toHex(output)
}

module.exports = {
  blake2b: blake2b,
  blake2bHex: blake2bHex,
  blake2bInit: blake2bInit,
  blake2bUpdate: blake2bUpdate,
  blake2bFinal: blake2bFinal
}


/***/ }),

/***/ 9488:
/***/ ((module) => {

const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'

// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput (input) {
  let ret
  if (input instanceof Uint8Array) {
    ret = input
  } else if (typeof input === 'string') {
    const encoder = new TextEncoder()
    ret = encoder.encode(input)
  } else {
    throw new Error(ERROR_MSG_INPUT)
  }
  return ret
}

// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex (bytes) {
  return Array.prototype.map
    .call(bytes, function (n) {
      return (n < 16 ? '0' : '') + n.toString(16)
    })
    .join('')
}

// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex (val) {
  return (0x100000000 + val).toString(16).substring(1)
}

// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint (label, arr, size) {
  let msg = '\n' + label + ' = '
  for (let i = 0; i < arr.length; i += 2) {
    if (size === 32) {
      msg += uint32ToHex(arr[i]).toUpperCase()
      msg += ' '
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
    } else if (size === 64) {
      msg += uint32ToHex(arr[i + 1]).toUpperCase()
      msg += uint32ToHex(arr[i]).toUpperCase()
    } else throw new Error('Invalid size ' + size)
    if (i % 6 === 4) {
      msg += '\n' + new Array(label.length + 4).join(' ')
    } else if (i < arr.length - 2) {
      msg += ' '
    }
  }
  console.log(msg)
}

// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed (hashFn, N, M) {
  let startMs = new Date().getTime()

  const input = new Uint8Array(N)
  for (let i = 0; i < N; i++) {
    input[i] = i % 256
  }
  const genMs = new Date().getTime()
  console.log('Generated random input in ' + (genMs - startMs) + 'ms')
  startMs = genMs

  for (let i = 0; i < M; i++) {
    const hashHex = hashFn(input)
    const hashMs = new Date().getTime()
    const ms = hashMs - startMs
    startMs = hashMs
    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')
    console.log(
      Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'
    )
  }
}

module.exports = {
  normalizeInput: normalizeInput,
  toHex: toHex,
  debugPrint: debugPrint,
  testSpeed: testSpeed
}


/***/ }),

/***/ 3536:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(1910);

module.exports = parent;


/***/ }),

/***/ 281:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(2547);

__webpack_require__(7522);
__webpack_require__(8783);
__webpack_require__(3975);
__webpack_require__(5414);

module.exports = parent;


/***/ }),

/***/ 31:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(6509);

module.exports = parent;


/***/ }),

/***/ 7487:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(5774);

module.exports = parent;


/***/ }),

/***/ 6793:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isPrototypeOf = __webpack_require__(7046);
var flags = __webpack_require__(1677);

var RegExpPrototype = RegExp.prototype;

module.exports = function (it) {
  return (it === RegExpPrototype || isPrototypeOf(RegExpPrototype, it)) ? flags(it) : it.flags;
};


/***/ }),

/***/ 8171:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(6450);
var path = __webpack_require__(4058);

var Object = path.Object;

var defineProperty = module.exports = function defineProperty(it, key, desc) {
  return Object.defineProperty(it, key, desc);
};

if (Object.defineProperty.sham) defineProperty.sham = true;


/***/ }),

/***/ 1677:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(4261);
var getRegExpFlags = __webpack_require__(3613);

module.exports = getRegExpFlags;


/***/ }),

/***/ 7473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(5906);
__webpack_require__(5967);
__webpack_require__(5824);
__webpack_require__(8555);
__webpack_require__(2615);
__webpack_require__(1732);
__webpack_require__(5903);
__webpack_require__(1825);
__webpack_require__(8394);
__webpack_require__(5915);
__webpack_require__(1766);
__webpack_require__(2737);
__webpack_require__(9911);
__webpack_require__(4315);
__webpack_require__(3131);
__webpack_require__(4714);
__webpack_require__(659);
__webpack_require__(9120);
__webpack_require__(5327);
__webpack_require__(1502);
var path = __webpack_require__(4058);

module.exports = path.Symbol;


/***/ }),

/***/ 4227:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(6274);
__webpack_require__(5967);
__webpack_require__(7971);
__webpack_require__(1825);
var WrappedWellKnownSymbolModule = __webpack_require__(1477);

module.exports = WrappedWellKnownSymbolModule.f('iterator');


/***/ }),

/***/ 2978:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(8084);
__webpack_require__(3131);
var WrappedWellKnownSymbolModule = __webpack_require__(1477);

module.exports = WrappedWellKnownSymbolModule.f('toPrimitive');


/***/ }),

/***/ 3685:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(621);


/***/ }),

/***/ 6600:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(2201);


/***/ }),

/***/ 9759:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(7398);


/***/ }),

/***/ 1384:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(6189);


/***/ }),

/***/ 621:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(3536);

module.exports = parent;


/***/ }),

/***/ 2201:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(281);
__webpack_require__(7618);
__webpack_require__(6989);
__webpack_require__(5799);
__webpack_require__(6774);
// TODO: Remove from `core-js@4`
__webpack_require__(2731);
__webpack_require__(5605);
__webpack_require__(1943);
__webpack_require__(620);
__webpack_require__(6172);

module.exports = parent;


/***/ }),

/***/ 7398:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(31);

module.exports = parent;


/***/ }),

/***/ 6189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(7487);

module.exports = parent;


/***/ }),

/***/ 4883:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(7475);
var tryToString = __webpack_require__(9826);

var $TypeError = TypeError;

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw $TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 1851:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(7475);

var $String = String;
var $TypeError = TypeError;

module.exports = function (argument) {
  if (typeof argument == 'object' || isCallable(argument)) return argument;
  throw $TypeError("Can't set " + $String(argument) + ' as a prototype');
};


/***/ }),

/***/ 8479:
/***/ ((module) => {

"use strict";

module.exports = function () { /* empty */ };


/***/ }),

/***/ 6059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isObject = __webpack_require__(941);

var $String = String;
var $TypeError = TypeError;

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw $TypeError($String(argument) + ' is not an object');
};


/***/ }),

/***/ 1692:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(4529);
var toAbsoluteIndex = __webpack_require__(9413);
var lengthOfArrayLike = __webpack_require__(623);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = lengthOfArrayLike(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 3610:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bind = __webpack_require__(6843);
var uncurryThis = __webpack_require__(5329);
var IndexedObject = __webpack_require__(7026);
var toObject = __webpack_require__(9678);
var lengthOfArrayLike = __webpack_require__(623);
var arraySpeciesCreate = __webpack_require__(4692);

var push = uncurryThis([].push);

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_REJECT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that);
    var length = lengthOfArrayLike(self);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push(target, value);      // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push(target, value);      // filterReject
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: createMethod(7)
};


/***/ }),

/***/ 568:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(5981);
var wellKnownSymbol = __webpack_require__(9813);
var V8_VERSION = __webpack_require__(3385);

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ 5790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toAbsoluteIndex = __webpack_require__(9413);
var lengthOfArrayLike = __webpack_require__(623);
var createProperty = __webpack_require__(5449);

var $Array = Array;
var max = Math.max;

module.exports = function (O, start, end) {
  var length = lengthOfArrayLike(O);
  var k = toAbsoluteIndex(start, length);
  var fin = toAbsoluteIndex(end === undefined ? length : end, length);
  var result = $Array(max(fin - k, 0));
  for (var n = 0; k < fin; k++, n++) createProperty(result, n, O[k]);
  result.length = n;
  return result;
};


/***/ }),

/***/ 3765:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);

module.exports = uncurryThis([].slice);


/***/ }),

/***/ 5693:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isArray = __webpack_require__(1052);
var isConstructor = __webpack_require__(4284);
var isObject = __webpack_require__(941);
var wellKnownSymbol = __webpack_require__(9813);

var SPECIES = wellKnownSymbol('species');
var $Array = Array;

// a part of `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (isConstructor(C) && (C === $Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? $Array : C;
};


/***/ }),

/***/ 4692:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var arraySpeciesConstructor = __webpack_require__(5693);

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};


/***/ }),

/***/ 2532:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);

var toString = uncurryThis({}.toString);
var stringSlice = uncurryThis(''.slice);

module.exports = function (it) {
  return stringSlice(toString(it), 8, -1);
};


/***/ }),

/***/ 9697:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(2885);
var isCallable = __webpack_require__(7475);
var classofRaw = __webpack_require__(2532);
var wellKnownSymbol = __webpack_require__(9813);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var $Object = Object;

// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 4160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(5981);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 3538:
/***/ ((module) => {

"use strict";

// `CreateIterResultObject` abstract operation
// https://tc39.es/ecma262/#sec-createiterresultobject
module.exports = function (value, done) {
  return { value: value, done: done };
};


/***/ }),

/***/ 2029:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(5746);
var definePropertyModule = __webpack_require__(5988);
var createPropertyDescriptor = __webpack_require__(1887);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 1887:
/***/ ((module) => {

"use strict";

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 5449:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(3894);
var definePropertyModule = __webpack_require__(5988);
var createPropertyDescriptor = __webpack_require__(1887);

module.exports = function (object, key, value) {
  var propertyKey = toPropertyKey(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ 9202:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineProperty = __webpack_require__(5988);

module.exports = function (target, name, descriptor) {
  return defineProperty.f(target, name, descriptor);
};


/***/ }),

/***/ 5929:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var createNonEnumerableProperty = __webpack_require__(2029);

module.exports = function (target, key, value, options) {
  if (options && options.enumerable) target[key] = value;
  else createNonEnumerableProperty(target, key, value);
  return target;
};


/***/ }),

/***/ 5609:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var defineProperty = Object.defineProperty;

module.exports = function (key, value) {
  try {
    defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 5746:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(5981);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 6616:
/***/ ((module) => {

"use strict";

var documentAll = typeof document == 'object' && document.all;

// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot
// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing
var IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;

module.exports = {
  all: documentAll,
  IS_HTMLDDA: IS_HTMLDDA
};


/***/ }),

/***/ 1333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);
var isObject = __webpack_require__(941);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 6796:
/***/ ((module) => {

"use strict";

var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991

module.exports = function (it) {
  if (it > MAX_SAFE_INTEGER) throw $TypeError('Maximum allowed index exceeded');
  return it;
};


/***/ }),

/***/ 3281:
/***/ ((module) => {

"use strict";

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 2861:
/***/ ((module) => {

"use strict";

module.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';


/***/ }),

/***/ 3385:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);
var userAgent = __webpack_require__(2861);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  // in old Chrome, versions of V8 isn't V8 = Chrome / 10
  // but their correct versions are not interesting for us
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}

// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`
// so check `userAgent` even if `.v8` exists, but 0
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = +match[1];
  }
}

module.exports = version;


/***/ }),

/***/ 6759:
/***/ ((module) => {

"use strict";

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 6887:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);
var apply = __webpack_require__(9730);
var uncurryThis = __webpack_require__(7484);
var isCallable = __webpack_require__(7475);
var getOwnPropertyDescriptor = (__webpack_require__(9677).f);
var isForced = __webpack_require__(7252);
var path = __webpack_require__(4058);
var bind = __webpack_require__(6843);
var createNonEnumerableProperty = __webpack_require__(2029);
var hasOwn = __webpack_require__(953);

var wrapConstructor = function (NativeConstructor) {
  var Wrapper = function (a, b, c) {
    if (this instanceof Wrapper) {
      switch (arguments.length) {
        case 0: return new NativeConstructor();
        case 1: return new NativeConstructor(a);
        case 2: return new NativeConstructor(a, b);
      } return new NativeConstructor(a, b, c);
    } return apply(NativeConstructor, this, arguments);
  };
  Wrapper.prototype = NativeConstructor.prototype;
  return Wrapper;
};

/*
  options.target         - name of the target object
  options.global         - target is the global object
  options.stat           - export as static methods of target
  options.proto          - export as prototype methods of target
  options.real           - real prototype method for the `pure` version
  options.forced         - export even if the native feature is available
  options.bind           - bind methods to the target, required for the `pure` version
  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe         - use the simple assignment of property instead of delete + defineProperty
  options.sham           - add a flag to not completely full polyfills
  options.enumerable     - export as enumerable property
  options.dontCallGetSet - prevent calling a getter on target
  options.name           - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var PROTO = options.proto;

  var nativeSource = GLOBAL ? global : STATIC ? global[TARGET] : (global[TARGET] || {}).prototype;

  var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
  var targetPrototype = target.prototype;

  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

  for (key in source) {
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contains in native
    USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);

    targetProperty = target[key];

    if (USE_NATIVE) if (options.dontCallGetSet) {
      descriptor = getOwnPropertyDescriptor(nativeSource, key);
      nativeProperty = descriptor && descriptor.value;
    } else nativeProperty = nativeSource[key];

    // export native or implementation
    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;

    // bind methods to global for calling from export context
    if (options.bind && USE_NATIVE) resultProperty = bind(sourceProperty, global);
    // wrap global constructors for prevent changes in this version
    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
    // make static versions for prototype methods
    else if (PROTO && isCallable(sourceProperty)) resultProperty = uncurryThis(sourceProperty);
    // default case
    else resultProperty = sourceProperty;

    // add a flag to not completely full polyfills
    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(resultProperty, 'sham', true);
    }

    createNonEnumerableProperty(target, key, resultProperty);

    if (PROTO) {
      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
      if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
      }
      // export virtual prototype methods
      createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
      // export real prototype methods
      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {
        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
      }
    }
  }
};


/***/ }),

/***/ 5981:
/***/ ((module) => {

"use strict";

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 9730:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(8285);

var FunctionPrototype = Function.prototype;
var apply = FunctionPrototype.apply;
var call = FunctionPrototype.call;

// eslint-disable-next-line es/no-reflect -- safe
module.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {
  return call.apply(apply, arguments);
});


/***/ }),

/***/ 6843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(7484);
var aCallable = __webpack_require__(4883);
var NATIVE_BIND = __webpack_require__(8285);

var bind = uncurryThis(uncurryThis.bind);

// optional / simple context binding
module.exports = function (fn, that) {
  aCallable(fn);
  return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 8285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(5981);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-function-prototype-bind -- safe
  var test = (function () { /* empty */ }).bind();
  // eslint-disable-next-line no-prototype-builtins -- safe
  return typeof test != 'function' || test.hasOwnProperty('prototype');
});


/***/ }),

/***/ 8834:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(8285);

var call = Function.prototype.call;

module.exports = NATIVE_BIND ? call.bind(call) : function () {
  return call.apply(call, arguments);
};


/***/ }),

/***/ 9417:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(5746);
var hasOwn = __webpack_require__(953);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = hasOwn(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 5526:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);
var aCallable = __webpack_require__(4883);

module.exports = function (object, key, method) {
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));
  } catch (error) { /* empty */ }
};


/***/ }),

/***/ 7484:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classofRaw = __webpack_require__(2532);
var uncurryThis = __webpack_require__(5329);

module.exports = function (fn) {
  // Nashorn bug:
  //   https://github.com/zloirock/core-js/issues/1128
  //   https://github.com/zloirock/core-js/issues/1130
  if (classofRaw(fn) === 'Function') return uncurryThis(fn);
};


/***/ }),

/***/ 5329:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_BIND = __webpack_require__(8285);

var FunctionPrototype = Function.prototype;
var call = FunctionPrototype.call;
var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);

module.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {
  return function () {
    return call.apply(fn, arguments);
  };
};


/***/ }),

/***/ 626:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(4058);
var global = __webpack_require__(1899);
var isCallable = __webpack_require__(7475);

var aFunction = function (variable) {
  return isCallable(variable) ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 3323:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);
var isArray = __webpack_require__(1052);
var isCallable = __webpack_require__(7475);
var classof = __webpack_require__(2532);
var toString = __webpack_require__(5803);

var push = uncurryThis([].push);

module.exports = function (replacer) {
  if (isCallable(replacer)) return replacer;
  if (!isArray(replacer)) return;
  var rawLength = replacer.length;
  var keys = [];
  for (var i = 0; i < rawLength; i++) {
    var element = replacer[i];
    if (typeof element == 'string') push(keys, element);
    else if (typeof element == 'number' || classof(element) == 'Number' || classof(element) == 'String') push(keys, toString(element));
  }
  var keysLength = keys.length;
  var root = true;
  return function (key, value) {
    if (root) {
      root = false;
      return value;
    }
    if (isArray(this)) return value;
    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;
  };
};


/***/ }),

/***/ 4229:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var aCallable = __webpack_require__(4883);
var isNullOrUndefined = __webpack_require__(2119);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return isNullOrUndefined(func) ? undefined : aCallable(func);
};


/***/ }),

/***/ 1899:
/***/ (function(module) {

"use strict";

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || this || Function('return this')();


/***/ }),

/***/ 953:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);
var toObject = __webpack_require__(9678);

var hasOwnProperty = uncurryThis({}.hasOwnProperty);

// `HasOwnProperty` abstract operation
// https://tc39.es/ecma262/#sec-hasownproperty
// eslint-disable-next-line es/no-object-hasown -- safe
module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty(toObject(it), key);
};


/***/ }),

/***/ 7748:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 5463:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(626);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 2840:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(5746);
var fails = __webpack_require__(5981);
var createElement = __webpack_require__(1333);

// Thanks to IE8 for its funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 7026:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);
var fails = __webpack_require__(5981);
var classof = __webpack_require__(2532);

var $Object = Object;
var split = uncurryThis(''.split);

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !$Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split(it, '') : $Object(it);
} : $Object;


/***/ }),

/***/ 1302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);
var isCallable = __webpack_require__(7475);
var store = __webpack_require__(3030);

var functionToString = uncurryThis(Function.toString);

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 5402:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_WEAK_MAP = __webpack_require__(7093);
var global = __webpack_require__(1899);
var isObject = __webpack_require__(941);
var createNonEnumerableProperty = __webpack_require__(2029);
var hasOwn = __webpack_require__(953);
var shared = __webpack_require__(3030);
var sharedKey = __webpack_require__(4262);
var hiddenKeys = __webpack_require__(7748);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var TypeError = global.TypeError;
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  /* eslint-disable no-self-assign -- prototype methods protection */
  store.get = store.get;
  store.has = store.has;
  store.set = store.set;
  /* eslint-enable no-self-assign -- prototype methods protection */
  set = function (it, metadata) {
    if (store.has(it)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    store.set(it, metadata);
    return metadata;
  };
  get = function (it) {
    return store.get(it) || {};
  };
  has = function (it) {
    return store.has(it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (hasOwn(it, STATE)) throw TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return hasOwn(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return hasOwn(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 1052:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(2532);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(argument) {
  return classof(argument) == 'Array';
};


/***/ }),

/***/ 7475:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $documentAll = __webpack_require__(6616);

var documentAll = $documentAll.all;

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = $documentAll.IS_HTMLDDA ? function (argument) {
  return typeof argument == 'function' || argument === documentAll;
} : function (argument) {
  return typeof argument == 'function';
};


/***/ }),

/***/ 4284:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);
var fails = __webpack_require__(5981);
var isCallable = __webpack_require__(7475);
var classof = __webpack_require__(9697);
var getBuiltIn = __webpack_require__(626);
var inspectSource = __webpack_require__(1302);

var noop = function () { /* empty */ };
var empty = [];
var construct = getBuiltIn('Reflect', 'construct');
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);

var isConstructorModern = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error) {
    return false;
  }
};

var isConstructorLegacy = function isConstructor(argument) {
  if (!isCallable(argument)) return false;
  switch (classof(argument)) {
    case 'AsyncFunction':
    case 'GeneratorFunction':
    case 'AsyncGeneratorFunction': return false;
  }
  try {
    // we can't check .prototype since constructors produced by .bind haven't it
    // `Function#toString` throws on some built-it function in some legacy engines
    // (for example, `DOMQuad` and similar in FF41-)
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error) {
    return true;
  }
};

isConstructorLegacy.sham = true;

// `IsConstructor` abstract operation
// https://tc39.es/ecma262/#sec-isconstructor
module.exports = !construct || fails(function () {
  var called;
  return isConstructorModern(isConstructorModern.call)
    || !isConstructorModern(Object)
    || !isConstructorModern(function () { called = true; })
    || called;
}) ? isConstructorLegacy : isConstructorModern;


/***/ }),

/***/ 7252:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(5981);
var isCallable = __webpack_require__(7475);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 2119:
/***/ ((module) => {

"use strict";

// we can't use just `it == null` since of `document.all` special case
// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec
module.exports = function (it) {
  return it === null || it === undefined;
};


/***/ }),

/***/ 941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isCallable = __webpack_require__(7475);
var $documentAll = __webpack_require__(6616);

var documentAll = $documentAll.all;

module.exports = $documentAll.IS_HTMLDDA ? function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;
} : function (it) {
  return typeof it == 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 2529:
/***/ ((module) => {

"use strict";

module.exports = true;


/***/ }),

/***/ 6664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(626);
var isCallable = __webpack_require__(7475);
var isPrototypeOf = __webpack_require__(7046);
var USE_SYMBOL_AS_UID = __webpack_require__(2302);

var $Object = Object;

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
};


/***/ }),

/***/ 3847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IteratorPrototype = (__webpack_require__(5143).IteratorPrototype);
var create = __webpack_require__(9290);
var createPropertyDescriptor = __webpack_require__(1887);
var setToStringTag = __webpack_require__(904);
var Iterators = __webpack_require__(2077);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(+!ENUMERABLE_NEXT, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 5105:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var call = __webpack_require__(8834);
var IS_PURE = __webpack_require__(2529);
var FunctionName = __webpack_require__(9417);
var isCallable = __webpack_require__(7475);
var createIteratorConstructor = __webpack_require__(3847);
var getPrototypeOf = __webpack_require__(249);
var setPrototypeOf = __webpack_require__(8929);
var setToStringTag = __webpack_require__(904);
var createNonEnumerableProperty = __webpack_require__(2029);
var defineBuiltIn = __webpack_require__(5929);
var wellKnownSymbol = __webpack_require__(9813);
var Iterators = __webpack_require__(2077);
var IteratorsCore = __webpack_require__(5143);

var PROPER_FUNCTION_NAME = FunctionName.PROPER;
var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
          defineBuiltIn(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF
  if (PROPER_FUNCTION_NAME && DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
      createNonEnumerableProperty(IterablePrototype, 'name', VALUES);
    } else {
      INCORRECT_VALUES_NAME = true;
      defaultIterator = function values() { return call(nativeIterator, this); };
    }
  }

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        defineBuiltIn(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    defineBuiltIn(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT });
  }
  Iterators[NAME] = defaultIterator;

  return methods;
};


/***/ }),

/***/ 5143:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var fails = __webpack_require__(5981);
var isCallable = __webpack_require__(7475);
var isObject = __webpack_require__(941);
var create = __webpack_require__(9290);
var getPrototypeOf = __webpack_require__(249);
var defineBuiltIn = __webpack_require__(5929);
var wellKnownSymbol = __webpack_require__(9813);
var IS_PURE = __webpack_require__(2529);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = !isObject(IteratorPrototype) || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
else if (IS_PURE) IteratorPrototype = create(IteratorPrototype);

// `%IteratorPrototype%[@@iterator]()` method
// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator
if (!isCallable(IteratorPrototype[ITERATOR])) {
  defineBuiltIn(IteratorPrototype, ITERATOR, function () {
    return this;
  });
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 2077:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 623:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toLength = __webpack_require__(3057);

// `LengthOfArrayLike` abstract operation
// https://tc39.es/ecma262/#sec-lengthofarraylike
module.exports = function (obj) {
  return toLength(obj.length);
};


/***/ }),

/***/ 5331:
/***/ ((module) => {

"use strict";

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc
// eslint-disable-next-line es/no-math-trunc -- safe
module.exports = Math.trunc || function trunc(x) {
  var n = +x;
  return (n > 0 ? floor : ceil)(n);
};


/***/ }),

/***/ 9290:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* global ActiveXObject -- old IE, WSH */
var anObject = __webpack_require__(6059);
var definePropertiesModule = __webpack_require__(9938);
var enumBugKeys = __webpack_require__(6759);
var hiddenKeys = __webpack_require__(7748);
var html = __webpack_require__(5463);
var documentCreateElement = __webpack_require__(1333);
var sharedKey = __webpack_require__(4262);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    activeXDocument = new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = typeof document != 'undefined'
    ? document.domain && activeXDocument
      ? NullProtoObjectViaActiveX(activeXDocument) // old IE
      : NullProtoObjectViaIFrame()
    : NullProtoObjectViaActiveX(activeXDocument); // WSH
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
// eslint-disable-next-line es/no-object-create -- safe
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : definePropertiesModule.f(result, Properties);
};


/***/ }),

/***/ 9938:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(5746);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(3937);
var definePropertyModule = __webpack_require__(5988);
var anObject = __webpack_require__(6059);
var toIndexedObject = __webpack_require__(4529);
var objectKeys = __webpack_require__(4771);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
exports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var props = toIndexedObject(Properties);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], props[key]);
  return O;
};


/***/ }),

/***/ 5988:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(5746);
var IE8_DOM_DEFINE = __webpack_require__(2840);
var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__(3937);
var anObject = __webpack_require__(6059);
var toPropertyKey = __webpack_require__(3894);

var $TypeError = TypeError;
// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = 'enumerable';
var CONFIGURABLE = 'configurable';
var WRITABLE = 'writable';

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  } return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw $TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 9677:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(5746);
var call = __webpack_require__(8834);
var propertyIsEnumerableModule = __webpack_require__(6760);
var createPropertyDescriptor = __webpack_require__(1887);
var toIndexedObject = __webpack_require__(4529);
var toPropertyKey = __webpack_require__(3894);
var hasOwn = __webpack_require__(953);
var IE8_DOM_DEFINE = __webpack_require__(2840);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};


/***/ }),

/***/ 684:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-object-getownpropertynames -- safe */
var classof = __webpack_require__(2532);
var toIndexedObject = __webpack_require__(4529);
var $getOwnPropertyNames = (__webpack_require__(946).f);
var arraySlice = __webpack_require__(5790);

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return arraySlice(windowNames);
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && classof(it) == 'Window'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ 946:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(5629);
var enumBugKeys = __webpack_require__(6759);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 7857:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 249:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var hasOwn = __webpack_require__(953);
var isCallable = __webpack_require__(7475);
var toObject = __webpack_require__(9678);
var sharedKey = __webpack_require__(4262);
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(4160);

var IE_PROTO = sharedKey('IE_PROTO');
var $Object = Object;
var ObjectPrototype = $Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {
  var object = toObject(O);
  if (hasOwn(object, IE_PROTO)) return object[IE_PROTO];
  var constructor = object.constructor;
  if (isCallable(constructor) && object instanceof constructor) {
    return constructor.prototype;
  } return object instanceof $Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 7046:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);

module.exports = uncurryThis({}.isPrototypeOf);


/***/ }),

/***/ 5629:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);
var hasOwn = __webpack_require__(953);
var toIndexedObject = __webpack_require__(4529);
var indexOf = (__webpack_require__(1692).indexOf);
var hiddenKeys = __webpack_require__(7748);

var push = uncurryThis([].push);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (hasOwn(O, key = names[i++])) {
    ~indexOf(result, key) || push(result, key);
  }
  return result;
};


/***/ }),

/***/ 4771:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var internalObjectKeys = __webpack_require__(5629);
var enumBugKeys = __webpack_require__(6759);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 6760:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 8929:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable no-proto -- safe */
var uncurryThisAccessor = __webpack_require__(5526);
var anObject = __webpack_require__(6059);
var aPossiblePrototype = __webpack_require__(1851);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');
    setter(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 5623:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(2885);
var classof = __webpack_require__(9697);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 9811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(8834);
var isCallable = __webpack_require__(7475);
var isObject = __webpack_require__(941);

var $TypeError = TypeError;

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input))) return val;
  throw $TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 4058:
/***/ ((module) => {

"use strict";

module.exports = {};


/***/ }),

/***/ 6777:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var anObject = __webpack_require__(6059);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.hasIndices) result += 'd';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.unicodeSets) result += 'v';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 3613:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(8834);
var hasOwn = __webpack_require__(953);
var isPrototypeOf = __webpack_require__(7046);
var regExpFlags = __webpack_require__(6777);

var RegExpPrototype = RegExp.prototype;

module.exports = function (R) {
  var flags = R.flags;
  return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R)
    ? call(regExpFlags, R) : flags;
};


/***/ }),

/***/ 8219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var isNullOrUndefined = __webpack_require__(2119);

var $TypeError = TypeError;

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (isNullOrUndefined(it)) throw $TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 904:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__(2885);
var defineProperty = (__webpack_require__(5988).f);
var createNonEnumerableProperty = __webpack_require__(2029);
var hasOwn = __webpack_require__(953);
var toString = __webpack_require__(5623);
var wellKnownSymbol = __webpack_require__(9813);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC, SET_METHOD) {
  if (it) {
    var target = STATIC ? it : it.prototype;
    if (!hasOwn(target, TO_STRING_TAG)) {
      defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
    }
    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
      createNonEnumerableProperty(target, 'toString', toString);
    }
  }
};


/***/ }),

/***/ 4262:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(8726);
var uid = __webpack_require__(9418);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 3030:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);
var defineGlobalProperty = __webpack_require__(5609);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || defineGlobalProperty(SHARED, {});

module.exports = store;


/***/ }),

/***/ 8726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var IS_PURE = __webpack_require__(2529);
var store = __webpack_require__(3030);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.32.0',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2014-2023 Denis Pushkarev (zloirock.ru)',
  license: 'https://github.com/zloirock/core-js/blob/v3.32.0/LICENSE',
  source: 'https://github.com/zloirock/core-js'
});


/***/ }),

/***/ 4620:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);
var toIntegerOrInfinity = __webpack_require__(2435);
var toString = __webpack_require__(5803);
var requireObjectCoercible = __webpack_require__(8219);

var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var stringSlice = uncurryThis(''.slice);

var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = toString(requireObjectCoercible($this));
    var position = toIntegerOrInfinity(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = charCodeAt(S, position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = charCodeAt(S, position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING
          ? charAt(S, position)
          : first
        : CONVERT_TO_STRING
          ? stringSlice(S, position, position + 2)
          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 3405:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __webpack_require__(3385);
var fails = __webpack_require__(5981);
var global = __webpack_require__(1899);

var $String = global.String;

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,
  // of course, fail.
  return !$String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 9630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(8834);
var getBuiltIn = __webpack_require__(626);
var wellKnownSymbol = __webpack_require__(9813);
var defineBuiltIn = __webpack_require__(5929);

module.exports = function () {
  var Symbol = getBuiltIn('Symbol');
  var SymbolPrototype = Symbol && Symbol.prototype;
  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;
  var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {
    // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
    // eslint-disable-next-line no-unused-vars -- required for .length
    defineBuiltIn(SymbolPrototype, TO_PRIMITIVE, function (hint) {
      return call(valueOf, this);
    }, { arity: 1 });
  }
};


/***/ }),

/***/ 2087:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(626);
var uncurryThis = __webpack_require__(5329);

var Symbol = getBuiltIn('Symbol');
var keyFor = Symbol.keyFor;
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);

// `Symbol.isRegisteredSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
module.exports = Symbol.isRegisteredSymbol || function isRegisteredSymbol(value) {
  try {
    return keyFor(thisSymbolValue(value)) !== undefined;
  } catch (error) {
    return false;
  }
};


/***/ }),

/***/ 6559:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var shared = __webpack_require__(8726);
var getBuiltIn = __webpack_require__(626);
var uncurryThis = __webpack_require__(5329);
var isSymbol = __webpack_require__(6664);
var wellKnownSymbol = __webpack_require__(9813);

var Symbol = getBuiltIn('Symbol');
var $isWellKnownSymbol = Symbol.isWellKnownSymbol;
var getOwnPropertyNames = getBuiltIn('Object', 'getOwnPropertyNames');
var thisSymbolValue = uncurryThis(Symbol.prototype.valueOf);
var WellKnownSymbolsStore = shared('wks');

for (var i = 0, symbolKeys = getOwnPropertyNames(Symbol), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {
  // some old engines throws on access to some keys like `arguments` or `caller`
  try {
    var symbolKey = symbolKeys[i];
    if (isSymbol(Symbol[symbolKey])) wellKnownSymbol(symbolKey);
  } catch (error) { /* empty */ }
}

// `Symbol.isWellKnownSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
module.exports = function isWellKnownSymbol(value) {
  if ($isWellKnownSymbol && $isWellKnownSymbol(value)) return true;
  try {
    var symbol = thisSymbolValue(value);
    for (var j = 0, keys = getOwnPropertyNames(WellKnownSymbolsStore), keysLength = keys.length; j < keysLength; j++) {
      if (WellKnownSymbolsStore[keys[j]] == symbol) return true;
    }
  } catch (error) { /* empty */ }
  return false;
};


/***/ }),

/***/ 4680:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var NATIVE_SYMBOL = __webpack_require__(3405);

/* eslint-disable es/no-symbol -- safe */
module.exports = NATIVE_SYMBOL && !!Symbol['for'] && !!Symbol.keyFor;


/***/ }),

/***/ 9413:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(2435);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toIntegerOrInfinity(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 4529:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(7026);
var requireObjectCoercible = __webpack_require__(8219);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 2435:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var trunc = __webpack_require__(5331);

// `ToIntegerOrInfinity` abstract operation
// https://tc39.es/ecma262/#sec-tointegerorinfinity
module.exports = function (argument) {
  var number = +argument;
  // eslint-disable-next-line no-self-compare -- NaN check
  return number !== number || number === 0 ? 0 : trunc(number);
};


/***/ }),

/***/ 3057:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIntegerOrInfinity = __webpack_require__(2435);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 9678:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var requireObjectCoercible = __webpack_require__(8219);

var $Object = Object;

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return $Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 6935:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var call = __webpack_require__(8834);
var isObject = __webpack_require__(941);
var isSymbol = __webpack_require__(6664);
var getMethod = __webpack_require__(4229);
var ordinaryToPrimitive = __webpack_require__(9811);
var wellKnownSymbol = __webpack_require__(9813);

var $TypeError = TypeError;
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = call(exoticToPrim, input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw $TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 3894:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPrimitive = __webpack_require__(6935);
var isSymbol = __webpack_require__(6664);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : key + '';
};


/***/ }),

/***/ 2885:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(9813);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 5803:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var classof = __webpack_require__(9697);

var $String = String;

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return $String(argument);
};


/***/ }),

/***/ 9826:
/***/ ((module) => {

"use strict";

var $String = String;

module.exports = function (argument) {
  try {
    return $String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 9418:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var uncurryThis = __webpack_require__(5329);

var id = 0;
var postfix = Math.random();
var toString = uncurryThis(1.0.toString);

module.exports = function (key) {
  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);
};


/***/ }),

/***/ 2302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __webpack_require__(3405);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 3937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var DESCRIPTORS = __webpack_require__(5746);
var fails = __webpack_require__(5981);

// V8 ~ Chrome 36-
// https://bugs.chromium.org/p/v8/issues/detail?id=3334
module.exports = DESCRIPTORS && fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty(function () { /* empty */ }, 'prototype', {
    value: 42,
    writable: false
  }).prototype != 42;
});


/***/ }),

/***/ 7093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);
var isCallable = __webpack_require__(7475);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));


/***/ }),

/***/ 3464:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var path = __webpack_require__(4058);
var hasOwn = __webpack_require__(953);
var wrappedWellKnownSymbolModule = __webpack_require__(1477);
var defineProperty = (__webpack_require__(5988).f);

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!hasOwn(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ 1477:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(9813);

exports.f = wellKnownSymbol;


/***/ }),

/***/ 9813:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);
var shared = __webpack_require__(8726);
var hasOwn = __webpack_require__(953);
var uid = __webpack_require__(9418);
var NATIVE_SYMBOL = __webpack_require__(3405);
var USE_SYMBOL_AS_UID = __webpack_require__(2302);

var Symbol = global.Symbol;
var WellKnownSymbolsStore = shared('wks');
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!hasOwn(WellKnownSymbolsStore, name)) {
    WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name)
      ? Symbol[name]
      : createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 5906:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var fails = __webpack_require__(5981);
var isArray = __webpack_require__(1052);
var isObject = __webpack_require__(941);
var toObject = __webpack_require__(9678);
var lengthOfArrayLike = __webpack_require__(623);
var doesNotExceedSafeInteger = __webpack_require__(6796);
var createProperty = __webpack_require__(5449);
var arraySpeciesCreate = __webpack_require__(4692);
var arrayMethodHasSpeciesSupport = __webpack_require__(568);
var wellKnownSymbol = __webpack_require__(9813);
var V8_VERSION = __webpack_require__(3385);

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport('concat');

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, arity: 1, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = lengthOfArrayLike(E);
        doesNotExceedSafeInteger(n + len);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        doesNotExceedSafeInteger(n + 1);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ 6274:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toIndexedObject = __webpack_require__(4529);
var addToUnscopables = __webpack_require__(8479);
var Iterators = __webpack_require__(2077);
var InternalStateModule = __webpack_require__(5402);
var defineProperty = (__webpack_require__(5988).f);
var defineIterator = __webpack_require__(5105);
var createIterResultObject = __webpack_require__(3538);
var IS_PURE = __webpack_require__(2529);
var DESCRIPTORS = __webpack_require__(5746);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return createIterResultObject(undefined, true);
  }
  if (kind == 'keys') return createIterResultObject(index, false);
  if (kind == 'values') return createIterResultObject(target[index], false);
  return createIterResultObject([index, target[index]], false);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
var values = Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

// V8 ~ Chrome 45- bug
if (!IS_PURE && DESCRIPTORS && values.name !== 'values') try {
  defineProperty(values, 'name', { value: 'values' });
} catch (error) { /* empty */ }


/***/ }),

/***/ 8084:
/***/ (() => {

// empty


/***/ }),

/***/ 2619:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var getBuiltIn = __webpack_require__(626);
var apply = __webpack_require__(9730);
var call = __webpack_require__(8834);
var uncurryThis = __webpack_require__(5329);
var fails = __webpack_require__(5981);
var isCallable = __webpack_require__(7475);
var isSymbol = __webpack_require__(6664);
var arraySlice = __webpack_require__(3765);
var getReplacerFunction = __webpack_require__(3323);
var NATIVE_SYMBOL = __webpack_require__(3405);

var $String = String;
var $stringify = getBuiltIn('JSON', 'stringify');
var exec = uncurryThis(/./.exec);
var charAt = uncurryThis(''.charAt);
var charCodeAt = uncurryThis(''.charCodeAt);
var replace = uncurryThis(''.replace);
var numberToString = uncurryThis(1.0.toString);

var tester = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL || fails(function () {
  var symbol = getBuiltIn('Symbol')();
  // MS Edge converts symbol values to JSON as {}
  return $stringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || $stringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
});

// https://github.com/tc39/proposal-well-formed-stringify
var ILL_FORMED_UNICODE = fails(function () {
  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
    || $stringify('\uDEAD') !== '"\\udead"';
});

var stringifyWithSymbolsFix = function (it, replacer) {
  var args = arraySlice(arguments);
  var $replacer = getReplacerFunction(replacer);
  if (!isCallable($replacer) && (it === undefined || isSymbol(it))) return; // IE8 returns string on undefined
  args[1] = function (key, value) {
    // some old implementations (like WebKit) could pass numbers as keys
    if (isCallable($replacer)) value = call($replacer, this, $String(key), value);
    if (!isSymbol(value)) return value;
  };
  return apply($stringify, null, args);
};

var fixIllFormed = function (match, offset, string) {
  var prev = charAt(string, offset - 1);
  var next = charAt(string, offset + 1);
  if ((exec(low, match) && !exec(hi, next)) || (exec(hi, match) && !exec(low, prev))) {
    return '\\u' + numberToString(charCodeAt(match, 0), 16);
  } return match;
};

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  $({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = arraySlice(arguments);
      var result = apply(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);
      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace(result, tester, fixIllFormed) : result;
    }
  });
}


/***/ }),

/***/ 9120:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var global = __webpack_require__(1899);
var setToStringTag = __webpack_require__(904);

// JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ 5327:
/***/ (() => {

// empty


/***/ }),

/***/ 6450:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var DESCRIPTORS = __webpack_require__(5746);
var defineProperty = (__webpack_require__(5988).f);

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
// eslint-disable-next-line es/no-object-defineproperty -- safe
$({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty, sham: !DESCRIPTORS }, {
  defineProperty: defineProperty
});


/***/ }),

/***/ 7144:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var NATIVE_SYMBOL = __webpack_require__(3405);
var fails = __webpack_require__(5981);
var getOwnPropertySymbolsModule = __webpack_require__(7857);
var toObject = __webpack_require__(9678);

// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FORCED = !NATIVE_SYMBOL || fails(function () { getOwnPropertySymbolsModule.f(1); });

// `Object.getOwnPropertySymbols` method
// https://tc39.es/ecma262/#sec-object.getownpropertysymbols
$({ target: 'Object', stat: true, forced: FORCED }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    var $getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject(it)) : [];
  }
});


/***/ }),

/***/ 5967:
/***/ (() => {

// empty


/***/ }),

/***/ 1502:
/***/ (() => {

// empty


/***/ }),

/***/ 4261:
/***/ (() => {

// empty


/***/ }),

/***/ 7971:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var charAt = (__webpack_require__(4620).charAt);
var toString = __webpack_require__(5803);
var InternalStateModule = __webpack_require__(5402);
var defineIterator = __webpack_require__(5105);
var createIterResultObject = __webpack_require__(3538);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: toString(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return createIterResultObject(undefined, true);
  point = charAt(string, index);
  state.index += point.length;
  return createIterResultObject(point, false);
});


/***/ }),

/***/ 8555:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');


/***/ }),

/***/ 8616:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var global = __webpack_require__(1899);
var call = __webpack_require__(8834);
var uncurryThis = __webpack_require__(5329);
var IS_PURE = __webpack_require__(2529);
var DESCRIPTORS = __webpack_require__(5746);
var NATIVE_SYMBOL = __webpack_require__(3405);
var fails = __webpack_require__(5981);
var hasOwn = __webpack_require__(953);
var isPrototypeOf = __webpack_require__(7046);
var anObject = __webpack_require__(6059);
var toIndexedObject = __webpack_require__(4529);
var toPropertyKey = __webpack_require__(3894);
var $toString = __webpack_require__(5803);
var createPropertyDescriptor = __webpack_require__(1887);
var nativeObjectCreate = __webpack_require__(9290);
var objectKeys = __webpack_require__(4771);
var getOwnPropertyNamesModule = __webpack_require__(946);
var getOwnPropertyNamesExternal = __webpack_require__(684);
var getOwnPropertySymbolsModule = __webpack_require__(7857);
var getOwnPropertyDescriptorModule = __webpack_require__(9677);
var definePropertyModule = __webpack_require__(5988);
var definePropertiesModule = __webpack_require__(9938);
var propertyIsEnumerableModule = __webpack_require__(6760);
var defineBuiltIn = __webpack_require__(5929);
var defineBuiltInAccessor = __webpack_require__(9202);
var shared = __webpack_require__(8726);
var sharedKey = __webpack_require__(4262);
var hiddenKeys = __webpack_require__(7748);
var uid = __webpack_require__(9418);
var wellKnownSymbol = __webpack_require__(9813);
var wrappedWellKnownSymbolModule = __webpack_require__(1477);
var defineWellKnownSymbol = __webpack_require__(3464);
var defineSymbolToPrimitive = __webpack_require__(9630);
var setToStringTag = __webpack_require__(904);
var InternalStateModule = __webpack_require__(5402);
var $forEach = (__webpack_require__(3610).forEach);

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';

var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);

var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];
var TypeError = global.TypeError;
var QObject = global.QObject;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var push = uncurryThis([].push);

var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var WellKnownSymbolsStore = shared('wks');

// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPropertyKey(P);
  anObject(Attributes);
  if (hasOwn(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!hasOwn(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (hasOwn(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || call($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPropertyKey(V);
  var enumerable = call(nativePropertyIsEnumerable, this, P);
  if (this === ObjectPrototype && hasOwn(AllSymbols, P) && !hasOwn(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !hasOwn(this, P) || !hasOwn(AllSymbols, P) || hasOwn(this, HIDDEN) && this[HIDDEN][P]
    ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPropertyKey(P);
  if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key)) push(result, key);
  });
  return result;
};

var $getOwnPropertySymbols = function (O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
      push(result, AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (isPrototypeOf(SymbolPrototype, this)) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) call(setter, ObjectPrototypeSymbols, value);
      if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  SymbolPrototype = $Symbol[PROTOTYPE];

  defineBuiltIn(SymbolPrototype, 'toString', function toString() {
    return getInternalState(this).tag;
  });

  defineBuiltIn($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  definePropertiesModule.f = $defineProperties;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    defineBuiltInAccessor(SymbolPrototype, 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      defineBuiltIn(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ 2615:
/***/ (() => {

// empty


/***/ }),

/***/ 4523:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var getBuiltIn = __webpack_require__(626);
var hasOwn = __webpack_require__(953);
var toString = __webpack_require__(5803);
var shared = __webpack_require__(8726);
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(4680);

var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.for` method
// https://tc39.es/ecma262/#sec-symbol.for
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  'for': function (key) {
    var string = toString(key);
    if (hasOwn(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = getBuiltIn('Symbol')(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  }
});


/***/ }),

/***/ 1732:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');


/***/ }),

/***/ 5903:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');


/***/ }),

/***/ 1825:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ 5824:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove this module from `core-js@4` since it's split to modules listed below
__webpack_require__(8616);
__webpack_require__(4523);
__webpack_require__(8608);
__webpack_require__(2619);
__webpack_require__(7144);


/***/ }),

/***/ 8608:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var hasOwn = __webpack_require__(953);
var isSymbol = __webpack_require__(6664);
var tryToString = __webpack_require__(9826);
var shared = __webpack_require__(8726);
var NATIVE_SYMBOL_REGISTRY = __webpack_require__(4680);

var SymbolToStringRegistry = shared('symbol-to-string-registry');

// `Symbol.keyFor` method
// https://tc39.es/ecma262/#sec-symbol.keyfor
$({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(tryToString(sym) + ' is not a symbol');
    if (hasOwn(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  }
});


/***/ }),

/***/ 5915:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall
defineWellKnownSymbol('matchAll');


/***/ }),

/***/ 8394:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');


/***/ }),

/***/ 1766:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');


/***/ }),

/***/ 2737:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');


/***/ }),

/***/ 9911:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');


/***/ }),

/***/ 4315:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');


/***/ }),

/***/ 3131:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);
var defineSymbolToPrimitive = __webpack_require__(9630);

// `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
defineSymbolToPrimitive();


/***/ }),

/***/ 4714:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getBuiltIn = __webpack_require__(626);
var defineWellKnownSymbol = __webpack_require__(3464);
var setToStringTag = __webpack_require__(904);

// `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');

// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag(getBuiltIn('Symbol'), 'Symbol');


/***/ }),

/***/ 659:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');


/***/ }),

/***/ 7522:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var wellKnownSymbol = __webpack_require__(9813);
var defineProperty = (__webpack_require__(5988).f);

var METADATA = wellKnownSymbol('metadata');
var FunctionPrototype = Function.prototype;

// Function.prototype[@@metadata]
// https://github.com/tc39/proposal-decorator-metadata
if (FunctionPrototype[METADATA] === undefined) {
  defineProperty(FunctionPrototype, METADATA, {
    value: null
  });
}


/***/ }),

/***/ 8783:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.asyncDispose` well-known symbol
// https://github.com/tc39/proposal-async-explicit-resource-management
defineWellKnownSymbol('asyncDispose');


/***/ }),

/***/ 3975:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.dispose` well-known symbol
// https://github.com/tc39/proposal-explicit-resource-management
defineWellKnownSymbol('dispose');


/***/ }),

/***/ 7618:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var isRegisteredSymbol = __webpack_require__(2087);

// `Symbol.isRegisteredSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
$({ target: 'Symbol', stat: true }, {
  isRegisteredSymbol: isRegisteredSymbol
});


/***/ }),

/***/ 2731:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var isRegisteredSymbol = __webpack_require__(2087);

// `Symbol.isRegistered` method
// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol
$({ target: 'Symbol', stat: true, name: 'isRegisteredSymbol' }, {
  isRegistered: isRegisteredSymbol
});


/***/ }),

/***/ 6989:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var isWellKnownSymbol = __webpack_require__(6559);

// `Symbol.isWellKnownSymbol` method
// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
$({ target: 'Symbol', stat: true, forced: true }, {
  isWellKnownSymbol: isWellKnownSymbol
});


/***/ }),

/***/ 5605:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var $ = __webpack_require__(6887);
var isWellKnownSymbol = __webpack_require__(6559);

// `Symbol.isWellKnown` method
// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol
// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected
$({ target: 'Symbol', stat: true, name: 'isWellKnownSymbol', forced: true }, {
  isWellKnown: isWellKnownSymbol
});


/***/ }),

/***/ 5799:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.matcher` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('matcher');


/***/ }),

/***/ 1943:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.metadataKey` well-known symbol
// https://github.com/tc39/proposal-decorator-metadata
defineWellKnownSymbol('metadataKey');


/***/ }),

/***/ 5414:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: Remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.metadata` well-known symbol
// https://github.com/tc39/proposal-decorators
defineWellKnownSymbol('metadata');


/***/ }),

/***/ 6774:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.observable` well-known symbol
// https://github.com/tc39/proposal-observable
defineWellKnownSymbol('observable');


/***/ }),

/***/ 620:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(3464);

// `Symbol.patternMatch` well-known symbol
// https://github.com/tc39/proposal-pattern-matching
defineWellKnownSymbol('patternMatch');


/***/ }),

/***/ 6172:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// TODO: remove from `core-js@4`
var defineWellKnownSymbol = __webpack_require__(3464);

defineWellKnownSymbol('replaceAll');


/***/ }),

/***/ 7634:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

__webpack_require__(6274);
var DOMIterables = __webpack_require__(3281);
var global = __webpack_require__(1899);
var classof = __webpack_require__(9697);
var createNonEnumerableProperty = __webpack_require__(2029);
var Iterators = __webpack_require__(2077);
var wellKnownSymbol = __webpack_require__(9813);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
  }
  Iterators[COLLECTION_NAME] = Iterators.Array;
}


/***/ }),

/***/ 8842:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(6793);

module.exports = parent;


/***/ }),

/***/ 1910:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(8171);

module.exports = parent;


/***/ }),

/***/ 2547:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(7473);
__webpack_require__(7634);

module.exports = parent;


/***/ }),

/***/ 6509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(4227);
__webpack_require__(7634);

module.exports = parent;


/***/ }),

/***/ 5774:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var parent = __webpack_require__(2978);

module.exports = parent;


/***/ }),

/***/ 4378:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(3837);
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(5717);
}


/***/ }),

/***/ 5717:
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ 9509:
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(9408)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ 4189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Buffer = (__webpack_require__(9509).Buffer)

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash


/***/ }),

/***/ 7499:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = __webpack_require__(4378)
var Hash = __webpack_require__(4189)
var Buffer = (__webpack_require__(9509).Buffer)

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256


/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 7946:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__7946__;

/***/ }),

/***/ 7417:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__7417__;

/***/ }),

/***/ 3983:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3983__;

/***/ }),

/***/ 4711:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__4711__;

/***/ }),

/***/ 5039:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__5039__;

/***/ }),

/***/ 8236:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__8236__;

/***/ }),

/***/ 5192:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__5192__;

/***/ }),

/***/ 1986:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__1986__;

/***/ }),

/***/ 3783:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3783__;

/***/ }),

/***/ 9408:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__9408__;

/***/ }),

/***/ 6667:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__6667__;

/***/ }),

/***/ 3735:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3735__;

/***/ }),

/***/ 3153:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3153__;

/***/ }),

/***/ 2716:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__2716__;

/***/ }),

/***/ 3485:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__3485__;

/***/ }),

/***/ 79:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__79__;

/***/ }),

/***/ 9882:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__9882__;

/***/ }),

/***/ 7480:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__7480__;

/***/ }),

/***/ 8079:
/***/ ((module) => {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__8079__;

/***/ }),

/***/ 3959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(8842);

/***/ }),

/***/ 9689:
/***/ ((module) => {

function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}
module.exports = _classApplyDescriptorGet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 6906:
/***/ ((module) => {

function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}
module.exports = _classApplyDescriptorSet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 6412:
/***/ ((module) => {

function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}
module.exports = _classExtractFieldDescriptor, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 7667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classApplyDescriptorGet = __webpack_require__(9689);
var classExtractFieldDescriptor = __webpack_require__(6412);
function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
  return classApplyDescriptorGet(receiver, descriptor);
}
module.exports = _classPrivateFieldGet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classApplyDescriptorSet = __webpack_require__(6906);
var classExtractFieldDescriptor = __webpack_require__(6412);
function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
  classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}
module.exports = _classPrivateFieldSet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 1125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Object$defineProperty = __webpack_require__(3685);
var toPropertyKey = __webpack_require__(7696);
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    _Object$defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 8504:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol$toPrimitive = __webpack_require__(1384);
var _typeof = (__webpack_require__(474)["default"]);
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[_Symbol$toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 7696:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(474)["default"]);
var toPrimitive = __webpack_require__(8504);
function _toPropertyKey(arg) {
  var key = toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),

/***/ 474:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _Symbol = __webpack_require__(6600);
var _Symbol$iterator = __webpack_require__(9759);
function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof _Symbol && "symbol" == typeof _Symbol$iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof _Symbol && obj.constructor === _Symbol && obj !== _Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  AE_AMOUNT_FORMATS: () => (/* reexport */ AE_AMOUNT_FORMATS),
  AbiVersion: () => (/* reexport */ AbiVersion),
  AccountBase: () => (/* reexport */ AccountBase),
  AccountError: () => (/* reexport */ AccountError),
  AccountGeneralized: () => (/* reexport */ AccountGeneralized),
  AccountLedger: () => (/* reexport */ AccountLedger),
  AccountLedgerFactory: () => (/* reexport */ AccountLedgerFactory),
  AeSdk: () => (/* reexport */ AeSdk),
  AeSdkAepp: () => (/* reexport */ AeSdkAepp),
  AeSdkBase: () => (/* reexport */ AeSdkBase),
  AeSdkMethods: () => (/* reexport */ src_AeSdkMethods),
  AeSdkWallet: () => (/* reexport */ AeSdkWallet),
  AensError: () => (/* reexport */ AensError),
  AensPointerContextError: () => (/* reexport */ AensPointerContextError),
  AeppError: () => (/* reexport */ AeppError),
  AlreadyConnectedError: () => (/* reexport */ AlreadyConnectedError),
  AmbiguousEventDefinitionError: () => (/* reexport */ AmbiguousEventDefinitionError),
  ArgumentCountMismatchError: () => (/* reexport */ ArgumentCountMismatchError),
  ArgumentError: () => (/* reexport */ ArgumentError),
  BaseError: () => (/* reexport */ BaseError),
  BrowserRuntimeConnection: () => (/* reexport */ BrowserRuntimeConnection),
  BrowserWindowMessageConnection: () => (/* reexport */ BrowserWindowMessageConnection),
  BytecodeMismatchError: () => (/* reexport */ BytecodeMismatchError),
  CLIENT_TTL: () => (/* reexport */ CLIENT_TTL),
  CallReturnType: () => (/* reexport */ CallReturnType),
  Channel: () => (/* reexport */ ChannelContract),
  ChannelCallError: () => (/* reexport */ ChannelCallError),
  ChannelConnectionError: () => (/* reexport */ ChannelConnectionError),
  ChannelError: () => (/* reexport */ ChannelError),
  ChannelIncomingMessageError: () => (/* reexport */ ChannelIncomingMessageError),
  ChannelPingTimedOutError: () => (/* reexport */ ChannelPingTimedOutError),
  CompilerBase: () => (/* reexport */ CompilerBase),
  CompilerCli: () => (/* reexport */ CompilerCli),
  CompilerError: () => (/* reexport */ CompilerError),
  CompilerHttp: () => (/* reexport */ CompilerHttp),
  CompilerHttpNode: () => (/* reexport */ CompilerHttpNode),
  ConsensusProtocolVersion: () => (/* reexport */ ConsensusProtocolVersion),
  Contract: () => (/* reexport */ contract_Contract),
  ContractError: () => (/* reexport */ ContractError),
  CryptographyError: () => (/* reexport */ CryptographyError),
  DRY_RUN_ACCOUNT: () => (/* reexport */ DRY_RUN_ACCOUNT),
  DecodeError: () => (/* reexport */ DecodeError),
  DerivationError: () => (/* reexport */ DerivationError),
  DryRunError: () => (/* reexport */ DryRunError),
  DuplicateContractError: () => (/* reexport */ DuplicateContractError),
  DuplicateNodeError: () => (/* reexport */ DuplicateNodeError),
  Encoded: () => (/* reexport */ encoder_types_namespaceObject),
  Encoding: () => (/* reexport */ Encoding),
  IllegalArgumentError: () => (/* reexport */ IllegalArgumentError),
  IllegalBidFeeError: () => (/* reexport */ IllegalBidFeeError),
  InactiveContractError: () => (/* reexport */ InactiveContractError),
  InsufficientBalanceError: () => (/* reexport */ InsufficientBalanceError),
  InsufficientNameFeeError: () => (/* reexport */ InsufficientNameFeeError),
  InternalError: () => (/* reexport */ InternalError),
  InvalidAensNameError: () => (/* reexport */ InvalidAensNameError),
  InvalidAuthDataError: () => (/* reexport */ InvalidAuthDataError),
  InvalidChecksumError: () => (/* reexport */ InvalidChecksumError),
  InvalidMethodInvocationError: () => (/* reexport */ InvalidMethodInvocationError),
  InvalidPasswordError: () => (/* reexport */ InvalidPasswordError),
  InvalidRpcMessageError: () => (/* reexport */ InvalidRpcMessageError),
  InvalidSignatureError: () => (/* reexport */ InvalidSignatureError),
  InvalidTxError: () => (/* reexport */ InvalidTxError),
  MAX_AUTH_FUN_GAS: () => (/* reexport */ MAX_AUTH_FUN_GAS),
  MESSAGE_DIRECTION: () => (/* reexport */ MESSAGE_DIRECTION),
  METHODS: () => (/* reexport */ METHODS),
  MIN_GAS_PRICE: () => (/* reexport */ MIN_GAS_PRICE),
  MemoryAccount: () => (/* reexport */ AccountMemory),
  MerkleTreeHashMismatchError: () => (/* reexport */ MerkleTreeHashMismatchError),
  MissingCallbackError: () => (/* reexport */ MissingCallbackError),
  MissingContractAddressError: () => (/* reexport */ MissingContractAddressError),
  MissingContractDefError: () => (/* reexport */ MissingContractDefError),
  MissingEventDefinitionError: () => (/* reexport */ MissingEventDefinitionError),
  MissingFunctionNameError: () => (/* reexport */ MissingFunctionNameError),
  MissingNodeInTreeError: () => (/* reexport */ MissingNodeInTreeError),
  MissingParamError: () => (/* reexport */ MissingParamError),
  NAME_BID_MAX_LENGTH: () => (/* reexport */ NAME_BID_MAX_LENGTH),
  NAME_BID_RANGES: () => (/* reexport */ NAME_BID_RANGES),
  NAME_BID_TIMEOUT_BLOCKS: () => (/* reexport */ NAME_BID_TIMEOUT_BLOCKS),
  NAME_FEE_BID_INCREMENT: () => (/* reexport */ NAME_FEE_BID_INCREMENT),
  NAME_FEE_MULTIPLIER: () => (/* reexport */ NAME_FEE_MULTIPLIER),
  NAME_MAX_CLIENT_TTL: () => (/* reexport */ NAME_MAX_CLIENT_TTL),
  NAME_MAX_LENGTH_FEE: () => (/* reexport */ NAME_MAX_LENGTH_FEE),
  NAME_MAX_TTL: () => (/* reexport */ NAME_MAX_TTL),
  NAME_TTL: () => (/* reexport */ NAME_TTL),
  NoSerializerFoundError: () => (/* reexport */ NoSerializerFoundError),
  NoSuchContractFunctionError: () => (/* reexport */ NoSuchContractFunctionError),
  NoWalletConnectedError: () => (/* reexport */ NoWalletConnectedError),
  Node: () => (/* reexport */ Node_Node),
  NodeError: () => (/* reexport */ NodeError),
  NodeInvocationError: () => (/* reexport */ NodeInvocationError),
  NodeNotFoundError: () => (/* reexport */ NodeNotFoundError),
  NotImplementedError: () => (/* reexport */ NotImplementedError),
  NotPayableFunctionError: () => (/* reexport */ NotPayableFunctionError),
  ORACLE_TTL: () => (/* reexport */ ORACLE_TTL),
  ORACLE_TTL_TYPES: () => (/* reexport */ ORACLE_TTL_TYPES),
  PayloadLengthError: () => (/* reexport */ PayloadLengthError),
  PrefixNotFoundError: () => (/* reexport */ PrefixNotFoundError),
  QUERY_TTL: () => (/* reexport */ QUERY_TTL),
  RESPONSE_TTL: () => (/* reexport */ RESPONSE_TTL),
  RPC_STATUS: () => (/* reexport */ RPC_STATUS),
  RequestTimedOutError: () => (/* reexport */ RequestTimedOutError),
  RpcBroadcastError: () => (/* reexport */ RpcBroadcastError),
  RpcConnectionDenyError: () => (/* reexport */ RpcConnectionDenyError),
  RpcConnectionError: () => (/* reexport */ RpcConnectionError),
  RpcError: () => (/* reexport */ RpcError),
  RpcInternalError: () => (/* reexport */ RpcInternalError),
  RpcInvalidTransactionError: () => (/* reexport */ RpcInvalidTransactionError),
  RpcMethodNotFoundError: () => (/* reexport */ RpcMethodNotFoundError),
  RpcNotAuthorizeError: () => (/* reexport */ RpcNotAuthorizeError),
  RpcPermissionDenyError: () => (/* reexport */ RpcPermissionDenyError),
  RpcRejectedByUserError: () => (/* reexport */ RpcRejectedByUserError),
  RpcUnsupportedProtocolError: () => (/* reexport */ RpcUnsupportedProtocolError),
  SUBSCRIPTION_TYPES: () => (/* reexport */ SUBSCRIPTION_TYPES),
  SchemaNotFoundError: () => (/* reexport */ SchemaNotFoundError),
  Tag: () => (/* reexport */ Tag),
  TagNotFoundError: () => (/* reexport */ TagNotFoundError),
  TransactionError: () => (/* reexport */ TransactionError),
  TxNotInChainError: () => (/* reexport */ TxNotInChainError),
  TxTimedOutError: () => (/* reexport */ TxTimedOutError),
  TypeError: () => (/* reexport */ errors_TypeError),
  UnAuthorizedAccountError: () => (/* reexport */ UnAuthorizedAccountError),
  UnavailableAccountError: () => (/* reexport */ UnavailableAccountError),
  UnexpectedChannelMessageError: () => (/* reexport */ UnexpectedChannelMessageError),
  UnexpectedTsError: () => (/* reexport */ UnexpectedTsError),
  UnknownChannelStateError: () => (/* reexport */ UnknownChannelStateError),
  UnknownNodeLengthError: () => (/* reexport */ UnknownNodeLengthError),
  UnknownPathNibbleError: () => (/* reexport */ UnknownPathNibbleError),
  UnknownRpcClientError: () => (/* reexport */ UnknownRpcClientError),
  UnsubscribedAccountError: () => (/* reexport */ UnsubscribedAccountError),
  UnsupportedPlatformError: () => (/* reexport */ UnsupportedPlatformError),
  UnsupportedProtocolError: () => (/* reexport */ UnsupportedProtocolError),
  UnsupportedVersionError: () => (/* reexport */ UnsupportedVersionError),
  VmVersion: () => (/* reexport */ VmVersion),
  WALLET_TYPE: () => (/* reexport */ WALLET_TYPE),
  WalletError: () => (/* reexport */ WalletError),
  _Middleware: () => (/* reexport */ Middleware_Middleware),
  _MiddlewareSubscriber: () => (/* reexport */ MiddlewareSubscriber),
  _MiddlewareSubscriberDisconnected: () => (/* reexport */ MiddlewareSubscriberDisconnected),
  _MiddlewareSubscriberError: () => (/* reexport */ MiddlewareSubscriberError),
  _getPollInterval: () => (/* reexport */ _getPollInterval),
  aensBid: () => (/* reexport */ aensBid),
  aensClaim: () => (/* reexport */ aensClaim),
  aensPreclaim: () => (/* reexport */ aensPreclaim),
  aensQuery: () => (/* reexport */ aensQuery),
  aensRevoke: () => (/* reexport */ aensRevoke),
  aensTransfer: () => (/* reexport */ aensTransfer),
  aensUpdate: () => (/* reexport */ aensUpdate),
  awaitHeight: () => (/* reexport */ awaitHeight),
  buildAuthTxHash: () => (/* reexport */ buildAuthTxHash),
  buildAuthTxHashByGaMetaTx: () => (/* reexport */ buildAuthTxHashByGaMetaTx),
  buildContractId: () => (/* reexport */ buildContractId),
  buildContractIdByContractTx: () => (/* reexport */ buildContractIdByContractTx),
  buildTx: () => (/* reexport */ buildTx),
  buildTxAsync: () => (/* reexport */ buildTxAsync),
  buildTxHash: () => (/* reexport */ buildTxHash),
  commitmentHash: () => (/* reexport */ commitmentHash),
  computeAuctionEndBlock: () => (/* reexport */ computeAuctionEndBlock),
  computeBidFee: () => (/* reexport */ computeBidFee),
  connectionProxy: () => (/* reexport */ connection_proxy),
  createGeneralizedAccount: () => (/* reexport */ createGeneralizedAccount),
  decode: () => (/* reexport */ decode),
  decodeFateValue: () => (/* reexport */ decodeFateValue),
  deriveChild: () => (/* reexport */ deriveChild),
  derivePathFromKey: () => (/* reexport */ derivePathFromKey),
  derivePathFromSeed: () => (/* reexport */ derivePathFromSeed),
  dump: () => (/* reexport */ dump),
  encode: () => (/* reexport */ encode),
  encodeContractAddress: () => (/* reexport */ encodeContractAddress),
  encodeFateValue: () => (/* reexport */ encodeFateValue),
  encodeUnsigned: () => (/* reexport */ encodeUnsigned),
  ensureName: () => (/* reexport */ ensureName),
  extendOracleTtl: () => (/* reexport */ extendOracleTtl),
  formatAmount: () => (/* reexport */ formatAmount),
  genSalt: () => (/* reexport */ genSalt),
  generateKeyPair: () => (/* reexport */ generateKeyPair),
  generateKeyPairFromSecret: () => (/* reexport */ generateKeyPairFromSecret),
  generateSaveHDWalletFromSeed: () => (/* reexport */ generateSaveHDWalletFromSeed),
  getAccount: () => (/* reexport */ getAccount),
  getAddressFromPriv: () => (/* reexport */ getAddressFromPriv),
  getBalance: () => (/* reexport */ getBalance),
  getContract: () => (/* reexport */ getContract),
  getContractByteCode: () => (/* reexport */ getContractByteCode),
  getCurrentGeneration: () => (/* reexport */ getCurrentGeneration),
  getDefaultPointerKey: () => (/* reexport */ getDefaultPointerKey),
  getExecutionCost: () => (/* reexport */ getExecutionCost),
  getExecutionCostBySignedTx: () => (/* reexport */ getExecutionCostBySignedTx),
  getExecutionCostUsingNode: () => (/* reexport */ getExecutionCostUsingNode),
  getFileSystem: () => (/* reexport */ getFileSystem),
  getGeneration: () => (/* reexport */ getGeneration),
  getHdWalletAccountFromSeed: () => (/* reexport */ getHdWalletAccountFromSeed),
  getHeight: () => (/* reexport */ getHeight),
  getKeyBlock: () => (/* reexport */ getKeyBlock),
  getKeyPair: () => (/* reexport */ getKeyPair),
  getMasterKeyFromSeed: () => (/* reexport */ getMasterKeyFromSeed),
  getMicroBlockHeader: () => (/* reexport */ getMicroBlockHeader),
  getMicroBlockTransactions: () => (/* reexport */ getMicroBlockTransactions),
  getMinimumNameFee: () => (/* reexport */ getMinimumNameFee),
  getName: () => (/* reexport */ getName),
  getOracleObject: () => (/* reexport */ getOracleObject),
  getQueryObject: () => (/* reexport */ getQueryObject),
  getSaveHDWalletAccounts: () => (/* reexport */ getSaveHDWalletAccounts),
  getTransactionSignerAddress: () => (/* reexport */ getTransactionSignerAddress),
  hash: () => (/* reexport */ hash),
  hashDomain: () => (/* reexport */ hashDomain),
  hashJson: () => (/* reexport */ hashJson),
  hashTypedData: () => (/* reexport */ hashTypedData),
  isAddressValid: () => (/* reexport */ isAddressValid),
  isAuctionName: () => (/* reexport */ isAuctionName),
  isNameValid: () => (/* reexport */ isNameValid),
  isValidKeypair: () => (/* reexport */ isValidKeypair),
  messageToHash: () => (/* reexport */ messageToHash),
  oracleQueryId: () => (/* reexport */ oracleQueryId),
  payForTransaction: () => (/* reexport */ payForTransaction),
  poll: () => (/* reexport */ poll),
  pollForQueries: () => (/* reexport */ pollForQueries),
  pollForQueryResponse: () => (/* reexport */ pollForQueryResponse),
  postQueryToOracle: () => (/* reexport */ postQueryToOracle),
  prefixedAmount: () => (/* reexport */ prefixedAmount),
  produceNameId: () => (/* reexport */ produceNameId),
  readInt: () => (/* reexport */ readInt),
  recover: () => (/* reexport */ recover),
  registerOracle: () => (/* reexport */ registerOracle),
  resolveName: () => (/* reexport */ resolveName),
  respondToQuery: () => (/* reexport */ respondToQuery),
  sendTransaction: () => (/* reexport */ sendTransaction),
  sign: () => (/* reexport */ sign),
  signMessage: () => (/* reexport */ signMessage),
  spend: () => (/* reexport */ spend),
  toAe: () => (/* reexport */ toAe),
  toAettos: () => (/* reexport */ toAettos),
  toBytes: () => (/* reexport */ toBytes),
  transferFunds: () => (/* reexport */ transferFunds),
  txDryRun: () => (/* reexport */ txDryRun),
  unpackTx: () => (/* reexport */ unpackTx),
  verify: () => (/* reexport */ verify),
  verifyMessage: () => (/* reexport */ verifyMessage),
  verifyTransaction: () => (/* reexport */ verifyTransaction),
  waitForTxConfirm: () => (/* reexport */ waitForTxConfirm),
  walletDetector: () => (/* reexport */ wallet_detector)
});

// NAMESPACE OBJECT: ./src/utils/encoder-types.ts
var encoder_types_namespaceObject = {};
__webpack_require__.r(encoder_types_namespaceObject);
__webpack_require__.d(encoder_types_namespaceObject, {
  Encoding: () => (Encoding)
});

// NAMESPACE OBJECT: ./src/apis/node/models/mappers.ts
var mappers_namespaceObject = {};
__webpack_require__.r(mappers_namespaceObject);
__webpack_require__.d(mappers_namespaceObject, {
  Account: () => (Account),
  ByteCode: () => (ByteCode),
  Channel: () => (Channel),
  ChannelCloseMutualTx: () => (ChannelCloseMutualTx),
  ChannelCloseSoloTx: () => (ChannelCloseSoloTx),
  ChannelCreateTx: () => (ChannelCreateTx),
  ChannelDepositTx: () => (ChannelDepositTx),
  ChannelForceProgressTx: () => (ChannelForceProgressTx),
  ChannelSetDelegatesTx: () => (ChannelSetDelegatesTx),
  ChannelSettleTx: () => (ChannelSettleTx),
  ChannelSlashTx: () => (ChannelSlashTx),
  ChannelSnapshotSoloTx: () => (ChannelSnapshotSoloTx),
  ChannelWithdrawTx: () => (ChannelWithdrawTx),
  CheckTxInPoolResponse: () => (CheckTxInPoolResponse),
  CommitmentId: () => (CommitmentId),
  ContractCallObject: () => (ContractCallObject),
  ContractCallTx: () => (ContractCallTx),
  ContractCreateTx: () => (ContractCreateTx),
  ContractObject: () => (ContractObject),
  CountResponse: () => (CountResponse),
  CreateContractUnsignedTx: () => (CreateContractUnsignedTx),
  Delegates: () => (Delegates),
  DryRunAccount: () => (DryRunAccount),
  DryRunCallContext: () => (DryRunCallContext),
  DryRunCallReq: () => (DryRunCallReq),
  DryRunInput: () => (DryRunInput),
  DryRunInputItem: () => (DryRunInputItem),
  DryRunResult: () => (DryRunResult),
  DryRunResults: () => (DryRunResults),
  EncodedTx: () => (EncodedTx),
  ErrorModel: () => (ErrorModel),
  Event: () => (Event),
  GAAttachTx: () => (GAAttachTx),
  GAMetaTx: () => (GAMetaTx),
  GAObject: () => (GAObject),
  Generation: () => (Generation),
  HashResponse: () => (HashResponse),
  Header: () => (Header),
  HeightResponse: () => (HeightResponse),
  KeyBlock: () => (KeyBlock),
  MicroBlockHeader: () => (MicroBlockHeader),
  NameClaimTx: () => (NameClaimTx),
  NameEntry: () => (NameEntry),
  NameHash: () => (NameHash),
  NamePointer: () => (NamePointer),
  NamePreclaimTx: () => (NamePreclaimTx),
  NameRevokeTx: () => (NameRevokeTx),
  NameTransferTx: () => (NameTransferTx),
  NameUpdateTx: () => (NameUpdateTx),
  NextNonceResponse: () => (NextNonceResponse),
  OffChainCallContract: () => (OffChainCallContract),
  OffChainDeposit: () => (OffChainDeposit),
  OffChainNewContract: () => (OffChainNewContract),
  OffChainTransfer: () => (OffChainTransfer),
  OffChainUpdate: () => (OffChainUpdate),
  OffChainWithdrawal: () => (OffChainWithdrawal),
  OracleExtendTx: () => (OracleExtendTx),
  OracleQueries: () => (OracleQueries),
  OracleQuery: () => (OracleQuery),
  OracleQueryTx: () => (OracleQueryTx),
  OracleRegisterTx: () => (OracleRegisterTx),
  OracleRespondTx: () => (OracleRespondTx),
  PayingForTx: () => (PayingForTx),
  PeerConnections: () => (PeerConnections),
  PeerCount: () => (PeerCount),
  PeerCountAvailable: () => (PeerCountAvailable),
  PeerCountConnected: () => (PeerCountConnected),
  PeerDetails: () => (PeerDetails),
  PeerPubKey: () => (PeerPubKey),
  Peers: () => (Peers),
  PoI: () => (PoI),
  PostTxResponse: () => (PostTxResponse),
  Protocol: () => (Protocol),
  PubKey: () => (PubKey),
  RegisteredOracle: () => (RegisteredOracle),
  RelativeTTL: () => (RelativeTTL),
  SignedTx: () => (SignedTx),
  SignedTxs: () => (SignedTxs),
  SpendTx: () => (SpendTx),
  Status: () => (Status),
  TokenSupply: () => (TokenSupply),
  Ttl: () => (Ttl),
  Tx: () => (Tx),
  TxInfoObject: () => (TxInfoObject),
  UnsignedTx: () => (UnsignedTx),
  discriminators: () => (discriminators)
});

// NAMESPACE OBJECT: ./src/chain.ts
var chain_namespaceObject = {};
__webpack_require__.r(chain_namespaceObject);
__webpack_require__.d(chain_namespaceObject, {
  InvalidTxError: () => (InvalidTxError),
  _getPollInterval: () => (_getPollInterval),
  awaitHeight: () => (awaitHeight),
  getAccount: () => (getAccount),
  getBalance: () => (getBalance),
  getContract: () => (getContract),
  getContractByteCode: () => (getContractByteCode),
  getCurrentGeneration: () => (getCurrentGeneration),
  getGeneration: () => (getGeneration),
  getHeight: () => (getHeight),
  getKeyBlock: () => (getKeyBlock),
  getMicroBlockHeader: () => (getMicroBlockHeader),
  getMicroBlockTransactions: () => (getMicroBlockTransactions),
  getName: () => (getName),
  poll: () => (poll),
  resolveName: () => (resolveName),
  sendTransaction: () => (sendTransaction),
  txDryRun: () => (txDryRun),
  waitForTxConfirm: () => (waitForTxConfirm)
});

// NAMESPACE OBJECT: ./src/aens.ts
var aens_namespaceObject = {};
__webpack_require__.r(aens_namespaceObject);
__webpack_require__.d(aens_namespaceObject, {
  aensBid: () => (aensBid),
  aensClaim: () => (aensClaim),
  aensPreclaim: () => (aensPreclaim),
  aensQuery: () => (aensQuery),
  aensRevoke: () => (aensRevoke),
  aensTransfer: () => (aensTransfer),
  aensUpdate: () => (aensUpdate)
});

// NAMESPACE OBJECT: ./src/oracle.ts
var oracle_namespaceObject = {};
__webpack_require__.r(oracle_namespaceObject);
__webpack_require__.d(oracle_namespaceObject, {
  extendOracleTtl: () => (extendOracleTtl),
  getOracleObject: () => (getOracleObject),
  getQueryObject: () => (getQueryObject),
  pollForQueries: () => (pollForQueries),
  pollForQueryResponse: () => (pollForQueryResponse),
  postQueryToOracle: () => (postQueryToOracle),
  registerOracle: () => (registerOracle),
  respondToQuery: () => (respondToQuery)
});

// NAMESPACE OBJECT: ./src/spend.ts
var spend_namespaceObject = {};
__webpack_require__.r(spend_namespaceObject);
__webpack_require__.d(spend_namespaceObject, {
  payForTransaction: () => (payForTransaction),
  spend: () => (spend),
  transferFunds: () => (transferFunds)
});

// NAMESPACE OBJECT: ./src/contract/ga.ts
var ga_namespaceObject = {};
__webpack_require__.r(ga_namespaceObject);
__webpack_require__.d(ga_namespaceObject, {
  buildAuthTxHash: () => (buildAuthTxHash),
  buildAuthTxHashByGaMetaTx: () => (buildAuthTxHashByGaMetaTx),
  createGeneralizedAccount: () => (createGeneralizedAccount)
});

// NAMESPACE OBJECT: ./src/apis/compiler/models/mappers.ts
var models_mappers_namespaceObject = {};
__webpack_require__.r(models_mappers_namespaceObject);
__webpack_require__.d(models_mappers_namespaceObject, {
  ApiVersion: () => (ApiVersion),
  ByteCodeInput: () => (ByteCodeInput),
  BytecodeCallResultInput: () => (BytecodeCallResultInput),
  Calldata: () => (Calldata),
  CompileOpts: () => (CompileOpts),
  CompileResult: () => (CompileResult),
  CompilerError: () => (mappers_CompilerError),
  CompilerVersion: () => (CompilerVersion),
  Contract: () => (mappers_Contract),
  DecodeCalldataBytecode: () => (DecodeCalldataBytecode),
  DecodeCalldataSource: () => (DecodeCalldataSource),
  DecodedCalldata: () => (DecodedCalldata),
  DecodedCallresult: () => (DecodedCallresult),
  ErrorModel: () => (mappers_ErrorModel),
  ErrorPos: () => (ErrorPos),
  FateAssembler: () => (FateAssembler),
  FunctionCallInput: () => (FunctionCallInput),
  SophiaBinaryData: () => (SophiaBinaryData),
  SophiaCallResultInput: () => (SophiaCallResultInput),
  SophiaJsonData: () => (SophiaJsonData),
  ValidateByteCodeInput: () => (ValidateByteCodeInput)
});

// NAMESPACE OBJECT: ./src/apis/middleware/models/mappers.ts
var middleware_models_mappers_namespaceObject = {};
__webpack_require__.r(middleware_models_mappers_namespaceObject);
__webpack_require__.d(middleware_models_mappers_namespaceObject, {
  Activity: () => (Activity),
  Aex141OwnedTokenResponse: () => (Aex141OwnedTokenResponse),
  Aex141Response: () => (Aex141Response),
  Aex141TemplateTokensResponse: () => (Aex141TemplateTokensResponse),
  Aex141TemplatesResponse: () => (Aex141TemplatesResponse),
  Aex141TransferEvent: () => (Aex141TransferEvent),
  Aex9BalanceResponse: () => (Aex9BalanceResponse),
  Aex9ContractBalanceResponse: () => (Aex9ContractBalanceResponse),
  Aex9Response: () => (Aex9Response),
  Aex9TransferEvent: () => (Aex9TransferEvent),
  Aex9TransferResponse: () => (Aex9TransferResponse),
  Auction: () => (Auction),
  AuctionInfo: () => (AuctionInfo),
  AuctionInfoLastBid: () => (AuctionInfoLastBid),
  Block: () => (Block),
  Channel: () => (mappers_Channel),
  ContractCall: () => (ContractCall),
  ContractLog: () => (ContractLog),
  DeltaStat: () => (DeltaStat),
  ErrorResponse: () => (ErrorResponse),
  Get200ApplicationJsonAllOfPropertiesItemsItem: () => (Get200ApplicationJsonAllOfPropertiesItemsItem),
  InternalContractCallEvent: () => (InternalContractCallEvent),
  InternalTransferEvent: () => (InternalTransferEvent),
  KeyBlock: () => (mappers_KeyBlock),
  MicroBlock: () => (MicroBlock),
  Name: () => (Name),
  NameClaim: () => (NameClaim),
  NameClaimEvent: () => (NameClaimEvent),
  NameInfo: () => (NameInfo),
  NameInfoOwnership: () => (NameInfoOwnership),
  NameInfoPointers: () => (NameInfoPointers),
  NameTransfer: () => (NameTransfer),
  NameUpdate: () => (NameUpdate),
  NotFoundResponse: () => (NotFoundResponse),
  Oracle: () => (Oracle),
  OracleExtendsItem: () => (OracleExtendsItem),
  PaginatedResponse: () => (PaginatedResponse),
  Paths10TrrshV2KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths10TrrshV2KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths11X7LpcV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths11X7LpcV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths12TleqhV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths12TleqhV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths15Ih6XV2BlocksGetResponses200ContentApplicationJsonSchema: () => (Paths15Ih6XV2BlocksGetResponses200ContentApplicationJsonSchema),
  Paths15PsutbV2TotalstatsGetResponses200ContentApplicationJsonSchema: () => (Paths15PsutbV2TotalstatsGetResponses200ContentApplicationJsonSchema),
  Paths16Srg6EV2NamesGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths16Srg6EV2NamesGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths16Tt677V2TxsCountIdGetResponses200ContentApplicationJsonSchema: () => (Paths16Tt677V2TxsCountIdGetResponses200ContentApplicationJsonSchema),
  Paths17Cjtx5V2TransfersGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths17Cjtx5V2TransfersGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths17FlgdkV2Aex141GetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths17FlgdkV2Aex141GetResponses200ContentApplicationJsonSchemaAllof0),
  Paths17O9Fn6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema: () => (Paths17O9Fn6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema),
  Paths187U0XzV2ContractsCallsGetResponses200ContentApplicationJsonSchema: () => (Paths187U0XzV2ContractsCallsGetResponses200ContentApplicationJsonSchema),
  Paths19B9O7TV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths19B9O7TV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1BsirxgV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchema: () => (Paths1BsirxgV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchema),
  Paths1C2B0UpV2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1C2B0UpV2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1Csrt0IV2ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Csrt0IV2ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1DkkopqV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchema: () => (Paths1DkkopqV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchema),
  Paths1Fe570RV2Aex9GetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1Fe570RV2Aex9GetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1I5J7OcV2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1I5J7OcV2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1I6PwfdV2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1I6PwfdV2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1Ilysy5V2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchema: () => (Paths1Ilysy5V2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchema),
  Paths1R02SlwV2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema: () => (Paths1R02SlwV2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema),
  Paths1R74KpvV2TxsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1R74KpvV2TxsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1RxrrvbV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths1RxrrvbV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths1T9RwnyV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema: () => (Paths1T9RwnyV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema),
  Paths1Txl2A9V2ChannelsGetResponses200ContentApplicationJsonSchema: () => (Paths1Txl2A9V2ChannelsGetResponses200ContentApplicationJsonSchema),
  Paths1Ulxr59V2KeyBlocksGetResponses200ContentApplicationJsonSchema: () => (Paths1Ulxr59V2KeyBlocksGetResponses200ContentApplicationJsonSchema),
  Paths1V0FiznV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchema: () => (Paths1V0FiznV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchema),
  Paths1Wbogg8V2Aex9GetResponses200ContentApplicationJsonSchema: () => (Paths1Wbogg8V2Aex9GetResponses200ContentApplicationJsonSchema),
  Paths1X48QgjV2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchema: () => (Paths1X48QgjV2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchema),
  Paths3Msq0DV2NamesSearchGetResponses200ContentApplicationJsonSchema: () => (Paths3Msq0DV2NamesSearchGetResponses200ContentApplicationJsonSchema),
  Paths5LeqfqV2BlocksGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths5LeqfqV2BlocksGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths5U7W2V2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths5U7W2V2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths7Hfka2V2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths7Hfka2V2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0),
  Paths7P6Qc1V2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0PropertiesDataItemsAllof1: () => (Paths7P6Qc1V2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0PropertiesDataItemsAllof1),
  Paths7Pbec0V2DeltastatsGetResponses200ContentApplicationJsonSchema: () => (Paths7Pbec0V2DeltastatsGetResponses200ContentApplicationJsonSchema),
  Paths9Ya94MV2ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0: () => (Paths9Ya94MV2ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsAxw0PwV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsAxw0PwV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsB0YvynV2OraclesGetResponses200ContentApplicationJsonSchema: () => (PathsB0YvynV2OraclesGetResponses200ContentApplicationJsonSchema),
  PathsB246H1V2ContractsLogsGetResponses200ContentApplicationJsonSchema: () => (PathsB246H1V2ContractsLogsGetResponses200ContentApplicationJsonSchema),
  PathsBelvp6V2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsBelvp6V2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsC25EgV2ChannelsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsC25EgV2ChannelsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsDjelzuV2NamesIdPointeesGetResponses200ContentApplicationJsonSchema: () => (PathsDjelzuV2NamesIdPointeesGetResponses200ContentApplicationJsonSchema),
  PathsDpxn99V2TotalstatsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsDpxn99V2TotalstatsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsFclv4TV2TxsGetResponses200ContentApplicationJsonSchema: () => (PathsFclv4TV2TxsGetResponses200ContentApplicationJsonSchema),
  PathsFlc7UjV2Aex141GetResponses200ContentApplicationJsonSchema: () => (PathsFlc7UjV2Aex141GetResponses200ContentApplicationJsonSchema),
  PathsGuqvhdV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchema: () => (PathsGuqvhdV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchema),
  PathsIgs9Z1V2TransfersGetResponses200ContentApplicationJsonSchema: () => (PathsIgs9Z1V2TransfersGetResponses200ContentApplicationJsonSchema),
  PathsK9TkttV2NamesGetResponses200ContentApplicationJsonSchema: () => (PathsK9TkttV2NamesGetResponses200ContentApplicationJsonSchema),
  PathsKlr2M2V2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchema: () => (PathsKlr2M2V2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchema),
  PathsMherz6V2OraclesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsMherz6V2OraclesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsN3Ru7DV2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsN3Ru7DV2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsNi359V2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema: () => (PathsNi359V2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema),
  PathsNuoourV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema: () => (PathsNuoourV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema),
  PathsO99PhzV2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema: () => (PathsO99PhzV2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema),
  PathsO9MbpkV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchemaAllof1: () => (PathsO9MbpkV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchemaAllof1),
  PathsRa6Pv6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsRa6Pv6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsRzn6HzV2DeltastatsGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsRzn6HzV2DeltastatsGetResponses200ContentApplicationJsonSchemaAllof0),
  PathsSs61ZgV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchema: () => (PathsSs61ZgV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchema),
  PathsY2JwfkV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchemaAllof0: () => (PathsY2JwfkV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchemaAllof0),
  Status: () => (mappers_Status),
  StatusMdwAsyncTasks: () => (StatusMdwAsyncTasks),
  TotalStat: () => (TotalStat),
  Transfer: () => (Transfer),
  Tx: () => (mappers_Tx)
});

// EXTERNAL MODULE: external "bignumber.js"
var external_bignumber_js_ = __webpack_require__(5192);
var external_bignumber_js_default = /*#__PURE__*/__webpack_require__.n(external_bignumber_js_);
;// CONCATENATED MODULE: ./src/utils/bignumber.ts
/**
 * Big Number Helpers
 */


/**
 * Check if value is BigNumber, Number, BigInt or number string representation
 * @param number - number to check
 */
const isBigNumber = number => {
  if (typeof number === 'bigint') return true;
  return ['number', 'object', 'string'].includes(typeof number)
  // eslint-disable-next-line no-restricted-globals
  && (!isNaN(number) || Number.isInteger(number) || external_bignumber_js_default().isBigNumber(number));
};

/**
 * BigNumber ceil operation
 */
const ceil = bigNumber => bigNumber.integerValue((external_bignumber_js_default()).ROUND_CEIL);
;// CONCATENATED MODULE: ./src/utils/errors.ts
// eslint-disable-next-line max-classes-per-file

/**
 * aepp-sdk originated error
 * @category exception
 */
class BaseError extends Error {
  constructor(message) {
    super(message);
    this.name = 'BaseError';
  }
}

/**
 * @category exception
 */
class AccountError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AccountError';
  }
}

/**
 * @category exception
 */
class AensError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AensError';
  }
}

/**
 * @category exception
 */
class AeppError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'AeppError';
  }
}

/**
 * @category exception
 */
class ChannelError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'ChannelError';
  }
}

/**
 * @category exception
 */
class CompilerError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'CompilerError';
  }
}

/**
 * @category exception
 */
class ContractError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'ContractError';
  }
}

/**
 * @category exception
 */
class CryptographyError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'CryptographyError';
  }
}

/**
 * @category exception
 */
class NodeError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'NodeError';
  }
}

/**
 * @category exception
 */
class TransactionError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'TransactionError';
  }
}

/**
 * @category exception
 */
class WalletError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'WalletError';
  }
}

/**
 * @category exception
 */
class ArgumentError extends BaseError {
  constructor(argumentName, requirement, argumentValue) {
    super(`${argumentName} should be ${requirement}, got ${argumentValue} instead`);
    this.name = 'ArgumentError';
  }
}

/**
 * @category exception
 */
class IllegalArgumentError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'IllegalArgumentError';
  }
}

/**
 * @category exception
 */
class ArgumentCountMismatchError extends BaseError {
  constructor(functionName, requiredCount, providedCount) {
    super(`${functionName} expects ${requiredCount} arguments, got ${providedCount} instead`);
    this.name = 'ArgumentCountMismatchError';
  }
}

/**
 * @category exception
 */
class InsufficientBalanceError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'InsufficientBalanceError';
  }
}

/**
 * @category exception
 */
class MissingParamError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'MissingParamError';
  }
}

/**
 * @category exception
 */
class NoSerializerFoundError extends BaseError {
  constructor() {
    super('Byte serialization not supported');
    this.name = 'NoSerializerFoundError';
  }
}

/**
 * @category exception
 */
class RequestTimedOutError extends BaseError {
  constructor(height) {
    super(`Giving up at height ${height}`);
    this.name = 'RequestTimedOutError';
  }
}

/**
 * @category exception
 */
class TxTimedOutError extends BaseError {
  constructor(blocks, th) {
    super([`Giving up after ${blocks} blocks mined`, `transaction hash: ${th}`].join(', '));
    this.name = 'TxTimedOutError';
  }
}

/**
 * @category exception
 */
class errors_TypeError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'TypeError';
  }
}

/**
 * @category exception
 */
class UnsupportedPlatformError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'UnsupportedPlatformError';
  }
}

/**
 * @category exception
 */
class UnsupportedProtocolError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'UnsupportedProtocolError';
  }
}

/**
 * @category exception
 */
class NotImplementedError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'NotImplementedError';
  }
}

/**
 * @category exception
 */
class UnsupportedVersionError extends BaseError {
  constructor(dependency, version, geVersion, ltVersion) {
    super(`Unsupported ${dependency} version ${version}. Supported: >= ${geVersion} < ${ltVersion}`);
    this.name = 'UnsupportedVersionError';
  }
}

/**
 * @category exception
 */
class InternalError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'InternalError';
  }
}

/**
 * @category exception
 */
class UnexpectedTsError extends InternalError {
  constructor(message = 'Expected to not happen, required for TS') {
    super(message);
    this.name = 'UnexpectedTsError';
  }
}

/**
 * @category exception
 */
class UnavailableAccountError extends AccountError {
  constructor(address) {
    super(`Account for ${address} not available`);
    this.name = 'UnavailableAccountError';
  }
}

/**
 * @category exception
 */
class AensPointerContextError extends AensError {
  constructor(nameOrId, prefix) {
    super(`Name ${nameOrId} don't have pointers for ${prefix}`);
    this.name = 'AensPointerContextError';
  }
}

/**
 * @category exception
 */
class InsufficientNameFeeError extends AensError {
  constructor(nameFee, minNameFee) {
    super(`the provided fee ${nameFee.toString()} is not enough to execute the claim, required: ${minNameFee.toString()}`);
    this.name = 'InsufficientNameFeeError';
  }
}

/**
 * @category exception
 */
class InvalidAensNameError extends AensError {
  constructor(message) {
    super(message);
    this.name = 'InvalidAensNameError';
  }
}

/**
 * @category exception
 */
class InvalidRpcMessageError extends AeppError {
  constructor(message) {
    super(`Received invalid message: ${message}`);
    this.name = 'InvalidRpcMessageError';
  }
}

/**
 * @category exception
 */
class MissingCallbackError extends AeppError {
  constructor(id) {
    super(`Can't find callback for this messageId ${id}`);
    this.name = 'MissingCallbackError';
  }
}

/**
 * @category exception
 */
class UnAuthorizedAccountError extends AeppError {
  constructor(onAccount) {
    super(`You do not have access to account ${onAccount}`);
    this.name = 'UnAuthorizedAccountError';
  }
}

/**
 * @category exception
 */
class UnknownRpcClientError extends AeppError {
  constructor(id) {
    super(`RpcClient with id ${id} do not exist`);
    this.name = 'UnknownRpcClientError';
  }
}

/**
 * @category exception
 */
class UnsubscribedAccountError extends AeppError {
  constructor() {
    super('You are not subscribed for an account.');
    this.name = 'UnsubscribedAccountError';
  }
}

/**
 * @category exception
 */
class ChannelCallError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'ChannelCallError';
  }
}

/**
 * @category exception
 */
class ChannelConnectionError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'ChannelConnectionError';
  }
}

/**
 * @category exception
 */
class ChannelPingTimedOutError extends ChannelError {
  constructor() {
    super('Server pong timed out');
    this.name = 'ChannelPingTimedOutError';
  }
}

/**
 * @category exception
 */
class UnexpectedChannelMessageError extends ChannelError {
  constructor(message) {
    super(message);
    this.name = 'UnexpectedChannelMessageError';
  }
}

/**
 * @category exception
 */
class ChannelIncomingMessageError extends ChannelError {
  constructor(handlerError, incomingMessage) {
    super(handlerError.message);
    this.handlerError = handlerError;
    this.incomingMessage = incomingMessage;
    this.name = 'ChannelIncomingMessageError';
  }
}

/**
 * @category exception
 */
class UnknownChannelStateError extends ChannelError {
  constructor() {
    super('State Channels FSM entered unknown state');
    this.name = 'UnknownChannelStateError';
  }
}

/**
 * @category exception
 */
class InvalidAuthDataError extends CompilerError {
  constructor(message) {
    super(message);
    this.name = 'InvalidAuthDataError';
  }
}

/**
 * @category exception
 */
class BytecodeMismatchError extends ContractError {
  constructor(source) {
    super(`Contract ${source} do not correspond to the bytecode deployed on the chain`);
    this.name = 'BytecodeMismatchError';
  }
}

/**
 * @category exception
 */
class DuplicateContractError extends ContractError {
  constructor() {
    super('Contract already deployed');
    this.name = 'DuplicateContractError';
  }
}

/**
 * @category exception
 */
class InactiveContractError extends ContractError {
  constructor(contractAddress) {
    super(`Contract with address ${contractAddress} not active`);
    this.name = 'InactiveContractError';
  }
}

/**
 * @category exception
 */
class InvalidMethodInvocationError extends ContractError {
  constructor(message) {
    super(message);
    this.name = 'InvalidMethodInvocationError';
  }
}

/**
 * @category exception
 */
class MissingContractAddressError extends ContractError {
  constructor(message) {
    super(message);
    this.name = 'MissingContractAddressError';
  }
}

/**
 * @category exception
 */
class MissingContractDefError extends ContractError {
  constructor() {
    super('Either ACI or sourceCode or sourceCodePath is required');
    this.name = 'MissingContractDefError';
  }
}

/**
 * @category exception
 */
class MissingFunctionNameError extends ContractError {
  constructor() {
    super('Function name is required');
    this.name = 'MissingFunctionNameError';
  }
}

/**
 * @category exception
 */
class NodeInvocationError extends ContractError {
  constructor(message, transaction) {
    super(`Invocation failed${message == null ? '' : `: "${message}"`}`);
    this.name = 'NodeInvocationError';
    this.transaction = transaction;
  }
}

/**
 * @category exception
 */
class NoSuchContractFunctionError extends ContractError {
  constructor(name) {
    super(`Function ${name} doesn't exist in contract`);
    this.name = 'NoSuchContractFunctionError';
  }
}

/**
 * @category exception
 */
class NotPayableFunctionError extends ContractError {
  constructor(amount, fn) {
    super(`You try to pay "${amount}" to function "${fn}" which is not payable. ` + 'Only payable function can accept coins');
    this.name = 'NotPayableFunctionError';
  }
}

/**
 * @category exception
 */
class MissingEventDefinitionError extends ContractError {
  constructor(eventNameHash, eventAddress) {
    super(`Can't find definition of ${eventNameHash} event emitted by ${eventAddress}` + ' (use omitUnknown option to ignore events like this)');
    this.name = 'MissingEventDefinitionError';
  }
}

/**
 * @category exception
 */
class AmbiguousEventDefinitionError extends ContractError {
  constructor(eventAddress, matchedEvents) {
    super(`Found multiple definitions of "${matchedEvents[0][1]}" event with different types emitted by` + ` ${eventAddress} in ${matchedEvents.map(([name]) => `"${name}"`).join(', ')} contracts` + ' (use contractAddressToName option to specify contract name corresponding to address)');
    this.name = 'AmbiguousEventDefinitionError';
  }
}

/**
 * @category exception
 */
class InvalidChecksumError extends CryptographyError {
  constructor() {
    super('Invalid checksum');
    this.name = 'InvalidChecksumError';
  }
}

/**
 * @category exception
 */
class InvalidPasswordError extends CryptographyError {
  constructor() {
    super('Invalid password or nonce');
    this.name = 'InvalidPasswordError';
  }
}

/**
 * @category exception
 */
class MerkleTreeHashMismatchError extends CryptographyError {
  constructor() {
    super('Node hash is not equal to provided one');
    this.name = 'MerkleTreeHashMismatchError';
  }
}

/**
 * @category exception
 */
class MissingNodeInTreeError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'MissingNodeInTreeError';
  }
}

/**
 * @category exception
 */
class UnknownNodeLengthError extends CryptographyError {
  constructor(nodeLength) {
    super(`Unknown node length: ${nodeLength}`);
    this.name = 'UnknownNodeLengthError';
  }
}

/**
 * @category exception
 */
class UnknownPathNibbleError extends CryptographyError {
  constructor(nibble) {
    super(`Unknown path nibble: ${nibble}`);
    this.name = 'UnknownPathNibbleError';
  }
}

/**
 * @category exception
 */
class DuplicateNodeError extends NodeError {
  constructor(name) {
    super(`Node with name ${name} already exist`);
    this.name = 'DuplicateNodeError';
  }
}

/**
 * @category exception
 */
class NodeNotFoundError extends NodeError {
  constructor(message) {
    super(message);
    this.name = 'NodeNotFoundError';
  }
}

/**
 * @category exception
 */
class DecodeError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'DecodeError';
  }
}

/**
 * @category exception
 */
class PayloadLengthError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'PayloadLengthError';
  }
}

/**
 * @category exception
 */
class DryRunError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'DryRunError';
  }
}

/**
 * @category exception
 */
class IllegalBidFeeError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'IllegalBidFeeError';
  }
}

/**
 * @category exception
 */
class InvalidSignatureError extends TransactionError {
  constructor(message) {
    super(message);
    this.name = 'InvalidSignatureError';
  }
}

/**
 * @category exception
 */
class PrefixNotFoundError extends TransactionError {
  constructor(tag) {
    super(`Prefix for id-tag ${tag} not found.`);
    this.name = 'PrefixNotFoundError';
  }
}

/**
 * @category exception
 */
class SchemaNotFoundError extends TransactionError {
  constructor(key, version) {
    super(`Transaction schema not implemented for tag ${key} version ${version}`);
    this.name = 'SchemaNotFoundError';
  }
}

/**
 * @category exception
 */
class TagNotFoundError extends TransactionError {
  constructor(prefix) {
    super(`Id tag for prefix ${prefix} not found.`);
    this.name = 'DecodeError';
  }
}

/**
 * @category exception
 */
class TxNotInChainError extends TransactionError {
  constructor(txHash) {
    super(`Transaction ${txHash} is removed from chain`);
    this.name = 'TxNotInChainError';
  }
}

/**
 * @category exception
 */
class AlreadyConnectedError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'AlreadyConnectedError';
  }
}

/**
 * @category exception
 */
class NoWalletConnectedError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'NoWalletConnectedError';
  }
}

/**
 * @category exception
 */
class RpcConnectionError extends WalletError {
  constructor(message) {
    super(message);
    this.name = 'RpcConnectionError';
  }
}
;// CONCATENATED MODULE: ./src/utils/amount-formatter.ts



let AE_AMOUNT_FORMATS = /*#__PURE__*/function (AE_AMOUNT_FORMATS) {
  AE_AMOUNT_FORMATS["AE"] = "ae";
  AE_AMOUNT_FORMATS["MILI_AE"] = "miliAE";
  AE_AMOUNT_FORMATS["MICRO_AE"] = "microAE";
  AE_AMOUNT_FORMATS["NANO_AE"] = "nanoAE";
  AE_AMOUNT_FORMATS["PICO_AE"] = "picoAE";
  AE_AMOUNT_FORMATS["FEMTO_AE"] = "femtoAE";
  AE_AMOUNT_FORMATS["AETTOS"] = "aettos";
  return AE_AMOUNT_FORMATS;
}({});

/**
 * DENOMINATION_MAGNITUDE
 */
const DENOMINATION_MAGNITUDE = {
  [AE_AMOUNT_FORMATS.AE]: 0,
  [AE_AMOUNT_FORMATS.MILI_AE]: -3,
  [AE_AMOUNT_FORMATS.MICRO_AE]: -6,
  [AE_AMOUNT_FORMATS.NANO_AE]: -9,
  [AE_AMOUNT_FORMATS.PICO_AE]: -12,
  [AE_AMOUNT_FORMATS.FEMTO_AE]: -15,
  [AE_AMOUNT_FORMATS.AETTOS]: -18
};

/**
 * Convert amount from one to other denomination
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 * @param options.targetDenomination - target denomination,
 * can be ['ae', 'aettos']
 */
const formatAmount = (value, {
  denomination = AE_AMOUNT_FORMATS.AETTOS,
  targetDenomination = AE_AMOUNT_FORMATS.AETTOS
}) => {
  if (!isBigNumber(value)) throw new ArgumentError('value', 'a number', value);
  return new (external_bignumber_js_default())(typeof value === 'bigint' ? value.toString() : value).shiftedBy(DENOMINATION_MAGNITUDE[denomination] - DENOMINATION_MAGNITUDE[targetDenomination]).toFixed();
};

/**
 * Convert amount to AE
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 */
const toAe = (value, {
  denomination = AE_AMOUNT_FORMATS.AETTOS
} = {}) => formatAmount(value, {
  denomination,
  targetDenomination: AE_AMOUNT_FORMATS.AE
});

/**
 * Convert amount to aettos
 * @param value - amount to convert
 * @param options - options
 * @param options.denomination - denomination of amount, can be ['ae', 'aettos']
 */
const toAettos = (value, {
  denomination = AE_AMOUNT_FORMATS.AE
} = {}) => formatAmount(value, {
  denomination
});
const prefixes = [{
  name: 'exa',
  magnitude: 18
}, {
  name: 'giga',
  magnitude: 9
}, {
  name: '',
  magnitude: 0
}, {
  name: 'pico',
  magnitude: -12
}];
const getNearestPrefix = exponent => prefixes.reduce((p, n) => Math.abs(n.magnitude - exponent) < Math.abs(p.magnitude - exponent) ? n : p);
const getLowerBoundPrefix = exponent => {
  var _prefixes$find;
  return (_prefixes$find = prefixes.find(p => p.magnitude <= exponent)) !== null && _prefixes$find !== void 0 ? _prefixes$find : prefixes[prefixes.length - 1];
};
const prefixedAmount = rawValue => {
  var _value$e;
  const value = new (external_bignumber_js_default())(rawValue);
  const exp = (_value$e = value.e) !== null && _value$e !== void 0 ? _value$e : 0;
  const {
    name,
    magnitude
  } = (exp < 0 ? getNearestPrefix : getLowerBoundPrefix)(exp);
  const v = value.shiftedBy(-magnitude).precision(9 + Math.min(exp - magnitude, 0)).toFixed();
  return `${v}${name !== '' ? ' ' : ''}${name}`;
};
// EXTERNAL MODULE: external "@azure/core-rest-pipeline"
var core_rest_pipeline_ = __webpack_require__(5039);
// EXTERNAL MODULE: external "tweetnacl"
var external_tweetnacl_ = __webpack_require__(79);
var external_tweetnacl_default = /*#__PURE__*/__webpack_require__.n(external_tweetnacl_);
// EXTERNAL MODULE: ./node_modules/blakejs/blake2b.js
var blake2b = __webpack_require__(8442);
// EXTERNAL MODULE: external "varuint-bitcoin"
var external_varuint_bitcoin_ = __webpack_require__(7480);
;// CONCATENATED MODULE: ./src/utils/other.ts

const pause = async duration => new Promise(resolve => {
  setTimeout(resolve, duration);
});
const mapObject = (object, fn) => Object.fromEntries(Object.entries(object).map(fn));

// remove after dropping webpack4 support
const isWebpack4Buffer = (() => {
  try {
    Buffer.concat([Uint8Array.from([])]);
    return false;
  } catch (error) {
    return true;
  }
})();
const concatBuffers = isWebpack4Buffer ? (list, totalLength) => Buffer.concat(list.map(el => Buffer.from(el)), totalLength) : Buffer.concat;

/**
 * Object key type guard
 * @param key - Maybe object key
 * @param object - Object
 */
function isKeyOfObject(key, object) {
  return key in object;
}

/**
 * Array item type guard
 * @param item - Maybe array item
 * @param array - Array
 */
function isItemOfArray(item, array) {
  return array.includes(item);
}
function isAccountNotFoundError(error) {
  return error instanceof core_rest_pipeline_.RestError && error.statusCode === 404 && error.message.includes('Account not found');
}

// based on https://stackoverflow.com/a/50375286/6176994

function ensureError(error) {
  if (error instanceof Error) return;
  throw error;
}
// EXTERNAL MODULE: external "bs58"
var external_bs58_ = __webpack_require__(3783);
// EXTERNAL MODULE: ./node_modules/sha.js/sha256.js
var sha256 = __webpack_require__(7499);
var sha256_default = /*#__PURE__*/__webpack_require__.n(sha256);
;// CONCATENATED MODULE: ./src/utils/encoder-types.ts
/**
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/master/node/api/api_encoding.md}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L205-L230}
 */
let Encoding = /*#__PURE__*/function (Encoding) {
  Encoding["KeyBlockHash"] = "kh";
  Encoding["MicroBlockHash"] = "mh";
  Encoding["BlockPofHash"] = "bf";
  Encoding["BlockTxHash"] = "bx";
  Encoding["BlockStateHash"] = "bs";
  Encoding["Channel"] = "ch";
  Encoding["ContractAddress"] = "ct";
  Encoding["ContractBytearray"] = "cb";
  Encoding["ContractStoreKey"] = "ck";
  Encoding["ContractStoreValue"] = "cv";
  Encoding["Transaction"] = "tx";
  Encoding["TxHash"] = "th";
  Encoding["OracleAddress"] = "ok";
  Encoding["OracleQuery"] = "ov";
  Encoding["OracleQueryId"] = "oq";
  Encoding["OracleResponse"] = "or";
  Encoding["AccountAddress"] = "ak";
  Encoding["Signature"] = "sg";
  Encoding["Commitment"] = "cm";
  Encoding["PeerPubkey"] = "pp";
  Encoding["Name"] = "nm";
  Encoding["State"] = "st";
  Encoding["Poi"] = "pi";
  Encoding["StateTrees"] = "ss";
  Encoding["CallStateTree"] = "cs";
  Encoding["Bytearray"] = "ba";
  return Encoding;
}({});
;// CONCATENATED MODULE: ./src/utils/encoder.ts

// js extension is required for mjs build, not importing the whole package to reduce bundle size
// eslint-disable-next-line import/extensions







/**
 * Calculate SHA256 hash of `input`
 * @param input - Data to hash
 * @returns Hash
 */
function sha256hash(input) {
  return new (sha256_default())().update(input).digest();
}

/**
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L177-L202}
 */
const base64Types = [Encoding.ContractBytearray, Encoding.ContractStoreKey, Encoding.ContractStoreValue, Encoding.Transaction, Encoding.OracleQuery, Encoding.OracleResponse, Encoding.State, Encoding.Poi, Encoding.StateTrees, Encoding.CallStateTree, Encoding.Bytearray];
const base58Types = [Encoding.KeyBlockHash, Encoding.MicroBlockHash, Encoding.BlockPofHash, Encoding.BlockTxHash, Encoding.BlockStateHash, Encoding.Channel, Encoding.ContractAddress, Encoding.TxHash, Encoding.OracleAddress, Encoding.OracleQueryId, Encoding.AccountAddress, Encoding.Signature, Encoding.Commitment, Encoding.PeerPubkey, Encoding.Name];

/**
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L261-L286}
 */
const byteSizeForType = {
  [Encoding.KeyBlockHash]: 32,
  [Encoding.MicroBlockHash]: 32,
  [Encoding.BlockPofHash]: 32,
  [Encoding.BlockTxHash]: 32,
  [Encoding.BlockStateHash]: 32,
  [Encoding.Channel]: 32,
  [Encoding.ContractAddress]: 32,
  [Encoding.TxHash]: 32,
  [Encoding.OracleAddress]: 32,
  [Encoding.OracleQueryId]: 32,
  [Encoding.AccountAddress]: 32,
  [Encoding.Signature]: 64,
  [Encoding.Commitment]: 32,
  [Encoding.PeerPubkey]: 32,
  [Encoding.State]: 32
};
function ensureValidLength(data, type) {
  if (!isKeyOfObject(type, byteSizeForType)) return;
  const reqLen = byteSizeForType[type];
  if (reqLen == null || data.length === reqLen) return;
  throw new PayloadLengthError(`Payload should be ${reqLen} bytes, got ${data.length} instead`);
}
const getChecksum = payload => sha256hash(sha256hash(payload)).slice(0, 4);
const addChecksum = payload => concatBuffers([payload, getChecksum(payload)]);
function getPayload(buffer) {
  const payload = buffer.slice(0, -4);
  if (!getChecksum(payload).equals(buffer.slice(-4))) throw new InvalidChecksumError();
  return payload;
}
const base64 = {
  encode: buffer => addChecksum(buffer).toString('base64'),
  decode: string => getPayload(Buffer.from(string, 'base64'))
};
const base58 = {
  encode: buffer => (0,external_bs58_.encode)(addChecksum(buffer)),
  decode: string => getPayload(Buffer.from((0,external_bs58_.decode)(string)))
};
const parseType = maybeType => {
  const base64Type = base64Types.find(t => t === maybeType);
  if (base64Type != null) return [base64Type, base64];
  const base58Type = base58Types.find(t => t === maybeType);
  if (base58Type != null) return [base58Type, base58];
  throw new ArgumentError('prefix', `one of ${[...base58Types, ...base64Types].join(', ')}`, maybeType);
};

/**
 * Decode data using the default encoding/decoding algorithm
 * @param data - An Base58/64check encoded and prefixed string
 * (ex tx_..., sg_..., ak_....)
 * @returns Decoded data
 */
function decode(data) {
  const [prefix, encodedPayload, extra] = data.split('_');
  if (encodedPayload == null) throw new DecodeError(`Encoded string missing payload: ${data}`);
  if (extra != null) throw new DecodeError(`Encoded string have extra parts: ${data}`);
  const [type, encoder] = parseType(prefix);
  const payload = encoder.decode(encodedPayload);
  ensureValidLength(payload, type);
  return payload;
}

/**
 * Encode data using the default encoding/decoding algorithm
 * @param data - An decoded data
 * @param type - Prefix of Transaction
 * @returns Encoded string Base58check or Base64check data
 */
function encode(data, type) {
  const [, encoder] = parseType(type);
  ensureValidLength(data, type);
  return `${type}_${encoder.encode(data)}`;
}
;// CONCATENATED MODULE: ./src/utils/crypto.ts

// js extension is required for mjs build, not importing the whole package to reduce bundle size
// eslint-disable-next-line import/extensions






/**
 * Generate address from secret key
 * @param secret - Private key as hex string
 * @returns Public key encoded as address
 */
function getAddressFromPriv(secret) {
  const secretBuffer = typeof secret === 'string' ? Buffer.from(secret, 'hex') : secret;
  const keys = external_tweetnacl_default().sign.keyPair.fromSecretKey(secretBuffer);
  return encode(keys.publicKey, Encoding.AccountAddress);
}

/**
 * Check if address is valid
 * @param address - Address
 * @param prefix - Transaction prefix. Default: 'ak'
 * @returns is valid
 */
function isAddressValid(address, prefix = Encoding.AccountAddress) {
  try {
    decode(address);
    const actualPrefix = address.split('_')[0];
    if (actualPrefix !== prefix) {
      throw new ArgumentError('Encoded string type', prefix, actualPrefix);
    }
    return true;
  } catch (e) {
    return false;
  }
}

/**
 * Generate a random salt (positive integer)
 * @returns random salt
 */
function genSalt() {
  const [random] = new BigUint64Array(external_tweetnacl_default().randomBytes(8).buffer);
  return Number(random % BigInt(Number.MAX_SAFE_INTEGER));
}

/**
 * Converts a positive integer to the smallest possible
 * representation in a binary digit representation
 * @param value - Value to encode
 * @returns Encoded number
 */
function encodeUnsigned(value) {
  const binary = Buffer.allocUnsafe(4);
  binary.writeUInt32BE(value);
  return binary.slice(binary.findIndex(i => i !== 0));
}

/**
 * Calculate 256bits Blake2b hash of `input`
 * @param input - Data to hash
 * @returns Hash
 */
function hash(input) {
  return Buffer.from((0,blake2b.blake2b)(input, undefined, 32)); // 256 bits
}

// Todo Duplicated in tx builder. remove
/**
 * Compute contract address
 * @category contract
 * @param owner - Address of contract owner
 * @param nonce - Round when contract was created
 * @returns Contract address
 */
function encodeContractAddress(owner, nonce) {
  const publicKey = decode(owner);
  const binary = concatBuffers([publicKey, encodeUnsigned(nonce)]);
  return encode(hash(binary), Encoding.ContractAddress);
}

// KEY-PAIR HELPERS

/**
 * Generate keyPair from secret key
 * @param secret - secret key
 * @returns Object with Private(privateKey) and Public(publicKey) keys
 */
function generateKeyPairFromSecret(secret) {
  return external_tweetnacl_default().sign.keyPair.fromSecretKey(secret);
}

/**
 * Generate a random ED25519 keypair
 * @param raw - Whether to return raw (binary) keys
 * @returns Key pair
 */

function generateKeyPair(raw = false) {
  const keyPair = external_tweetnacl_default().sign.keyPair();
  const publicBuffer = Buffer.from(keyPair.publicKey);
  const secretBuffer = Buffer.from(keyPair.secretKey);
  if (raw) {
    return {
      publicKey: publicBuffer,
      secretKey: secretBuffer
    };
  }
  return {
    publicKey: encode(publicBuffer, Encoding.AccountAddress),
    secretKey: secretBuffer.toString('hex')
  };
}

// SIGNATURES

/**
 * Generate signature
 * @param data - Data to sign
 * @param privateKey - Key to sign with
 * @returns Signature
 */
function sign(data, privateKey) {
  return external_tweetnacl_default().sign.detached(Buffer.from(data), Buffer.from(privateKey));
}

/**
 * Verify that signature was signed by public key
 * @param data - Data that was signed
 * @param signature - Signature of data
 * @param address - Address to verify against
 * @returns is data was signed by address
 */
function verify(data, signature, address) {
  return external_tweetnacl_default().sign.detached.verify(data, signature, decode(address));
}
const messagePrefix = Buffer.from('aeternity Signed Message:\n', 'utf8');
const messagePrefixLength = (0,external_varuint_bitcoin_.encode)(messagePrefix.length);

// TODO: consider rename to hashMessage
function messageToHash(message) {
  const msg = Buffer.from(message, 'utf8');
  return hash(concatBuffers([messagePrefixLength, messagePrefix, (0,external_varuint_bitcoin_.encode)(msg.length), msg]));
}
function signMessage(message, privateKey) {
  return sign(messageToHash(message), privateKey);
}

/**
 * Verify that message was signed by address
 * @param message - Message that was signed
 * @param signature - Signature of message
 * @param address - Address to verify against
 * @returns is data was signed by address
 */
// TODO: deprecate in favour of `verify(messageToHash(message), ...`, also the name is confusing
// it should contain "signature"
function verifyMessage(message, signature, address) {
  return verify(messageToHash(message), signature, address);
}

/**
 * Check key pair for validity
 *
 * Signs a message, and then verifies that signature
 * @param privateKey - Private key to verify
 * @param publicKey - Public key to verify as hex string
 * @returns Valid?
 */
function isValidKeypair(privateKey, publicKey) {
  const message = Buffer.from('TheMessage');
  const signature = sign(message, privateKey);
  const publicKeyBuffer = typeof publicKey === 'string' ? Buffer.from(publicKey, 'hex') : publicKey;
  return verify(message, signature, encode(publicKeyBuffer, Encoding.AccountAddress));
}
;// CONCATENATED MODULE: ./src/tx/builder/constants.ts


const MAX_AUTH_FUN_GAS = 50000;

// # AENS

const NAME_TTL = 180000;
// # max number of block into the future that the name is going to be available
// # https://github.com/aeternity/protocol/blob/epoch-v0.22.0/AENS.md#update
// # https://github.com/aeternity/protocol/blob/44a93d3aab957ca820183c3520b9daf6b0fedff4/AENS.md#aens-entry
const NAME_MAX_TTL = 36000;
const NAME_MAX_CLIENT_TTL = 84600;
const CLIENT_TTL = NAME_MAX_CLIENT_TTL;
const MIN_GAS_PRICE = 1e9;
// # see https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L67
const NAME_FEE_MULTIPLIER = 1e14; // 100000000000000
const NAME_FEE_BID_INCREMENT = 0.05; // # the increment is in percentage
// # see https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L272
const NAME_BID_TIMEOUT_BLOCKS = 480; // # ~1 day
// # this is the max length for a domain that requires a base fee to be paid
const NAME_MAX_LENGTH_FEE = 31;
// # https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L290
// # https://github.com/aeternity/protocol/blob/master/AENS.md#protocol-fees-and-protection-times
// # bid ranges:
const NAME_BID_RANGES = mapObject({
  31: 3,
  30: 5,
  29: 8,
  28: 13,
  27: 21,
  26: 34,
  25: 55,
  24: 89,
  23: 144,
  22: 233,
  21: 377,
  20: 610,
  19: 987,
  18: 1597,
  17: 2584,
  16: 4181,
  15: 6765,
  14: 10946,
  13: 17711,
  12: 28657,
  11: 46368,
  10: 75025,
  9: 121393,
  8: 196418,
  7: 317811,
  6: 514229,
  5: 832040,
  4: 1346269,
  3: 2178309,
  2: 3524578,
  1: 5702887
}, ([key, value]) => [key, new (external_bignumber_js_default())(value).times(NAME_FEE_MULTIPLIER)]);
let ConsensusProtocolVersion = /*#__PURE__*/function (ConsensusProtocolVersion) {
  ConsensusProtocolVersion[ConsensusProtocolVersion["Iris"] = 5] = "Iris";
  ConsensusProtocolVersion[ConsensusProtocolVersion["Ceres"] = 6] = "Ceres";
  return ConsensusProtocolVersion;
}({});

/**
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/contracts/contract_vms.md#virtual-machines-on-the-%C3%A6ternity-blockchain}
 */
let VmVersion = /*#__PURE__*/function (VmVersion) {
  VmVersion[VmVersion["NoVm"] = 0] = "NoVm";
  VmVersion[VmVersion["Sophia"] = 1] = "Sophia";
  VmVersion[VmVersion["SophiaImprovementsMinerva"] = 3] = "SophiaImprovementsMinerva";
  VmVersion[VmVersion["SophiaImprovementsFortuna"] = 4] = "SophiaImprovementsFortuna";
  VmVersion[VmVersion["Fate"] = 5] = "Fate";
  VmVersion[VmVersion["SophiaImprovementsLima"] = 6] = "SophiaImprovementsLima";
  VmVersion[VmVersion["Fate2"] = 7] = "Fate2";
  VmVersion[VmVersion["Fate3"] = 8] = "Fate3";
  return VmVersion;
}({});

/**
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/contracts/contract_vms.md#virtual-machines-on-the-%C3%A6ternity-blockchain}
 */
let AbiVersion = /*#__PURE__*/function (AbiVersion) {
  AbiVersion[AbiVersion["NoAbi"] = 0] = "NoAbi";
  AbiVersion[AbiVersion["Sophia"] = 1] = "Sophia";
  AbiVersion[AbiVersion["Fate"] = 3] = "Fate";
  return AbiVersion;
}({});

/**
 * Enum with tag types
 * @category transaction builder
 * @see {@link https://github.com/aeternity/protocol/blob/0f6dee3d9d1e8e2469816798f5c7587a6c918f94/serializations.md#binary-serialization}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_chain_objects.erl#L39-L97}
 */
// TODO: implement serialisation for commented-out tags
let Tag = /*#__PURE__*/function (Tag) {
  Tag[Tag["Account"] = 10] = "Account";
  Tag[Tag["SignedTx"] = 11] = "SignedTx";
  Tag[Tag["SpendTx"] = 12] = "SpendTx";
  Tag[Tag["Oracle"] = 20] = "Oracle";
  Tag[Tag["OracleRegisterTx"] = 22] = "OracleRegisterTx";
  Tag[Tag["OracleQueryTx"] = 23] = "OracleQueryTx";
  Tag[Tag["OracleResponseTx"] = 24] = "OracleResponseTx";
  Tag[Tag["OracleExtendTx"] = 25] = "OracleExtendTx";
  Tag[Tag["Name"] = 30] = "Name";
  Tag[Tag["NameClaimTx"] = 32] = "NameClaimTx";
  Tag[Tag["NamePreclaimTx"] = 33] = "NamePreclaimTx";
  Tag[Tag["NameUpdateTx"] = 34] = "NameUpdateTx";
  Tag[Tag["NameRevokeTx"] = 35] = "NameRevokeTx";
  Tag[Tag["NameTransferTx"] = 36] = "NameTransferTx";
  Tag[Tag["Contract"] = 40] = "Contract";
  Tag[Tag["ContractCall"] = 41] = "ContractCall";
  Tag[Tag["ContractCreateTx"] = 42] = "ContractCreateTx";
  Tag[Tag["ContractCallTx"] = 43] = "ContractCallTx";
  Tag[Tag["ChannelCreateTx"] = 50] = "ChannelCreateTx";
  Tag[Tag["ChannelDepositTx"] = 51] = "ChannelDepositTx";
  Tag[Tag["ChannelWithdrawTx"] = 52] = "ChannelWithdrawTx";
  Tag[Tag["ChannelForceProgressTx"] = 521] = "ChannelForceProgressTx";
  Tag[Tag["ChannelCloseMutualTx"] = 53] = "ChannelCloseMutualTx";
  Tag[Tag["ChannelCloseSoloTx"] = 54] = "ChannelCloseSoloTx";
  Tag[Tag["ChannelSlashTx"] = 55] = "ChannelSlashTx";
  Tag[Tag["ChannelSettleTx"] = 56] = "ChannelSettleTx";
  Tag[Tag["ChannelOffChainTx"] = 57] = "ChannelOffChainTx";
  Tag[Tag["ChannelOffChainUpdateTransfer"] = 570] = "ChannelOffChainUpdateTransfer";
  Tag[Tag["ChannelOffChainUpdateDeposit"] = 571] = "ChannelOffChainUpdateDeposit";
  Tag[Tag["ChannelOffChainUpdateWithdraw"] = 572] = "ChannelOffChainUpdateWithdraw";
  Tag[Tag["ChannelOffChainUpdateCreateContract"] = 573] = "ChannelOffChainUpdateCreateContract";
  Tag[Tag["ChannelOffChainUpdateCallContract"] = 574] = "ChannelOffChainUpdateCallContract";
  Tag[Tag["ChannelClientReconnectTx"] = 575] = "ChannelClientReconnectTx";
  Tag[Tag["Channel"] = 58] = "Channel";
  Tag[Tag["ChannelSnapshotSoloTx"] = 59] = "ChannelSnapshotSoloTx";
  Tag[Tag["TreesPoi"] = 60] = "TreesPoi";
  Tag[Tag["StateTrees"] = 62] = "StateTrees";
  Tag[Tag["Mtree"] = 63] = "Mtree";
  Tag[Tag["MtreeValue"] = 64] = "MtreeValue";
  Tag[Tag["ContractsMtree"] = 621] = "ContractsMtree";
  Tag[Tag["CallsMtree"] = 622] = "CallsMtree";
  Tag[Tag["ChannelsMtree"] = 623] = "ChannelsMtree";
  Tag[Tag["NameserviceMtree"] = 624] = "NameserviceMtree";
  Tag[Tag["OraclesMtree"] = 625] = "OraclesMtree";
  Tag[Tag["AccountsMtree"] = 626] = "AccountsMtree";
  Tag[Tag["GaAttachTx"] = 80] = "GaAttachTx";
  Tag[Tag["GaMetaTx"] = 81] = "GaMetaTx";
  Tag[Tag["PayingForTx"] = 82] = "PayingForTx";
  Tag[Tag["GaMetaTxAuthData"] = 810] = "GaMetaTxAuthData";
  return Tag;
}({}); // KeyBlock = 100,
// MicroBlock = 101,
// LightMicroBlock = 102,
// Pof = 200,
;// CONCATENATED MODULE: ./src/tx/builder/field-types/ct-version.ts

/*
 * First abi/vm by default
 * @see {@link https://github.com/aeternity/protocol/blob/71cf111/contracts/contract_vms.md#virtual-machines-on-the-ternity-blockchain}
 */
const ProtocolToVmAbi = {
  [ConsensusProtocolVersion.Iris]: {
    'contract-create': {
      vmVersion: [VmVersion.Fate2],
      abiVersion: [AbiVersion.Fate]
    },
    'contract-call': {
      vmVersion: [],
      abiVersion: [AbiVersion.Fate, AbiVersion.Sophia]
    },
    'oracle-call': {
      vmVersion: [],
      abiVersion: [AbiVersion.NoAbi, AbiVersion.Fate]
    }
  },
  [ConsensusProtocolVersion.Ceres]: {
    'contract-create': {
      vmVersion: [VmVersion.Fate3],
      abiVersion: [AbiVersion.Fate]
    },
    'contract-call': {
      vmVersion: [],
      abiVersion: [AbiVersion.Fate]
    },
    'oracle-call': {
      vmVersion: [],
      abiVersion: [AbiVersion.NoAbi, AbiVersion.Fate]
    }
  }
};
function getProtocolDetails(protocolVersion, type) {
  var _protocol$vmVersion$;
  const protocol = ProtocolToVmAbi[protocolVersion][type];
  return {
    vmVersion: (_protocol$vmVersion$ = protocol.vmVersion[0]) !== null && _protocol$vmVersion$ !== void 0 ? _protocol$vmVersion$ : VmVersion.Fate2,
    abiVersion: protocol.abiVersion[0]
  };
}
/* harmony default export */ const ct_version = ({
  serialize(value, params, {
    consensusProtocolVersion = ConsensusProtocolVersion.Iris
  }) {
    var _value;
    (_value = value) !== null && _value !== void 0 ? _value : value = getProtocolDetails(consensusProtocolVersion, 'contract-create');
    return Buffer.from([value.vmVersion, 0, value.abiVersion]);
  },
  async prepare(value, params,
  // TODO: { consensusProtocolVersion: ConsensusProtocolVersion } | { onNode: Node } | {}
  options) {
    if (value != null) return value;
    if (options.consensusProtocolVersion != null) return undefined;
    if (Object.keys(ConsensusProtocolVersion).length === 2) return undefined;
    if (options.onNode != null) {
      return getProtocolDetails((await options.onNode.getNodeInfo()).consensusProtocolVersion, 'contract-create');
    }
    return undefined;
  },
  deserialize(buffer) {
    const [vm,, abi] = buffer;
    return {
      vmVersion: +vm,
      abiVersion: +abi
    };
  }
});
// EXTERNAL MODULE: external "rlp"
var external_rlp_ = __webpack_require__(3485);
;// CONCATENATED MODULE: ./src/tx/builder/field-types/entry.ts



function genEntryField(tag) {
  return {
    serialize(txParams, {
      buildTx
    }) {
      if (ArrayBuffer.isView(txParams)) return Buffer.from(txParams);
      if (typeof txParams === 'string' && txParams.startsWith('tx_')) {
        return decode(txParams);
      }
      return decode(buildTx({
        ...txParams,
        ...(tag != null && {
          tag
        })
      }));
    },
    deserialize(buf, {
      unpackTx
    }) {
      const tx = unpackTx(encode(buf, Encoding.Transaction));
      if (tag != null && tx.tag !== tag) throw new ArgumentError('Tag', Tag[tag], Tag[tx.tag]);
      return tx;
    }
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/array.ts
function genArrayField(itemHandler) {
  return {
    serialize(items, params) {
      return items.map(item => itemHandler.serialize(item, params));
    },
    deserialize(buffers, params) {
      return buffers.map(buffer => itemHandler.deserialize(buffer, params));
    }
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/map.ts


function genMapField(encoding, tag) {
  return {
    serialize(object, {
      buildTx
    }) {
      return decode(buildTx({
        tag: Tag.Mtree,
        values: Object.entries(object).map(([key, value]) => ({
          tag: Tag.MtreeValue,
          key: decode(key),
          value: decode(buildTx({
            ...value,
            tag
          }))
        }))
      }));
    },
    deserialize(buffer, {
      unpackTx
    }) {
      const {
        values
      } = unpackTx(encode(buffer, Encoding.Transaction), Tag.Mtree);
      return Object.fromEntries(values
      // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066
      .filter(({
        key
      }) => encoding !== Encoding.ContractAddress || key.length === 32).map(({
        key,
        value
      }) => [encode(key, encoding), unpackTx(encode(value, Encoding.Transaction), tag)]));
    },
    recursiveType: true
  };
}
;// CONCATENATED MODULE: ./src/utils/bytes.ts



/**
 * Convert string, number, or BigNumber to byte array
 * @param val - value to convert
 * @param big - enables force conversion to BigNumber
 * @returns Buffer
 */
// eslint-disable-next-line import/prefer-default-export
function toBytes(val, big = false) {
  // Encode a value to bytes.
  // If the value is an int it will be encoded as bytes big endian
  // Raises ValueError if the input is not an int or string

  if (val == null) return Buffer.from([]);
  if (Number.isInteger(val) || external_bignumber_js_default().isBigNumber(val) || big) {
    if (!external_bignumber_js_default().isBigNumber(val)) val = new (external_bignumber_js_default())(val);
    if (!val.isInteger()) throw new errors_TypeError(`Unexpected not integer value: ${val.toFixed()}`);
    let hexString = val.toString(16);
    if (hexString.length % 2 === 1) hexString = `0${hexString}`;
    return Buffer.from(hexString, 'hex');
  }
  if (typeof val === 'string') {
    return Buffer.from(val);
  }
  throw new NoSerializerFoundError();
}
;// CONCATENATED MODULE: ./src/tx/builder/helpers.ts









/**
 * JavaScript-based Transaction builder helper function's
 */

/**
 * Build a contract public key
 * @category contract
 * @param ownerId - The public key of the owner account
 * @param nonce - the nonce of the transaction
 * @returns Contract public key
 */
function buildContractId(ownerId, nonce) {
  const ownerIdAndNonce = Buffer.from([...decode(ownerId), ...toBytes(nonce)]);
  const b2bHash = hash(ownerIdAndNonce);
  return encode(b2bHash, Encoding.ContractAddress);
}

/**
 * Build a oracle query id
 * @category oracle
 * @param senderId - The public key of the sender account
 * @param nonce - the nonce of the transaction
 * @param oracleId - The oracle public key
 * @returns Contract public key
 */
function oracleQueryId(senderId, nonce, oracleId) {
  function _int32(val) {
    const nonceBE = toBytes(val, true);
    return concatBuffers([Buffer.alloc(32 - nonceBE.length), nonceBE]);
  }
  const b2bHash = hash(Buffer.from([...decode(senderId), ..._int32(nonce), ...decode(oracleId)]));
  return encode(b2bHash, Encoding.OracleQueryId);
}
const AENS_SUFFIX = '.chain';
function nameToPunycode(maybeName) {
  const [name, suffix, ...other] = maybeName.split('.');
  if (other.length !== 0) throw new ArgumentError('aens name', 'including only one dot', maybeName);
  if (suffix !== AENS_SUFFIX.slice(1)) {
    throw new ArgumentError('aens name', `suffixed with ${AENS_SUFFIX}`, maybeName);
  }
  if (/\p{Emoji_Presentation}/u.test(name)) {
    throw new ArgumentError('aens name', 'not containing emoji', maybeName);
  }
  let punycode;
  try {
    const u = new URL(`http://${name}.${suffix}`);
    if (u.username + u.password + u.port + u.search + u.hash !== '' || u.pathname !== '/') {
      throw new ArgumentError('aens name', 'valid', maybeName);
    }
    punycode = u.host;
  } catch (error) {
    if (error instanceof TypeError && error.message.includes('Invalid URL')) {
      throw new ArgumentError('aens name', 'valid', maybeName);
    }
    throw error;
  }
  if (!/^[a-z0-9.-]+$/i.test(punycode)) {
    throw new ArgumentError('aens name', 'without illegal chars', maybeName);
  }
  if (punycode.length > 63 + AENS_SUFFIX.length) {
    throw new ArgumentError('aens name', 'not too long', maybeName);
  }
  return punycode;
}

/**
 * Encode an AENS name
 * @category AENS
 * @param name - Name to encode
 * @returns `nm_` prefixed encoded AENS name
 */
function produceNameId(name) {
  return encode(hash(nameToPunycode(name)), Encoding.Name);
}

/**
 * Generate the commitment hash by hashing the salt and
 * name, base 58 encoding the result and prepending 'cm_'
 * @category transaction builder
 * @param name - Name to be registered
 * @param salt - Random number
 * @returns Commitment hash
 */
function commitmentHash(name, salt = genSalt()) {
  return encode(hash(concatBuffers([Buffer.from(nameToPunycode(name)), Buffer.from(salt.toString(16).padStart(64, '0'), 'hex')])), Encoding.Commitment);
}

/**
 * Utility function to convert bytes to int
 * @category transaction builder
 * @param buf - Value
 * @returns Buffer Buffer from number(BigEndian)
 */
function readInt(buf = Buffer.from([])) {
  return new (external_bignumber_js_default())(Buffer.from(buf).toString('hex'), 16).toString(10);
}

/**
 * Ensure that name is valid AENS name, would throw an exception otherwise
 * @category AENS
 * @param name - AENS name
 */
function ensureName(maybeName) {
  nameToPunycode(maybeName);
}

/**
 * Is AENS name valid
 * @category AENS
 * @param name - AENS name
 */
// TODO: consider renaming to isName
function isNameValid(maybeName) {
  try {
    ensureName(maybeName);
    return true;
  } catch (error) {
    return false;
  }
}
const encodingToPointerKey = [[Encoding.AccountAddress, 'account_pubkey'], [Encoding.OracleAddress, 'oracle_pubkey'], [Encoding.ContractAddress, 'contract_pubkey'], [Encoding.Channel, 'channel']];

/**
 * @category AENS
 * @param identifier - account/oracle/contract address, or channel
 * @returns default AENS pointer key
 */
function getDefaultPointerKey(identifier) {
  var _encodingToPointerKey;
  decode(identifier);
  const encoding = identifier.substring(0, 2);
  const result = (_encodingToPointerKey = encodingToPointerKey.find(([e]) => e === encoding)) === null || _encodingToPointerKey === void 0 ? void 0 : _encodingToPointerKey[1];
  if (result != null) return result;
  throw new ArgumentError('identifier', `prefixed with one of ${encodingToPointerKey.map(([e]) => `${e}_`).join(', ')}`, identifier);
}

/**
 * Get the minimum AENS name fee
 * @category AENS
 * @param name - the AENS name to get the fee for
 * @returns the minimum fee for the AENS name auction
 */
function getMinimumNameFee(name) {
  const nameLength = nameToPunycode(name).length - AENS_SUFFIX.length;
  return NAME_BID_RANGES[Math.min(nameLength, NAME_MAX_LENGTH_FEE)];
}

/**
 * Compute bid fee for AENS auction
 * @category AENS
 * @param name - the AENS name to get the fee for
 * @param options - Options
 * @param options.startFee - Auction start fee
 * @param options.increment - Bid multiplier(In percentage, must be between 0 and 1)
 * @returns Bid fee
 */
function computeBidFee(name, {
  startFee,
  increment = NAME_FEE_BID_INCREMENT
} = {}) {
  if (!(Number(increment) === increment && increment % 1 !== 0)) throw new IllegalBidFeeError(`Increment must be float. Current increment ${increment}`);
  if (increment < NAME_FEE_BID_INCREMENT) throw new IllegalBidFeeError(`minimum increment percentage is ${NAME_FEE_BID_INCREMENT}`);
  // FIXME: increment should be used somehow here
  return ceil(new (external_bignumber_js_default())(startFee !== null && startFee !== void 0 ? startFee : getMinimumNameFee(name)).times(new (external_bignumber_js_default())(NAME_FEE_BID_INCREMENT).plus(1)));
}

/**
 * Compute auction end height
 * @category AENS
 * @param name - Name to compute auction end for
 * @param claimHeight - Auction starting height
 * @see {@link https://github.com/aeternity/aeternity/blob/72e440b8731422e335f879a31ecbbee7ac23a1cf/apps/aecore/src/aec_governance.erl#L273}
 * @returns Auction end height
 */
function computeAuctionEndBlock(name, claimHeight) {
  var _ref, _ref2, _ref3;
  const length = nameToPunycode(name).length - AENS_SUFFIX.length;
  const h = (_ref = (_ref2 = (_ref3 = length <= 4 ? 62 * NAME_BID_TIMEOUT_BLOCKS : null) !== null && _ref3 !== void 0 ? _ref3 : length <= 8 ? 31 * NAME_BID_TIMEOUT_BLOCKS : null) !== null && _ref2 !== void 0 ? _ref2 : length <= 12 ? NAME_BID_TIMEOUT_BLOCKS : null) !== null && _ref !== void 0 ? _ref : 0;
  return h + claimHeight;
}

/**
 * Is name accept going to auction
 * @category AENS
 */
function isAuctionName(name) {
  return nameToPunycode(name).length < 13 + AENS_SUFFIX.length;
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/u-int.ts



/* harmony default export */ const u_int = ({
  serialize(value) {
    if (Number(value) < 0) throw new ArgumentError('value', 'greater or equal to 0', value);
    return toBytes(value, true);
  },
  deserialize(value) {
    return readInt(value);
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/short-u-int.ts

/* harmony default export */ const short_u_int = ({
  serialize(value) {
    return u_int.serialize(value);
  },
  deserialize(value) {
    return +u_int.deserialize(value);
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/short-u-int-const.ts


function genShortUIntConstField(constValue, optional) {
  return {
    serialize(value) {
      if ((optional !== true || value != null) && value !== constValue) {
        throw new ArgumentError('ShortUIntConst', constValue, value);
      }
      return short_u_int.serialize(constValue);
    },
    deserialize(buf) {
      const value = short_u_int.deserialize(buf);
      if (value !== constValue) throw new ArgumentError('ShortUIntConst', constValue, value);
      return constValue;
    },
    constValue,
    constValueOptional: optional === true
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/address.ts





/**
 * Map of prefix to ID tag constant
 * @see {@link https://github.com/aeternity/protocol/blob/master/serializations.md#the-id-type}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_id.erl#L97-L102}
 * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L163-L168}
 */
const idTagToEncoding = [Encoding.AccountAddress, Encoding.Name, Encoding.Commitment, Encoding.OracleAddress, Encoding.ContractAddress, Encoding.Channel];
function genAddressField(...encodings) {
  return {
    /**
     * Utility function to create and _id type
     * @param hashId - Encoded hash
     * @returns Buffer Buffer with ID tag and decoded HASh
     */
    serialize(hashId) {
      const enc = hashId.slice(0, 2);
      if (!isItemOfArray(enc, idTagToEncoding)) throw new TagNotFoundError(enc);
      if (!isItemOfArray(enc, encodings)) {
        throw new ArgumentError('Address encoding', encodings.join(', '), enc);
      }
      const idTag = idTagToEncoding.indexOf(enc) + 1;
      return Buffer.from([...toBytes(idTag), ...decode(hashId)]);
    },
    /**
     * Utility function to read and _id type
     * @param buf - Data
     * @returns Encoded hash string with prefix
     */
    deserialize(buf) {
      const idTag = Buffer.from(buf).readUIntBE(0, 1);
      const enc = idTagToEncoding[idTag - 1];
      if (enc == null) throw new PrefixNotFoundError(idTag);
      if (!isItemOfArray(enc, encodings)) {
        throw new ArgumentError('Address encoding', encodings.join(', '), enc);
      }
      return encode(buf.subarray(1), enc);
    }
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/encoded.ts


function genEncodedField(encoding, optional) {
  return {
    serialize(encodedData) {
      if (encodedData == null) {
        if (optional === true) return Buffer.from([]);
        throw new ArgumentError('Encoded data', 'provided', encodedData);
      }
      return decode(encodedData);
    },
    deserialize(buffer) {
      return encode(buffer, encoding);
    }
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/raw.ts
/* harmony default export */ const raw = ({
  serialize(buffer) {
    return Buffer.from(buffer);
  },
  deserialize(buffer) {
    return buffer;
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/coin-amount.ts


/* harmony default export */ const coin_amount = ({
  ...u_int,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  serializeAettos(value, params) {
    return value !== null && value !== void 0 ? value : '0';
  },
  serialize(value, params, {
    denomination = AE_AMOUNT_FORMATS.AETTOS
  }) {
    return u_int.serialize(this.serializeAettos(value != null ? formatAmount(value, {
      denomination
    }) : value, params));
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/fee.ts






const BASE_GAS = 15000;
const GAS_PER_BYTE = 20;
const KEY_BLOCK_INTERVAL = 3;

/**
 * Calculate the Base fee gas
 * @see {@link https://github.com/aeternity/protocol/blob/master/consensus/README.md#gas}
 * @param txType - The transaction type
 * @returns The base fee
 * @example
 * ```js
 * TX_FEE_BASE('channelForceProgress') => new BigNumber(30 * 15000)
 * ```
 */
const TX_FEE_BASE_GAS = txType => {
  var _feeFactors;
  const feeFactors = {
    [Tag.ChannelForceProgressTx]: 30,
    [Tag.ChannelOffChainTx]: 0,
    [Tag.ChannelOffChainUpdateCallContract]: 0,
    [Tag.ChannelOffChainUpdateCreateContract]: 0,
    [Tag.ChannelOffChainUpdateDeposit]: 0,
    [Tag.ChannelOffChainUpdateWithdraw]: 0,
    [Tag.ChannelOffChainUpdateTransfer]: 0,
    [Tag.ContractCreateTx]: 5,
    [Tag.ContractCallTx]: 12,
    [Tag.GaAttachTx]: 5,
    [Tag.GaMetaTx]: 5,
    [Tag.PayingForTx]: 1 / 5
  };
  const factor = (_feeFactors = feeFactors[txType]) !== null && _feeFactors !== void 0 ? _feeFactors : 1;
  return new (external_bignumber_js_default())(factor * BASE_GAS);
};

/**
 * Calculate fee for Other types of transactions
 * @see {@link https://github.com/aeternity/protocol/blob/master/consensus/README.md#gas}
 * @param txType - The transaction type
 * @param txSize - The transaction size
 * @returns parameters - The transaction parameters
 * @returns parameters.relativeTtl - The relative ttl
 * @returns parameters.innerTxSize - The size of the inner transaction
 * @returns The Other fee
 * @example
 * ```js
 * TX_FEE_OTHER_GAS('oracleResponse',10, { relativeTtl: 10, innerTxSize: 10 })
 *  => new BigNumber(10).times(20).plus(Math.ceil(32000 * 10 / Math.floor(60 * 24 * 365 / 2)))
 * ```
 */
const TX_FEE_OTHER_GAS = (txType, txSize, {
  relativeTtl,
  innerTxSize
}) => {
  switch (txType) {
    case Tag.OracleRegisterTx:
    case Tag.OracleExtendTx:
    case Tag.OracleQueryTx:
    case Tag.OracleResponseTx:
      return new (external_bignumber_js_default())(txSize).times(GAS_PER_BYTE).plus(Math.ceil(32000 * relativeTtl / Math.floor(60 * 24 * 365 / KEY_BLOCK_INTERVAL)));
    case Tag.GaMetaTx:
    case Tag.PayingForTx:
      return new (external_bignumber_js_default())(txSize).minus(innerTxSize).times(GAS_PER_BYTE);
    default:
      return new (external_bignumber_js_default())(txSize).times(GAS_PER_BYTE);
  }
};
function getOracleRelativeTtl(params) {
  const ttlKeys = {
    [Tag.OracleRegisterTx]: 'oracleTtlValue',
    [Tag.OracleExtendTx]: 'oracleTtlValue',
    [Tag.OracleQueryTx]: 'queryTtlValue',
    [Tag.OracleResponseTx]: 'responseTtlValue'
  };
  const {
    tag
  } = params;
  if (!isKeyOfObject(tag, ttlKeys)) return 1;
  return params[ttlKeys[tag]];
}

/**
 * Calculate fee based on tx type and params
 */
function buildFee(builtTx, unpackTx, buildTx) {
  const {
    length
  } = decode(builtTx);
  const txObject = unpackTx(builtTx);
  let innerTxSize = 0;
  if (txObject.tag === Tag.GaMetaTx || txObject.tag === Tag.PayingForTx) {
    innerTxSize = decode(buildTx(txObject.tx.encodedTx)).length;
  }
  return TX_FEE_BASE_GAS(txObject.tag).plus(TX_FEE_OTHER_GAS(txObject.tag, length, {
    relativeTtl: getOracleRelativeTtl(txObject),
    innerTxSize
  })).times(MIN_GAS_PRICE);
}

/**
 * Calculate min fee
 * @category transaction builder
 * @param rebuildTx - Callback to get built transaction with specific fee
 */
function calculateMinFee(rebuildTx, unpackTx, buildTx) {
  let fee = new (external_bignumber_js_default())(0);
  let previousFee;
  do {
    previousFee = fee;
    fee = buildFee(rebuildTx(fee), unpackTx, buildTx);
  } while (!fee.eq(previousFee));
  return fee;
}
/* harmony default export */ const fee = ({
  ...coin_amount,
  serializeAettos(_value, {
    rebuildTx,
    unpackTx,
    buildTx,
    _computingMinFee,
    _pickBiggerFee
  }) {
    if (_computingMinFee != null) return _computingMinFee.toFixed();
    const minFee = calculateMinFee(fee => rebuildTx({
      _computingMinFee: fee
    }), unpackTx, buildTx);
    const value = new (external_bignumber_js_default())(_value !== null && _value !== void 0 ? _value : minFee);
    if (minFee.gt(value)) {
      if (_pickBiggerFee === true) return minFee.toFixed();
      throw new IllegalArgumentError(`Fee ${value.toString()} must be bigger than ${minFee}`);
    }
    return value.toFixed();
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/ttl.ts


/* harmony default export */ const ttl = ({
  ...short_u_int,
  serialize(value) {
    return short_u_int.serialize(value !== null && value !== void 0 ? value : 0);
  },
  async prepare(value, params,
  // TODO: { absoluteTtl: true } | { absoluteTtl: false, onNode: Node }
  {
    onNode,
    absoluteTtl
  }) {
    if (absoluteTtl !== true && value !== 0 && value != null) {
      if (onNode == null) throw new ArgumentError('onNode', 'provided', onNode);
      value += (await onNode.getCurrentKeyBlock()).height;
    }
    return value;
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/nonce.ts



function genNonceField(senderKey) {
  return {
    ...short_u_int,
    async prepare(value, params, options) {
      if (value != null) return value;
      const {
        onNode,
        strategy
      } = options;
      const senderId = options[senderKey];
      const requirement = 'provided (or provide `nonce` instead)';
      if (onNode == null) throw new ArgumentError('onNode', requirement, onNode);
      if (senderId == null) throw new ArgumentError('senderId', requirement, senderId);
      return (await onNode.getAccountNextNonce(senderId.replace(/^ok_/, 'ak_'), {
        strategy
      }).catch(error => {
        if (!isAccountNotFoundError(error)) throw error;
        return {
          nextNonce: 1
        };
      })).nextNonce;
    },
    senderKey
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/pointers.ts



const addressAny = genAddressField(...idTagToEncoding);

// TODO: remove after fixing node types

/* harmony default export */ const pointers = ({
  /**
   * Helper function to build pointers for name update TX
   * @param pointers - Array of pointers
   * `([ { key: 'account_pubkey', id: 'ak_32klj5j23k23j5423l434l2j3423'} ])`
   * @returns Serialized pointers array
   */
  serialize(pointers) {
    if (pointers.length > 32) {
      throw new IllegalArgumentError(`Expected 32 pointers or less, got ${pointers.length} instead`);
    }
    return pointers.map(pointer => [toBytes(pointer.key), addressAny.serialize(pointer.id)]);
  },
  /**
   * Helper function to read pointers from name update TX
   * @param pointers - Array of pointers
   * @returns Deserialize pointer array
   */
  deserialize(pointers) {
    return pointers.map(([key, id]) => ({
      key: key.toString(),
      id: addressAny.deserialize(id)
    }));
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/field.ts
/* harmony default export */ const field = ({
  serialize(value) {
    return Buffer.from(value);
  },
  deserialize(value) {
    return value.toString();
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/name.ts

/* harmony default export */ const field_types_name = ({
  /**
   * @param value - AENS name
   */
  serialize(value) {
    return field.serialize(value);
  },
  /**
   * @param value - AENS name
   */
  deserialize(value) {
    return field.deserialize(value);
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/name-fee.ts




/* harmony default export */ const name_fee = ({
  ...coin_amount,
  serializeAettos(_value, txFields) {
    const minNameFee = getMinimumNameFee(txFields.name);
    const value = new (external_bignumber_js_default())(_value !== null && _value !== void 0 ? _value : minNameFee);
    if (minNameFee.gt(value)) throw new InsufficientNameFeeError(value, minNameFee);
    return value.toFixed();
  },
  /**
   * @param value - AENS name fee Buffer
   * @param txFields - Transaction fields
   * @param txFields.name - AENS Name in transaction
   */
  serialize(value, txFields, parameters) {
    return coin_amount.serialize.call(this, value, txFields, parameters);
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/name-id.ts



const addressName = genAddressField(Encoding.Name);
/* harmony default export */ const name_id = ({
  ...addressName,
  /**
   * @param value - AENS name ID
   */
  serialize(value) {
    return addressName.serialize(isNameValid(value) ? produceNameId(value) : value);
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/boolean.ts
/* harmony default export */ const field_types_boolean = ({
  serialize(value) {
    return Buffer.from([value ? 1 : 0]);
  },
  deserialize(buffer) {
    return buffer[0] === 1;
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/deposit.ts


/* harmony default export */ const deposit = ({
  ...coin_amount,
  /**
   * @param value - Deposit value in string format. Should be equal to '0'.
   * @param options - Options
   * @param parameters - Parameters
   * @returns Deposit value Buffer.
   */
  serialize(value, options, parameters) {
    var _value;
    (_value = value) !== null && _value !== void 0 ? _value : value = 0;
    if (+value !== 0) throw new IllegalArgumentError(`Contract deposit is not refundable, so it should be equal 0, got ${value.toString()} instead`);
    return coin_amount.serialize(value, options, parameters);
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/gas-limit.ts




function calculateGasLimitMax(gasMax, rebuildTx, unpackTx, buildTx) {
  return gasMax - +buildFee(rebuildTx(gasMax), unpackTx, buildTx).dividedBy(MIN_GAS_PRICE);
}
/* harmony default export */ const gas_limit = ({
  ...short_u_int,
  serialize(_value, {
    tag,
    rebuildTx,
    unpackTx,
    buildTx,
    _computingGasLimit
  }, {
    gasMax = 6e6
  }) {
    if (_computingGasLimit != null) return short_u_int.serialize(_computingGasLimit);
    const gasLimitMax = tag === Tag.GaMetaTx ? MAX_AUTH_FUN_GAS : calculateGasLimitMax(gasMax, gasLimit => rebuildTx({
      _computingGasLimit: gasLimit,
      _pickBiggerFee: true
    }), unpackTx, buildTx);
    const value = _value !== null && _value !== void 0 ? _value : gasLimitMax;
    if (value > gasLimitMax) {
      throw new IllegalArgumentError(`Gas limit ${value} must be less or equal to ${gasLimitMax}`);
    }
    return short_u_int.serialize(value);
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/gas-price.ts



/* harmony default export */ const gas_price = ({
  ...coin_amount,
  serializeAettos(value = MIN_GAS_PRICE.toString()) {
    if (+value < MIN_GAS_PRICE) {
      throw new IllegalArgumentError(`Gas price ${value.toString()} must be bigger than ${MIN_GAS_PRICE}`);
    }
    return value;
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/abi-version.ts


/* harmony default export */ const abi_version = ({
  _getProtocolDetails(c, tag) {
    const kind = Tag.ContractCallTx === tag || Tag.GaMetaTx === tag ? 'contract-call' : 'oracle-call';
    return getProtocolDetails(c, kind).abiVersion;
  },
  serialize(value, {
    tag
  }, {
    consensusProtocolVersion = ConsensusProtocolVersion.Iris
  }) {
    const result = value !== null && value !== void 0 ? value : this._getProtocolDetails(consensusProtocolVersion, tag);
    return Buffer.from([result]);
  },
  async prepare(value, {
    tag
  },
  // TODO: { consensusProtocolVersion: ConsensusProtocolVersion } | { onNode: Node } | {}
  options) {
    if (value != null) return value;
    if (options.consensusProtocolVersion != null) return undefined;
    if (Object.keys(ConsensusProtocolVersion).length === 2) return undefined;
    if (options.onNode != null) {
      return this._getProtocolDetails((await options.onNode.getNodeInfo()).consensusProtocolVersion, tag);
    }
    return undefined;
  },
  deserialize(buffer) {
    return buffer[0];
  }
});
;// CONCATENATED MODULE: ./src/tx/builder/field-types/enumeration.ts


function genEnumerationField(enm) {
  const values = Object.values(enm).filter(v => typeof v === 'number');
  return {
    serialize(value) {
      if (typeof value !== 'number') throw new ArgumentError('value', 'to be a number', value);
      if (value > 0xff) throw new ArgumentError('value', 'to be less than 256', value);
      if (!isItemOfArray(value, values)) {
        throw new ArgumentError('value', 'to be a value of Enum', value);
      }
      return Buffer.from([value]);
    },
    deserialize(buffer) {
      if (buffer.length !== 1) {
        throw new ArgumentError('buffer', 'to have single element', buffer.length);
      }
      const value = buffer[0];
      if (!isItemOfArray(value, values)) {
        throw new ArgumentError('value', 'to be a value of Enum', value);
      }
      return value;
    }
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/string.ts

/* harmony default export */ const string = ({
  serialize(string) {
    return toBytes(string);
  },
  deserialize(buffer) {
    return buffer.toString();
  }
});
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/helpers/classPrivateFieldSet.js
var classPrivateFieldSet = __webpack_require__(719);
var classPrivateFieldSet_default = /*#__PURE__*/__webpack_require__.n(classPrivateFieldSet);
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/helpers/classPrivateFieldGet.js
var classPrivateFieldGet = __webpack_require__(7667);
var classPrivateFieldGet_default = /*#__PURE__*/__webpack_require__.n(classPrivateFieldGet);
;// CONCATENATED MODULE: ./src/tx/builder/field-types/mptree.ts


function _classPrivateMethodInitSpec(obj, privateSet) { _checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function _classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
function _classStaticPrivateMethodGet(receiver, classConstructor, method) { _classCheckPrivateStaticAccess(receiver, classConstructor); return method; }
function _classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }




var NodeType = /*#__PURE__*/function (NodeType) {
  NodeType[NodeType["Branch"] = 0] = "Branch";
  NodeType[NodeType["Extension"] = 1] = "Extension";
  NodeType[NodeType["Leaf"] = 2] = "Leaf";
  return NodeType;
}(NodeType || {});
var _rootHash = /*#__PURE__*/new WeakMap();
var _isComplete = /*#__PURE__*/new WeakMap();
var _nodes = /*#__PURE__*/new WeakMap();
var _encoding = /*#__PURE__*/new WeakMap();
var _tag = /*#__PURE__*/new WeakMap();
var _unpackTx = /*#__PURE__*/new WeakMap();
var _getRaw = /*#__PURE__*/new WeakSet();
var _entriesRaw = /*#__PURE__*/new WeakSet();
class MPTree {
  get isComplete() {
    return classPrivateFieldGet_default()(this, _isComplete);
  }
  /**
   * Deserialize Merkle Patricia Tree
   * @param binary - Binary
   * @param tag - Tag to use to decode value
   * @param unpTx - Implementation of unpackTx use to decode values
   * @returns Merkle Patricia Tree
   */
  constructor(binary, encoding, tag, unpTx) {
    _classPrivateMethodInitSpec(this, _entriesRaw);
    /**
     * Retrieve value from Merkle Patricia Tree
     * @param _key - The key of the element to retrieve
     * @returns Value associated to the specified key
     */
    _classPrivateMethodInitSpec(this, _getRaw);
    _classPrivateFieldInitSpec(this, _rootHash, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _isComplete, {
      writable: true,
      value: true
    });
    _classPrivateFieldInitSpec(this, _nodes, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _encoding, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _tag, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec(this, _unpackTx, {
      writable: true,
      value: void 0
    });
    classPrivateFieldSet_default()(this, _encoding, encoding);
    classPrivateFieldSet_default()(this, _tag, tag);
    classPrivateFieldSet_default()(this, _unpackTx, unpTx);
    classPrivateFieldSet_default()(this, _rootHash, binary[0].toString('hex'));
    classPrivateFieldSet_default()(this, _nodes, Object.fromEntries(binary[1].map(node => [node[0].toString('hex'), node[1]])));
    if (classPrivateFieldGet_default()(this, _nodes)[classPrivateFieldGet_default()(this, _rootHash)] == null) {
      if (Object.keys(classPrivateFieldGet_default()(this, _nodes)).length !== 0) {
        throw new MissingNodeInTreeError('Can\'t find a node by root hash');
      }
      classPrivateFieldSet_default()(this, _isComplete, false);
      return;
    }
    Object.entries(classPrivateFieldGet_default()(this, _nodes)).forEach(([key, node]) => {
      if (_classStaticPrivateMethodGet(MPTree, MPTree, _nodeHash).call(MPTree, node) !== key) throw new MerkleTreeHashMismatchError();
      const {
        type
      } = _classStaticPrivateMethodGet(MPTree, MPTree, _parseNode).call(MPTree, node);
      switch (type) {
        case NodeType.Branch:
          node.slice(0, 16).filter(n => n.length).forEach(n => {
            // TODO: enable after resolving https://github.com/aeternity/aeternity/issues/4066
            // if (n.length !== 32) {
            //   throw new ArgumentError('MPTree branch item length', 32, n.length);
            // }
            if (classPrivateFieldGet_default()(this, _nodes)[n.toString('hex')] == null) classPrivateFieldSet_default()(this, _isComplete, false);
          });
          break;
        case NodeType.Extension:
          if (classPrivateFieldGet_default()(this, _nodes)[node[1].toString('hex')] == null) {
            throw new MissingNodeInTreeError('Can\'t find a node by hash in extension node');
          }
          break;
        case NodeType.Leaf:
          break;
        default:
          throw new InternalError(`Unknown MPTree node type: ${type}`);
      }
    });
  }
  isEqual(tree) {
    return classPrivateFieldGet_default()(this, _rootHash) === classPrivateFieldGet_default()(tree, _rootHash);
  }
  /**
   * Serialize Merkle Patricia Tree
   * @returns Binary
   */
  serialize() {
    return [Buffer.from(classPrivateFieldGet_default()(this, _rootHash), 'hex'), Object.entries(classPrivateFieldGet_default()(this, _nodes)).map(([mptHash, value]) => [Buffer.from(mptHash, 'hex'), value])];
  }
  /**
   * Retrieve value from Merkle Patricia Tree
   * @param key - The key of the element to retrieve
   * @returns Value associated to the specified key
   */
  get(key) {
    const d = _classPrivateMethodGet(this, _getRaw, _getRaw2).call(this, decode(key).toString('hex'));
    if (d == null) return d;
    return classPrivateFieldGet_default()(this, _unpackTx).call(this, encode(d, Encoding.Transaction), classPrivateFieldGet_default()(this, _tag));
  }
  toObject() {
    return Object.fromEntries(_classPrivateMethodGet(this, _entriesRaw, _entriesRaw2).call(this) // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066
    .filter(([k]) => classPrivateFieldGet_default()(this, _encoding) !== Encoding.ContractAddress || k.length !== 66).map(([k, v]) => [encode(Buffer.from(k, 'hex'), classPrivateFieldGet_default()(this, _encoding)), classPrivateFieldGet_default()(this, _unpackTx).call(this, encode(v, Encoding.Transaction), classPrivateFieldGet_default()(this, _tag))]));
  }
}
function _nodeHash(node) {
  return Buffer.from(hash((0,external_rlp_.encode)(node))).toString('hex');
}
function _parseNode(node) {
  switch (node.length) {
    case 17:
      return {
        type: NodeType.Branch,
        ...(node[16].length !== 0 && {
          value: node[16]
        })
      };
    case 2:
      {
        const nibble = node[0][0] >> 4; // eslint-disable-line no-bitwise
        if (nibble > 3) throw new UnknownPathNibbleError(nibble);
        const type = nibble <= 1 ? NodeType.Extension : NodeType.Leaf;
        const slice = [0, 2].includes(nibble) ? 2 : 1;
        return {
          type,
          ...(type === NodeType.Leaf && {
            value: node[1]
          }),
          path: node[0].toString('hex').slice(slice)
        };
      }
    default:
      throw new UnknownNodeLengthError(node.length);
  }
}
function _getRaw2(_key) {
  let searchFrom = classPrivateFieldGet_default()(this, _rootHash);
  let key = _key;
  while (true) {
    // eslint-disable-line no-constant-condition
    const node = classPrivateFieldGet_default()(this, _nodes)[searchFrom];
    if (node == null) {
      if (!this.isComplete) return undefined;
      throw new InternalError('Can\'t find node in complete tree');
    }
    const {
      type,
      value,
      path
    } = _classStaticPrivateMethodGet(MPTree, MPTree, _parseNode).call(MPTree, node);
    switch (type) {
      case NodeType.Branch:
        if (key.length === 0) return value;
        searchFrom = node[+`0x${key[0]}`].toString('hex');
        key = key.substring(1);
        break;
      case NodeType.Extension:
        if (key.substring(0, path === null || path === void 0 ? void 0 : path.length) !== path) return undefined;
        searchFrom = node[1].toString('hex');
        key = key.substring(path.length);
        break;
      case NodeType.Leaf:
        if (path !== key) return undefined;
        return value;
      default:
        throw new InternalError(`Unknown MPTree node type: ${type}`);
    }
  }
}
function _entriesRaw2() {
  const entries = [];
  const rec = (searchFrom, key) => {
    const node = classPrivateFieldGet_default()(this, _nodes)[searchFrom];
    if (node == null) {
      if (!this.isComplete) return;
      throw new InternalError('Can\'t find node in complete tree');
    }
    const {
      type,
      value,
      path
    } = _classStaticPrivateMethodGet(MPTree, MPTree, _parseNode).call(MPTree, node);
    switch (type) {
      case NodeType.Branch:
        node.slice(0, 16).map((t, idx) => [t, idx]).filter(([t]) => t.length).forEach(([t, idx]) => rec(t.toString('hex'), key + idx.toString(16)));
        if (value != null) entries.push([key, value]);
        break;
      case NodeType.Extension:
        rec(node[1].toString('hex'), key + path);
        break;
      case NodeType.Leaf:
        if (value == null) throw new UnexpectedTsError();
        entries.push([key + path, value]);
        break;
      default:
        throw new InternalError(`Unknown MPTree node type: ${type}`);
    }
  };
  rec(classPrivateFieldGet_default()(this, _rootHash), '');
  return entries;
}
function genMPTreeField(encoding, tag) {
  return {
    serialize(value) {
      return value.serialize();
    },
    deserialize(value, {
      unpackTx
    }) {
      return new MPTree(value, encoding, tag, unpackTx);
    }
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/field-types/wrapped.ts

function genWrappedField(tag) {
  return {
    serialize(payload, {
      buildTx
    }) {
      return decode(buildTx({
        tag,
        payload
      }));
    },
    deserialize(buffer, {
      unpackTx
    }) {
      return unpackTx(encode(buffer, Encoding.Transaction), tag).payload;
    },
    recursiveType: true
  };
}
;// CONCATENATED MODULE: ./src/tx/builder/schema.ts
/**
 * Transaction Schema for TxBuilder
 */
// # RLP version number
// # https://github.com/aeternity/protocol/blob/master/serializations.md#binary-serialization





let ORACLE_TTL_TYPES = /*#__PURE__*/function (ORACLE_TTL_TYPES) {
  ORACLE_TTL_TYPES[ORACLE_TTL_TYPES["delta"] = 0] = "delta";
  ORACLE_TTL_TYPES[ORACLE_TTL_TYPES["block"] = 1] = "block";
  return ORACLE_TTL_TYPES;
}({});

// # ORACLE
const ORACLE_TTL = {
  type: ORACLE_TTL_TYPES.delta,
  value: 500
};
const QUERY_TTL = {
  type: ORACLE_TTL_TYPES.delta,
  value: 10
};
const RESPONSE_TTL = {
  type: ORACLE_TTL_TYPES.delta,
  value: 10
};
// # CONTRACT
const DRY_RUN_ACCOUNT = {
  pub: 'ak_11111111111111111111111111111111273Yts',
  amount: 100000000000000000000000000000000000n
};
let CallReturnType = /*#__PURE__*/function (CallReturnType) {
  CallReturnType[CallReturnType["Ok"] = 0] = "Ok";
  CallReturnType[CallReturnType["Error"] = 1] = "Error";
  CallReturnType[CallReturnType["Revert"] = 2] = "Revert";
  return CallReturnType;
}({});

// TODO: figure out how to omit overriding types of recursive fields

const entryAny = genEntryField();
const entrySignedTx = genEntryField(Tag.SignedTx);
const entryMtreeValueArray = genArrayField(genEntryField(Tag.MtreeValue));
const entryTreesPoi = genEntryField(Tag.TreesPoi);
const mapContracts = genMapField(Encoding.ContractAddress, Tag.Contract);
const mapAccounts = genMapField(Encoding.AccountAddress, Tag.Account);
const mapCalls = genMapField(Encoding.Bytearray, Tag.ContractCall);
const mapChannels = genMapField(Encoding.Channel, Tag.Channel);
const mapNames = genMapField(Encoding.Name, Tag.Name);
const mapOracles = genMapField(Encoding.OracleAddress, Tag.Oracle);

/**
 * @see {@link https://github.com/aeternity/protocol/blob/c007deeac4a01e401238412801ac7084ac72d60e/serializations.md#accounts-version-1-basic-accounts}
 */
const txSchema = [{
  tag: genShortUIntConstField(Tag.Account),
  version: genShortUIntConstField(1),
  nonce: short_u_int,
  balance: u_int
}, {
  tag: genShortUIntConstField(Tag.Account),
  version: genShortUIntConstField(2, true),
  flags: u_int,
  nonce: short_u_int,
  balance: u_int,
  gaContract: genAddressField(Encoding.ContractAddress, Encoding.Name),
  gaAuthFun: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.SignedTx),
  version: genShortUIntConstField(1, true),
  signatures: genArrayField(raw),
  encodedTx: entryAny
}, {
  tag: genShortUIntConstField(Tag.SpendTx),
  version: genShortUIntConstField(1, true),
  senderId: genAddressField(Encoding.AccountAddress),
  recipientId: genAddressField(Encoding.AccountAddress, Encoding.Name),
  amount: coin_amount,
  fee: fee,
  ttl: ttl,
  nonce: genNonceField('senderId'),
  payload: genEncodedField(Encoding.Bytearray, true)
}, {
  tag: genShortUIntConstField(Tag.Name),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nameTtl: short_u_int,
  status: raw,
  clientTtl: short_u_int,
  pointers: pointers
}, {
  tag: genShortUIntConstField(Tag.NamePreclaimTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  commitmentId: genAddressField(Encoding.Commitment),
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameClaimTx),
  version: genShortUIntConstField(2, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  name: field_types_name,
  nameSalt: u_int,
  nameFee: name_fee,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameUpdateTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  nameId: name_id,
  nameTtl: short_u_int,
  pointers: pointers,
  clientTtl: short_u_int,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameTransferTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  nameId: name_id,
  recipientId: genAddressField(Encoding.AccountAddress, Encoding.Name),
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.NameRevokeTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  nameId: name_id,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.Contract),
  version: genShortUIntConstField(1, true),
  owner: genAddressField(Encoding.AccountAddress),
  ctVersion: ct_version,
  code: genEncodedField(Encoding.ContractBytearray),
  log: genEncodedField(Encoding.ContractBytearray),
  active: field_types_boolean,
  referers: genArrayField(genAddressField(Encoding.AccountAddress)),
  deposit: deposit
}, {
  tag: genShortUIntConstField(Tag.ContractCreateTx),
  version: genShortUIntConstField(1, true),
  ownerId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('ownerId'),
  code: genEncodedField(Encoding.ContractBytearray),
  ctVersion: ct_version,
  fee: fee,
  ttl: ttl,
  deposit: deposit,
  amount: coin_amount,
  gasLimit: gas_limit,
  gasPrice: gas_price,
  callData: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.ContractCallTx),
  version: genShortUIntConstField(1, true),
  callerId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('callerId'),
  contractId: genAddressField(Encoding.ContractAddress, Encoding.Name),
  abiVersion: abi_version,
  fee: fee,
  ttl: ttl,
  amount: coin_amount,
  gasLimit: gas_limit,
  gasPrice: gas_price,
  callData: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.ContractCall),
  version: genShortUIntConstField(2, true),
  callerId: genAddressField(Encoding.AccountAddress),
  callerNonce: short_u_int,
  height: short_u_int,
  contractId: genAddressField(Encoding.ContractAddress),
  // TODO: rename after resolving https://github.com/aeternity/protocol/issues/506
  gasPrice: u_int,
  gasUsed: short_u_int,
  returnValue: genEncodedField(Encoding.ContractBytearray),
  returnType: genEnumerationField(CallReturnType),
  // TODO: add serialization for
  //  <log> :: [ { <address> :: id, [ <topics> :: binary() }, <data> :: binary() } ]
  log: genArrayField(raw)
}, {
  tag: genShortUIntConstField(Tag.Oracle),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  queryFormat: string,
  responseFormat: string,
  queryFee: coin_amount,
  oracleTtlValue: short_u_int,
  abiVersion: abi_version
}, {
  tag: genShortUIntConstField(Tag.OracleRegisterTx),
  version: genShortUIntConstField(1, true),
  accountId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('accountId'),
  queryFormat: string,
  responseFormat: string,
  queryFee: coin_amount,
  oracleTtlType: genEnumerationField(ORACLE_TTL_TYPES),
  oracleTtlValue: short_u_int,
  fee: fee,
  ttl: ttl,
  abiVersion: abi_version
}, {
  tag: genShortUIntConstField(Tag.OracleExtendTx),
  version: genShortUIntConstField(1, true),
  oracleId: genAddressField(Encoding.OracleAddress, Encoding.Name),
  nonce: genNonceField('oracleId'),
  oracleTtlType: genEnumerationField(ORACLE_TTL_TYPES),
  oracleTtlValue: short_u_int,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.OracleQueryTx),
  version: genShortUIntConstField(1, true),
  senderId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('senderId'),
  oracleId: genAddressField(Encoding.OracleAddress, Encoding.Name),
  query: string,
  queryFee: coin_amount,
  queryTtlType: genEnumerationField(ORACLE_TTL_TYPES),
  queryTtlValue: short_u_int,
  responseTtlType: genEnumerationField(ORACLE_TTL_TYPES),
  responseTtlValue: short_u_int,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.OracleResponseTx),
  version: genShortUIntConstField(1, true),
  oracleId: genAddressField(Encoding.OracleAddress),
  nonce: genNonceField('oracleId'),
  queryId: genEncodedField(Encoding.OracleQueryId),
  response: string,
  responseTtlType: genEnumerationField(ORACLE_TTL_TYPES),
  responseTtlValue: short_u_int,
  fee: fee,
  ttl: ttl
}, {
  tag: genShortUIntConstField(Tag.ChannelCreateTx),
  version: genShortUIntConstField(2, true),
  initiator: genAddressField(Encoding.AccountAddress),
  initiatorAmount: u_int,
  responder: genAddressField(Encoding.AccountAddress),
  responderAmount: u_int,
  channelReserve: u_int,
  lockPeriod: u_int,
  ttl: ttl,
  fee: fee,
  initiatorDelegateIds: genArrayField(genAddressField(...idTagToEncoding)),
  responderDelegateIds: genArrayField(genAddressField(...idTagToEncoding)),
  stateHash: genEncodedField(Encoding.State),
  nonce: genNonceField('initiator')
}, {
  tag: genShortUIntConstField(Tag.ChannelCloseMutualTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  initiatorAmountFinal: u_int,
  responderAmountFinal: u_int,
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelCloseSoloTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  payload: genEncodedField(Encoding.Transaction),
  poi: entryTreesPoi,
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelSlashTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  payload: genEncodedField(Encoding.Transaction),
  poi: entryTreesPoi,
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelDepositTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  amount: u_int,
  ttl: ttl,
  fee: fee,
  stateHash: genEncodedField(Encoding.State),
  round: short_u_int,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelWithdrawTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  toId: genAddressField(Encoding.AccountAddress),
  amount: u_int,
  ttl: ttl,
  fee: fee,
  stateHash: genEncodedField(Encoding.State),
  round: short_u_int,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelSettleTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  initiatorAmountFinal: u_int,
  responderAmountFinal: u_int,
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelForceProgressTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  payload: genEncodedField(Encoding.Transaction),
  round: short_u_int,
  update: genEncodedField(Encoding.ContractBytearray),
  stateHash: genEncodedField(Encoding.State),
  offChainTrees: genEncodedField(Encoding.StateTrees),
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelOffChainTx),
  version: genShortUIntConstField(2, true),
  channelId: genAddressField(Encoding.Channel),
  round: short_u_int,
  stateHash: genEncodedField(Encoding.State)
}, {
  tag: genShortUIntConstField(Tag.Channel),
  version: genShortUIntConstField(3, true),
  initiator: genAddressField(Encoding.AccountAddress),
  responder: genAddressField(Encoding.AccountAddress),
  channelAmount: u_int,
  initiatorAmount: u_int,
  responderAmount: u_int,
  channelReserve: u_int,
  initiatorDelegateIds: genArrayField(genAddressField(...idTagToEncoding)),
  responderDelegateIds: genArrayField(genAddressField(...idTagToEncoding)),
  stateHash: genEncodedField(Encoding.State),
  round: short_u_int,
  soloRound: u_int,
  lockPeriod: u_int,
  lockedUntil: u_int,
  initiatorAuth: genEncodedField(Encoding.ContractBytearray),
  responderAuth: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.ChannelSnapshotSoloTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  fromId: genAddressField(Encoding.AccountAddress),
  payload: genEncodedField(Encoding.Transaction),
  ttl: ttl,
  fee: fee,
  nonce: genNonceField('fromId')
}, {
  tag: genShortUIntConstField(Tag.ChannelOffChainUpdateTransfer),
  version: genShortUIntConstField(1, true),
  from: genAddressField(Encoding.AccountAddress),
  to: genAddressField(Encoding.AccountAddress),
  amount: u_int
}, {
  tag: genShortUIntConstField(Tag.ChannelOffChainUpdateDeposit),
  version: genShortUIntConstField(1, true),
  from: genAddressField(Encoding.AccountAddress),
  amount: u_int
}, {
  tag: genShortUIntConstField(Tag.ChannelOffChainUpdateWithdraw),
  version: genShortUIntConstField(1, true),
  from: genAddressField(Encoding.AccountAddress),
  amount: u_int
}, {
  tag: genShortUIntConstField(Tag.ChannelOffChainUpdateCreateContract),
  version: genShortUIntConstField(1, true),
  owner: genAddressField(Encoding.AccountAddress),
  ctVersion: ct_version,
  code: genEncodedField(Encoding.ContractBytearray),
  deposit: u_int,
  callData: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.ChannelOffChainUpdateCallContract),
  version: genShortUIntConstField(1, true),
  caller: genAddressField(Encoding.AccountAddress),
  contract: genAddressField(Encoding.ContractAddress),
  abiVersion: abi_version,
  amount: u_int,
  callData: genEncodedField(Encoding.ContractBytearray),
  callStack: raw,
  gasPrice: gas_price,
  gasLimit: gas_limit
}, {
  tag: genShortUIntConstField(Tag.ChannelClientReconnectTx),
  version: genShortUIntConstField(1, true),
  channelId: genAddressField(Encoding.Channel),
  round: short_u_int,
  role: string,
  pubkey: genAddressField(Encoding.AccountAddress)
}, {
  tag: genShortUIntConstField(Tag.TreesPoi),
  version: genShortUIntConstField(1, true),
  // TODO: inline an extra wrapping array after resolving https://github.com/aeternity/protocol/issues/505
  accounts: genArrayField(genMPTreeField(Encoding.AccountAddress, Tag.Account)),
  calls: genArrayField(genMPTreeField(Encoding.Bytearray, Tag.ContractCall)),
  channels: genArrayField(genMPTreeField(Encoding.Channel, Tag.Channel)),
  contracts: genArrayField(genMPTreeField(Encoding.ContractAddress, Tag.Contract)),
  ns: genArrayField(genMPTreeField(Encoding.Name, Tag.Name)),
  oracles: genArrayField(genMPTreeField(Encoding.OracleAddress, Tag.Oracle))
}, {
  tag: genShortUIntConstField(Tag.StateTrees),
  version: genShortUIntConstField(0, true),
  contracts: genWrappedField(Tag.ContractsMtree),
  calls: genWrappedField(Tag.CallsMtree),
  channels: genWrappedField(Tag.ChannelsMtree),
  ns: genWrappedField(Tag.NameserviceMtree),
  oracles: genWrappedField(Tag.OraclesMtree),
  accounts: genWrappedField(Tag.AccountsMtree)
}, {
  tag: genShortUIntConstField(Tag.Mtree),
  version: genShortUIntConstField(1, true),
  values: entryMtreeValueArray
}, {
  tag: genShortUIntConstField(Tag.MtreeValue),
  version: genShortUIntConstField(1, true),
  key: raw,
  value: raw
}, {
  tag: genShortUIntConstField(Tag.ContractsMtree),
  version: genShortUIntConstField(1, true),
  payload: mapContracts
}, {
  tag: genShortUIntConstField(Tag.CallsMtree),
  version: genShortUIntConstField(1, true),
  payload: mapCalls
}, {
  tag: genShortUIntConstField(Tag.ChannelsMtree),
  version: genShortUIntConstField(1, true),
  payload: mapChannels
}, {
  tag: genShortUIntConstField(Tag.NameserviceMtree),
  version: genShortUIntConstField(1, true),
  payload: mapNames
}, {
  tag: genShortUIntConstField(Tag.OraclesMtree),
  version: genShortUIntConstField(1, true),
  payload: mapOracles
}, {
  tag: genShortUIntConstField(Tag.AccountsMtree),
  version: genShortUIntConstField(1, true),
  payload: mapAccounts
}, {
  tag: genShortUIntConstField(Tag.GaAttachTx),
  version: genShortUIntConstField(1, true),
  ownerId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('ownerId'),
  code: genEncodedField(Encoding.ContractBytearray),
  authFun: raw,
  ctVersion: ct_version,
  fee: fee,
  ttl: ttl,
  gasLimit: gas_limit,
  gasPrice: gas_price,
  callData: genEncodedField(Encoding.ContractBytearray)
}, {
  tag: genShortUIntConstField(Tag.GaMetaTx),
  version: genShortUIntConstField(2, true),
  gaId: genAddressField(Encoding.AccountAddress),
  authData: genEncodedField(Encoding.ContractBytearray),
  abiVersion: abi_version,
  fee: fee,
  gasLimit: gas_limit,
  gasPrice: gas_price,
  tx: entrySignedTx
}, {
  tag: genShortUIntConstField(Tag.PayingForTx),
  version: genShortUIntConstField(1, true),
  payerId: genAddressField(Encoding.AccountAddress),
  nonce: genNonceField('payerId'),
  fee: fee,
  tx: entrySignedTx
}, {
  tag: genShortUIntConstField(Tag.GaMetaTxAuthData),
  version: genShortUIntConstField(1, true),
  fee: coin_amount,
  gasPrice: gas_price,
  txHash: genEncodedField(Encoding.TxHash)
}];
;// CONCATENATED MODULE: ./src/tx/builder/index.ts








/**
 * JavaScript-based Transaction builder
 */

function getSchema(tag, version) {
  var _version;
  const schemas = txSchema.filter(s => s.tag.constValue === tag);
  if (schemas.length === 0) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, 0);
  (_version = version) !== null && _version !== void 0 ? _version : version = Math.max(...schemas.map(schema => schema.version.constValue));
  const schema = schemas.find(s => s.version.constValue === version);
  if (schema == null) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, version);
  return Object.entries(schema);
}
/**
 * Build transaction hash
 * @category transaction builder
 * @param params - Object with tx params
 * @param options - options
 * @param options.prefix - Prefix of transaction
 * @returns object Base64Check transaction hash with 'tx_' prefix
 */
function buildTx(params, {
  prefix
} = {}) {
  const schema = getSchema(params.tag, params.version);
  const binary = schema.map(([key, field]) => field.serialize(
  // @ts-expect-error the type of `params[key]` can't be determined accurately
  params[key], {
    ...params,
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    unpackTx,
    buildTx,
    rebuildTx: overrideParams => buildTx({
      ...params,
      ...overrideParams
    })
  }, params));

  // @ts-expect-error looks like a TypeScript edge case
  return encode((0,external_rlp_.encode)(binary), prefix !== null && prefix !== void 0 ? prefix : Encoding.Transaction);
}
/**
 * @category transaction builder
 */
async function buildTxAsync(params) {
  await Promise.all(getSchema(params.tag, params.version).map(async ([key, field]) => {
    if (field.prepare == null) return;
    // @ts-expect-error the type of `params[key]` can't be determined accurately
    params[key] = await field.prepare(params[key], params, params);
  }));

  // @ts-expect-error after preparation properties should be compatible with sync tx builder
  return buildTx(params);
}

/**
 * Unpack transaction encoded as string
 * @category transaction builder
 * @param encodedTx - Transaction to unpack
 * @param txType - Expected transaction type
 * @returns Object with transaction param's
 */
function unpackTx(encodedTx, txType) {
  const binary = (0,external_rlp_.decode)(decode(encodedTx));
  const tag = +readInt(binary[0]);
  const version = +readInt(binary[1]);
  const schema = getSchema(tag, version);
  if (txType != null && txType !== tag) throw new DecodeError(`Expected transaction to have ${Tag[txType]} tag, got ${Tag[tag]} instead`);
  if (binary.length !== schema.length) {
    throw new ArgumentError('Transaction RLP length', schema.length, binary.length);
  }
  return schema.reduce((acc, [name, field], index) => {
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    const deserialized = field.deserialize(binary[index], {
      unpackTx
    });
    return {
      ...acc,
      [name]: deserialized
    };
  }, {});
}

/**
 * Build a transaction hash
 * @category transaction builder
 * @param rawTx - base64 or rlp encoded transaction
 * @returns Transaction hash
 */
function buildTxHash(rawTx) {
  const data = typeof rawTx === 'string' && rawTx.startsWith('tx_') ? decode(rawTx) : rawTx;
  return encode(hash(data), Encoding.TxHash);
}

/**
 * Build a contract public key by contractCreateTx or gaAttach
 * @category contract
 * @param contractTx - Transaction
 * @returns Contract public key
 */
function buildContractIdByContractTx(contractTx) {
  const params = unpackTx(contractTx);
  if (Tag.ContractCreateTx !== params.tag && Tag.GaAttachTx !== params.tag) {
    throw new ArgumentError('contractTx', 'a contractCreateTx or gaAttach', params.tag);
  }
  return buildContractId(params.ownerId, params.nonce);
}
;// CONCATENATED MODULE: ./src/utils/semver-satisfies.ts
function semverSatisfies(version, geVersion, ltVersion) {
  const getComponents = v => v.split(/[-+]/)[0].split('.').map(i => +i);
  const versionComponents = getComponents(version);
  const geComponents = getComponents(geVersion);
  const ltComponents = getComponents(ltVersion);
  const base = Math.max(...versionComponents, ...geComponents, ...ltComponents) + 1;
  const componentsToNumber = components => components.reverse().reduce((acc, n, idx) => acc + n * base ** idx, 0);
  const vNumber = componentsToNumber(versionComponents);
  const geNumber = componentsToNumber(geComponents);
  const ltNumber = componentsToNumber(ltComponents);
  return vNumber >= geNumber && vNumber < ltNumber;
}
;// CONCATENATED MODULE: ./src/utils/autorest.ts




const genRequestQueuesPolicy = () => {
  const requestQueues = new Map();
  return {
    policy: {
      name: 'request-queues',
      async sendRequest(request, next) {
        var _requestQueues$get;
        const key = request.headers.get('__queue');
        request.headers.delete('__queue');
        const getResponse = async () => next(request);
        if (key == null) return getResponse();
        const req = ((_requestQueues$get = requestQueues.get(key)) !== null && _requestQueues$get !== void 0 ? _requestQueues$get : Promise.resolve()).then(getResponse);
        // TODO: remove pause after fixing https://github.com/aeternity/aeternity/issues/3803
        // gap to ensure that node won't reject the nonce
        requestQueues.set(key, req.then(async () => pause(750), () => {}));
        return req;
      }
    },
    position: 'perCall'
  };
};
const genCombineGetRequestsPolicy = () => {
  const pendingGetRequests = new Map();
  return {
    policy: {
      name: 'combine-get-requests',
      async sendRequest(request, next) {
        var _pendingGetRequests$g;
        if (request.method !== 'GET') return next(request);
        const key = JSON.stringify([request.url, request.body]);
        const response = (_pendingGetRequests$g = pendingGetRequests.get(key)) !== null && _pendingGetRequests$g !== void 0 ? _pendingGetRequests$g : next(request);
        pendingGetRequests.set(key, response);
        try {
          return await response;
        } finally {
          pendingGetRequests.delete(key);
        }
      }
    },
    position: 'perCall'
  };
};
const genAggressiveCacheGetResponsesPolicy = () => {
  const getRequests = new Map();
  return {
    policy: {
      name: 'aggressive-cache-get-responses',
      async sendRequest(request, next) {
        var _getRequests$get;
        if (request.method !== 'GET') return next(request);
        const key = JSON.stringify([request.url, request.body]);
        const response = (_getRequests$get = getRequests.get(key)) !== null && _getRequests$get !== void 0 ? _getRequests$get : next(request);
        getRequests.set(key, response);
        return response;
      }
    },
    position: 'perCall'
  };
};
const genErrorFormatterPolicy = getMessage => ({
  policy: {
    name: 'error-formatter',
    async sendRequest(request, next) {
      try {
        return await next(request);
      } catch (error) {
        var _error$response;
        if (!(error instanceof core_rest_pipeline_.RestError) || error.request == null) throw error;
        if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.bodyAsText) == null) throw error;
        let body;
        try {
          body = JSON.parse(error.response.bodyAsText);
        } catch (e) {
          throw error;
        }
        error.message = `${new URL(error.request.url).pathname.slice(1)} error`;
        const message = getMessage(body);
        if (message !== '') error.message += `:${message}`;
        throw error;
      }
    }
  },
  position: 'perCall'
});
const genVersionCheckPolicy = (name, ignorePath, versionPromise, geVersion, ltVersion) => ({
  name: 'version-check',
  async sendRequest(request, next) {
    if (new URL(request.url).pathname === ignorePath) return next(request);
    const version = await versionPromise;
    if (version instanceof Error) throw version;
    const args = [version, geVersion, ltVersion];
    if (!semverSatisfies(...args)) throw new UnsupportedVersionError(name, ...args);
    return next(request);
  }
});
const genRetryOnFailurePolicy = (retryCount, retryOverallDelay) => ({
  policy: {
    name: 'retry-on-failure',
    async sendRequest(request, next) {
      const statusesToNotRetry = [200, 400, 403, 500];
      const intervals = new Array(retryCount).fill(0).map((_, idx) => ((idx + 1) / retryCount) ** 2);
      const intervalSum = intervals.reduce((a, b) => a + b);
      const intervalsInMs = intervals.map(el => el / intervalSum * retryOverallDelay);
      let error = new core_rest_pipeline_.RestError('Not expected to be thrown');
      for (let attempt = 0; attempt <= retryCount; attempt += 1) {
        if (attempt !== 0) await pause(intervalsInMs[attempt - 1]);
        try {
          return await next(request);
        } catch (e) {
          var _e$response$status, _e$response;
          if (!(e instanceof core_rest_pipeline_.RestError)) throw e;
          if (statusesToNotRetry.includes((_e$response$status = (_e$response = e.response) === null || _e$response === void 0 ? void 0 : _e$response.status) !== null && _e$response$status !== void 0 ? _e$response$status : 0)) throw e;
          error = e;
        }
      }
      throw error;
    }
  },
  position: 'perCall'
});
// EXTERNAL MODULE: external "@azure/core-client"
var core_client_ = __webpack_require__(4711);
;// CONCATENATED MODULE: ./src/apis/node/models/mappers.ts
const Header = {
  type: {
    name: "Composite",
    className: "Header",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        type: {
          name: "String"
        }
      },
      beneficiary: {
        serializedName: "beneficiary",
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        type: {
          name: "String"
        }
      },
      pow: {
        constraints: {
          MinItems: 42,
          MaxItems: 42
        },
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      info: {
        serializedName: "info",
        type: {
          name: "String"
        }
      },
      pofHash: {
        serializedName: "pof_hash",
        type: {
          name: "String"
        }
      },
      txsHash: {
        serializedName: "txs_hash",
        type: {
          name: "String"
        }
      },
      signature: {
        serializedName: "signature",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ErrorModel = {
  type: {
    name: "Composite",
    className: "ErrorModel",
    modelProperties: {
      reason: {
        serializedName: "reason",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const KeyBlock = {
  type: {
    name: "Composite",
    className: "KeyBlock",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        required: true,
        type: {
          name: "String"
        }
      },
      beneficiary: {
        serializedName: "beneficiary",
        required: true,
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        required: true,
        type: {
          name: "String"
        }
      },
      pow: {
        constraints: {
          MinItems: 42,
          MaxItems: 42
        },
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      info: {
        serializedName: "info",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const HashResponse = {
  type: {
    name: "Composite",
    className: "HashResponse",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const HeightResponse = {
  type: {
    name: "Composite",
    className: "HeightResponse",
    modelProperties: {
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const MicroBlockHeader = {
  type: {
    name: "Composite",
    className: "MicroBlockHeader",
    modelProperties: {
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      pofHash: {
        serializedName: "pof_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      txsHash: {
        serializedName: "txs_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      signature: {
        serializedName: "signature",
        required: true,
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        required: true,
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SignedTxs = {
  type: {
    name: "Composite",
    className: "SignedTxs",
    modelProperties: {
      transactions: {
        serializedName: "transactions",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SignedTx"
            }
          }
        }
      }
    }
  }
};
const SignedTx = {
  type: {
    name: "Composite",
    className: "SignedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "Tx"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "String"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      hash: {
        serializedName: "hash",
        required: true,
        type: {
          name: "String"
        }
      },
      signatures: {
        serializedName: "signatures",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const Tx = {
  serializedName: "Tx",
  type: {
    name: "Composite",
    className: "Tx",
    uberParent: "Tx",
    polymorphicDiscriminator: {
      serializedName: "type",
      clientName: "type"
    },
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        type: {
          name: "String"
        }
      },
      initiatorId: {
        serializedName: "initiator_id",
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        serializedName: "initiator_amount",
        type: {
          name: "String"
        }
      },
      responderId: {
        serializedName: "responder_id",
        type: {
          name: "String"
        }
      },
      responderAmount: {
        serializedName: "responder_amount",
        type: {
          name: "String"
        }
      },
      channelReserve: {
        serializedName: "channel_reserve",
        type: {
          name: "String"
        }
      },
      lockPeriod: {
        serializedName: "lock_period",
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      },
      channelId: {
        serializedName: "channel_id",
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        type: {
          name: "String"
        }
      },
      toId: {
        serializedName: "to_id",
        type: {
          name: "String"
        }
      },
      update: {
        serializedName: "update",
        type: {
          name: "Composite",
          className: "OffChainUpdate"
        }
      },
      offchainTrees: {
        serializedName: "offchain_trees",
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        serializedName: "initiator_amount_final",
        type: {
          name: "String"
        }
      },
      responderAmountFinal: {
        serializedName: "responder_amount_final",
        type: {
          name: "String"
        }
      },
      poi: {
        serializedName: "poi",
        type: {
          name: "String"
        }
      },
      initiatorDelegateIds: {
        serializedName: "initiator_delegate_ids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responderDelegateIds: {
        serializedName: "responder_delegate_ids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      queryFormat: {
        serializedName: "query_format",
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        type: {
          name: "String"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      accountId: {
        serializedName: "account_id",
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        type: {
          name: "String"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        type: {
          name: "String"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      queryId: {
        serializedName: "query_id",
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        type: {
          name: "String"
        }
      },
      commitmentId: {
        serializedName: "commitment_id",
        type: {
          name: "String"
        }
      },
      name: {
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      nameSalt: {
        serializedName: "name_salt",
        type: {
          name: "String"
        }
      },
      nameFee: {
        serializedName: "name_fee",
        type: {
          name: "String"
        }
      },
      nameId: {
        serializedName: "name_id",
        type: {
          name: "String"
        }
      },
      nameTtl: {
        serializedName: "name_ttl",
        type: {
          name: "String"
        }
      },
      pointers: {
        serializedName: "pointers",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      clientTtl: {
        serializedName: "client_ttl",
        type: {
          name: "String"
        }
      },
      ownerId: {
        serializedName: "owner_id",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        type: {
          name: "String"
        }
      },
      deposit: {
        serializedName: "deposit",
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        type: {
          name: "String"
        }
      },
      callerId: {
        serializedName: "caller_id",
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      authFun: {
        constraints: {
          Pattern: new RegExp("^(0x|0X)?[a-fA-F0-9]+$")
        },
        serializedName: "auth_fun",
        type: {
          name: "String"
        }
      },
      gaId: {
        serializedName: "ga_id",
        type: {
          name: "String"
        }
      },
      authData: {
        serializedName: "auth_data",
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      },
      payerId: {
        serializedName: "payer_id",
        type: {
          name: "String"
        }
      },
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["SpendTx", "ChannelCreateTx", "ChannelDepositTx", "ChannelWithdrawTx", "ChannelForceProgressTx", "ChannelCloseMutualTx", "ChannelCloseSoloTx", "ChannelSlashTx", "ChannelSettleTx", "ChannelSnapshotSoloTx", "ChannelSetDelegatesTx", "OracleRegisterTx", "OracleExtendTx", "OracleQueryTx", "OracleRespondTx", "NamePreclaimTx", "NameClaimTx", "NameUpdateTx", "NameTransferTx", "NameRevokeTx", "ContractCreateTx", "ContractCallTx", "GAAttachTx", "GAMetaTx", "PayingForTx"]
        }
      }
    }
  }
};
const Delegates = {
  type: {
    name: "Composite",
    className: "Delegates",
    modelProperties: {
      initiator: {
        serializedName: "initiator",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responder: {
        serializedName: "responder",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const OffChainUpdate = {
  type: {
    name: "Composite",
    className: "OffChainUpdate",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: {
      serializedName: "op",
      clientName: "op"
    },
    modelProperties: {
      op: {
        serializedName: "op",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const RelativeTTL = {
  type: {
    name: "Composite",
    className: "RelativeTTL",
    modelProperties: {
      type: {
        defaultValue: "delta",
        isConstant: true,
        serializedName: "type",
        type: {
          name: "String"
        }
      },
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Ttl = {
  type: {
    name: "Composite",
    className: "Ttl",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["delta", "block"]
        }
      },
      value: {
        serializedName: "value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NamePointer = {
  type: {
    name: "Composite",
    className: "NamePointer",
    modelProperties: {
      key: {
        serializedName: "key",
        required: true,
        type: {
          name: "String"
        }
      },
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const CountResponse = {
  type: {
    name: "Composite",
    className: "CountResponse",
    modelProperties: {
      count: {
        serializedName: "count",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Generation = {
  type: {
    name: "Composite",
    className: "Generation",
    modelProperties: {
      keyBlock: {
        serializedName: "key_block",
        type: {
          name: "Composite",
          className: "KeyBlock"
        }
      },
      microBlocks: {
        serializedName: "micro_blocks",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const Account = {
  type: {
    name: "Composite",
    className: "Account",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      balance: {
        serializedName: "balance",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      payable: {
        serializedName: "payable",
        type: {
          name: "Boolean"
        }
      },
      kind: {
        serializedName: "kind",
        type: {
          name: "Enum",
          allowedValues: ["basic", "generalized"]
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      authFun: {
        serializedName: "auth_fun",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NextNonceResponse = {
  type: {
    name: "Composite",
    className: "NextNonceResponse",
    modelProperties: {
      nextNonce: {
        serializedName: "next_nonce",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DryRunInput = {
  type: {
    name: "Composite",
    className: "DryRunInput",
    modelProperties: {
      top: {
        serializedName: "top",
        type: {
          name: "String"
        }
      },
      accounts: {
        serializedName: "accounts",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunAccount"
            }
          }
        }
      },
      txs: {
        serializedName: "txs",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunInputItem"
            }
          }
        }
      },
      txEvents: {
        defaultValue: false,
        serializedName: "tx_events",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const DryRunAccount = {
  type: {
    name: "Composite",
    className: "DryRunAccount",
    modelProperties: {
      pubKey: {
        serializedName: "pub_key",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DryRunInputItem = {
  type: {
    name: "Composite",
    className: "DryRunInputItem",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "String"
        }
      },
      callReq: {
        serializedName: "call_req",
        type: {
          name: "Composite",
          className: "DryRunCallReq"
        }
      }
    }
  }
};
const DryRunCallReq = {
  type: {
    name: "Composite",
    className: "DryRunCallReq",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      },
      contract: {
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        type: {
          name: "String"
        }
      },
      caller: {
        serializedName: "caller",
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        type: {
          name: "String"
        }
      },
      context: {
        serializedName: "context",
        type: {
          name: "Composite",
          className: "DryRunCallContext"
        }
      }
    }
  }
};
const DryRunCallContext = {
  type: {
    name: "Composite",
    className: "DryRunCallContext",
    modelProperties: {
      tx: {
        serializedName: "tx",
        type: {
          name: "String"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        type: {
          name: "String"
        }
      },
      stateful: {
        serializedName: "stateful",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
const DryRunResults = {
  type: {
    name: "Composite",
    className: "DryRunResults",
    modelProperties: {
      results: {
        serializedName: "results",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DryRunResult"
            }
          }
        }
      },
      txEvents: {
        serializedName: "tx_events",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      }
    }
  }
};
const DryRunResult = {
  type: {
    name: "Composite",
    className: "DryRunResult",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      },
      result: {
        serializedName: "result",
        required: true,
        type: {
          name: "String"
        }
      },
      reason: {
        serializedName: "reason",
        type: {
          name: "String"
        }
      },
      callObj: {
        serializedName: "call_obj",
        type: {
          name: "Composite",
          className: "ContractCallObject"
        }
      }
    }
  }
};
const ContractCallObject = {
  type: {
    name: "Composite",
    className: "ContractCallObject",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      callerNonce: {
        serializedName: "caller_nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      gasUsed: {
        serializedName: "gas_used",
        required: true,
        type: {
          name: "String"
        }
      },
      log: {
        serializedName: "log",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Event"
            }
          }
        }
      },
      returnValue: {
        serializedName: "return_value",
        required: true,
        type: {
          name: "String"
        }
      },
      returnType: {
        serializedName: "return_type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["ok", "error", "revert"]
        }
      }
    }
  }
};
const Event = {
  type: {
    name: "Composite",
    className: "Event",
    modelProperties: {
      address: {
        serializedName: "address",
        required: true,
        type: {
          name: "String"
        }
      },
      topics: {
        serializedName: "topics",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const TxInfoObject = {
  type: {
    name: "Composite",
    className: "TxInfoObject",
    modelProperties: {
      callInfo: {
        serializedName: "call_info",
        type: {
          name: "Composite",
          className: "ContractCallObject"
        }
      },
      gaInfo: {
        serializedName: "ga_info",
        type: {
          name: "Composite",
          className: "GAObject"
        }
      },
      txInfo: {
        serializedName: "tx_info",
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAObject = {
  type: {
    name: "Composite",
    className: "GAObject",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      gasUsed: {
        serializedName: "gas_used",
        required: true,
        type: {
          name: "String"
        }
      },
      returnValue: {
        serializedName: "return_value",
        required: true,
        type: {
          name: "String"
        }
      },
      returnType: {
        serializedName: "return_type",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["ok", "error"]
        }
      },
      innerObject: {
        serializedName: "inner_object",
        type: {
          name: "Composite",
          className: "TxInfoObject"
        }
      }
    }
  }
};
const EncodedTx = {
  type: {
    name: "Composite",
    className: "EncodedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PostTxResponse = {
  type: {
    name: "Composite",
    className: "PostTxResponse",
    modelProperties: {
      txHash: {
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ContractObject = {
  type: {
    name: "Composite",
    className: "ContractObject",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      active: {
        serializedName: "active",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      referrerIds: {
        serializedName: "referrer_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      deposit: {
        serializedName: "deposit",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ByteCode = {
  type: {
    name: "Composite",
    className: "ByteCode",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PoI = {
  type: {
    name: "Composite",
    className: "PoI",
    modelProperties: {
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const RegisteredOracle = {
  type: {
    name: "Composite",
    className: "RegisteredOracle",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFormat: {
        serializedName: "query_format",
        required: true,
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleQueries = {
  type: {
    name: "Composite",
    className: "OracleQueries",
    modelProperties: {
      oracleQueries: {
        serializedName: "oracle_queries",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "OracleQuery"
            }
          }
        }
      }
    }
  }
};
const OracleQuery = {
  type: {
    name: "Composite",
    className: "OracleQuery",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      senderNonce: {
        serializedName: "sender_nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameEntry = {
  type: {
    name: "Composite",
    className: "NameEntry",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      owner: {
        serializedName: "owner",
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      pointers: {
        serializedName: "pointers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      }
    }
  }
};
const Channel = {
  type: {
    name: "Composite",
    className: "Channel",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorId: {
        serializedName: "initiator_id",
        required: true,
        type: {
          name: "String"
        }
      },
      responderId: {
        serializedName: "responder_id",
        required: true,
        type: {
          name: "String"
        }
      },
      channelAmount: {
        serializedName: "channel_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        serializedName: "initiator_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmount: {
        serializedName: "responder_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      channelReserve: {
        serializedName: "channel_reserve",
        required: true,
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      },
      soloRound: {
        serializedName: "solo_round",
        required: true,
        type: {
          name: "String"
        }
      },
      lockPeriod: {
        serializedName: "lock_period",
        required: true,
        type: {
          name: "String"
        }
      },
      lockedUntil: {
        serializedName: "locked_until",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerPubKey = {
  type: {
    name: "Composite",
    className: "PeerPubKey",
    modelProperties: {
      pubkey: {
        serializedName: "pubkey",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Status = {
  type: {
    name: "Composite",
    className: "Status",
    modelProperties: {
      genesisKeyBlockHash: {
        serializedName: "genesis_key_block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      solutions: {
        serializedName: "solutions",
        required: true,
        type: {
          name: "String"
        }
      },
      difficulty: {
        serializedName: "difficulty",
        required: true,
        type: {
          name: "String"
        }
      },
      syncing: {
        serializedName: "syncing",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      syncProgress: {
        constraints: {
          InclusiveMaximum: 100,
          InclusiveMinimum: 0
        },
        serializedName: "sync_progress",
        type: {
          name: "Number"
        }
      },
      listening: {
        serializedName: "listening",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      protocols: {
        serializedName: "protocols",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Protocol"
            }
          }
        }
      },
      nodeVersion: {
        serializedName: "node_version",
        required: true,
        type: {
          name: "String"
        }
      },
      nodeRevision: {
        serializedName: "node_revision",
        required: true,
        type: {
          name: "String"
        }
      },
      peerCount: {
        serializedName: "peer_count",
        required: true,
        type: {
          name: "String"
        }
      },
      peerConnections: {
        serializedName: "peer_connections",
        type: {
          name: "Composite",
          className: "PeerConnections"
        }
      },
      pendingTransactionsCount: {
        serializedName: "pending_transactions_count",
        required: true,
        type: {
          name: "String"
        }
      },
      networkId: {
        serializedName: "network_id",
        required: true,
        type: {
          name: "String"
        }
      },
      peerPubkey: {
        serializedName: "peer_pubkey",
        required: true,
        type: {
          name: "String"
        }
      },
      topKeyBlockHash: {
        serializedName: "top_key_block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topBlockHeight: {
        serializedName: "top_block_height",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Protocol = {
  type: {
    name: "Composite",
    className: "Protocol",
    modelProperties: {
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      },
      effectiveAtHeight: {
        serializedName: "effective_at_height",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerConnections = {
  type: {
    name: "Composite",
    className: "PeerConnections",
    modelProperties: {
      inbound: {
        serializedName: "inbound",
        required: true,
        type: {
          name: "String"
        }
      },
      outbound: {
        serializedName: "outbound",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SpendTx = {
  type: {
    name: "Composite",
    className: "SpendTx",
    modelProperties: {
      recipientId: {
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleRegisterTx = {
  type: {
    name: "Composite",
    className: "OracleRegisterTx",
    modelProperties: {
      queryFormat: {
        serializedName: "query_format",
        required: true,
        type: {
          name: "String"
        }
      },
      responseFormat: {
        serializedName: "response_format",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          name: "String"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleExtendTx = {
  type: {
    name: "Composite",
    className: "OracleExtendTx",
    modelProperties: {
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      oracleTtl: {
        serializedName: "oracle_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleQueryTx = {
  type: {
    name: "Composite",
    className: "OracleQueryTx",
    modelProperties: {
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          name: "String"
        }
      },
      queryTtl: {
        serializedName: "query_ttl",
        type: {
          name: "Composite",
          className: "Ttl"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const OracleRespondTx = {
  type: {
    name: "Composite",
    className: "OracleRespondTx",
    modelProperties: {
      queryId: {
        serializedName: "query_id",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      },
      responseTtl: {
        serializedName: "response_ttl",
        type: {
          name: "Composite",
          className: "RelativeTTL"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      oracleId: {
        serializedName: "oracle_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NamePreclaimTx = {
  type: {
    name: "Composite",
    className: "NamePreclaimTx",
    modelProperties: {
      commitmentId: {
        serializedName: "commitment_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameClaimTx = {
  type: {
    name: "Composite",
    className: "NameClaimTx",
    modelProperties: {
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      nameSalt: {
        serializedName: "name_salt",
        required: true,
        type: {
          name: "String"
        }
      },
      nameFee: {
        serializedName: "name_fee",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameUpdateTx = {
  type: {
    name: "Composite",
    className: "NameUpdateTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nameTtl: {
        serializedName: "name_ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      pointers: {
        serializedName: "pointers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "NamePointer"
            }
          }
        }
      },
      clientTtl: {
        serializedName: "client_ttl",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameTransferTx = {
  type: {
    name: "Composite",
    className: "NameTransferTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      recipientId: {
        serializedName: "recipient_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameRevokeTx = {
  type: {
    name: "Composite",
    className: "NameRevokeTx",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const CommitmentId = {
  type: {
    name: "Composite",
    className: "CommitmentId",
    modelProperties: {
      commitmentId: {
        serializedName: "commitment_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameHash = {
  type: {
    name: "Composite",
    className: "NameHash",
    modelProperties: {
      nameId: {
        serializedName: "name_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelCreateTx = {
  type: {
    name: "Composite",
    className: "ChannelCreateTx",
    modelProperties: {
      initiatorId: {
        serializedName: "initiator_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        serializedName: "initiator_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      responderId: {
        serializedName: "responder_id",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmount: {
        serializedName: "responder_amount",
        required: true,
        type: {
          name: "String"
        }
      },
      channelReserve: {
        serializedName: "channel_reserve",
        required: true,
        type: {
          name: "String"
        }
      },
      lockPeriod: {
        serializedName: "lock_period",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Composite",
          className: "Delegates"
        }
      }
    }
  }
};
const ChannelDepositTx = {
  type: {
    name: "Composite",
    className: "ChannelDepositTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelWithdrawTx = {
  type: {
    name: "Composite",
    className: "ChannelWithdrawTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      toId: {
        serializedName: "to_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelForceProgressTx = {
  type: {
    name: "Composite",
    className: "ChannelForceProgressTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      },
      update: {
        serializedName: "update",
        type: {
          name: "Composite",
          className: "OffChainUpdate"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      offchainTrees: {
        serializedName: "offchain_trees",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelCloseMutualTx = {
  type: {
    name: "Composite",
    className: "ChannelCloseMutualTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        serializedName: "initiator_amount_final",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmountFinal: {
        serializedName: "responder_amount_final",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelCloseSoloTx = {
  type: {
    name: "Composite",
    className: "ChannelCloseSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSlashTx = {
  type: {
    name: "Composite",
    className: "ChannelSlashTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      poi: {
        serializedName: "poi",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSettleTx = {
  type: {
    name: "Composite",
    className: "ChannelSettleTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorAmountFinal: {
        serializedName: "initiator_amount_final",
        required: true,
        type: {
          name: "String"
        }
      },
      responderAmountFinal: {
        serializedName: "responder_amount_final",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSnapshotSoloTx = {
  type: {
    name: "Composite",
    className: "ChannelSnapshotSoloTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ChannelSetDelegatesTx = {
  type: {
    name: "Composite",
    className: "ChannelSetDelegatesTx",
    modelProperties: {
      channelId: {
        serializedName: "channel_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fromId: {
        serializedName: "from_id",
        required: true,
        type: {
          name: "String"
        }
      },
      initiatorDelegateIds: {
        serializedName: "initiator_delegate_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      responderDelegateIds: {
        serializedName: "responder_delegate_ids",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      stateHash: {
        serializedName: "state_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      round: {
        serializedName: "round",
        required: true,
        type: {
          name: "String"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      }
    }
  }
};
const PubKey = {
  type: {
    name: "Composite",
    className: "PubKey",
    modelProperties: {
      pubKey: {
        serializedName: "pub_key",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerDetails = {
  type: {
    name: "Composite",
    className: "PeerDetails",
    modelProperties: {
      host: {
        serializedName: "host",
        required: true,
        type: {
          name: "String"
        }
      },
      port: {
        serializedName: "port",
        required: true,
        type: {
          name: "String"
        }
      },
      firstSeen: {
        serializedName: "first_seen",
        required: true,
        type: {
          name: "String"
        }
      },
      lastSeen: {
        serializedName: "last_seen",
        required: true,
        type: {
          name: "String"
        }
      },
      genesisHash: {
        serializedName: "genesis_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topHash: {
        serializedName: "top_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      topDifficulty: {
        serializedName: "top_difficulty",
        required: true,
        type: {
          name: "String"
        }
      },
      networkId: {
        serializedName: "network_id",
        type: {
          name: "String"
        }
      },
      nodeVersion: {
        serializedName: "node_version",
        type: {
          name: "String"
        }
      },
      nodeRevision: {
        serializedName: "node_revision",
        type: {
          name: "String"
        }
      },
      nodeVendor: {
        serializedName: "node_vendor",
        type: {
          name: "String"
        }
      },
      nodeOs: {
        serializedName: "node_os",
        type: {
          name: "String"
        }
      }
    }
  }
};
const Peers = {
  type: {
    name: "Composite",
    className: "Peers",
    modelProperties: {
      peers: {
        serializedName: "peers",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      blocked: {
        serializedName: "blocked",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const PeerCount = {
  type: {
    name: "Composite",
    className: "PeerCount",
    modelProperties: {
      connected: {
        serializedName: "connected",
        type: {
          name: "Composite",
          className: "PeerCountConnected"
        }
      },
      available: {
        serializedName: "available",
        type: {
          name: "Composite",
          className: "PeerCountAvailable"
        }
      },
      blocked: {
        serializedName: "blocked",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerCountConnected = {
  type: {
    name: "Composite",
    className: "PeerCountConnected",
    modelProperties: {
      inbound: {
        serializedName: "inbound",
        type: {
          name: "String"
        }
      },
      outbound: {
        serializedName: "outbound",
        type: {
          name: "String"
        }
      }
    }
  }
};
const PeerCountAvailable = {
  type: {
    name: "Composite",
    className: "PeerCountAvailable",
    modelProperties: {
      verified: {
        serializedName: "verified",
        type: {
          name: "String"
        }
      },
      unverified: {
        serializedName: "unverified",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ContractCreateTx = {
  type: {
    name: "Composite",
    className: "ContractCreateTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      deposit: {
        serializedName: "deposit",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ContractCallTx = {
  type: {
    name: "Composite",
    className: "ContractCallTx",
    modelProperties: {
      callerId: {
        serializedName: "caller_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const UnsignedTx = {
  type: {
    name: "Composite",
    className: "UnsignedTx",
    modelProperties: {
      tx: {
        serializedName: "tx",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const TokenSupply = {
  type: {
    name: "Composite",
    className: "TokenSupply",
    modelProperties: {
      accounts: {
        serializedName: "accounts",
        type: {
          name: "String"
        }
      },
      contracts: {
        serializedName: "contracts",
        type: {
          name: "String"
        }
      },
      contractOracles: {
        serializedName: "contract_oracles",
        type: {
          name: "String"
        }
      },
      locked: {
        serializedName: "locked",
        type: {
          name: "String"
        }
      },
      oracles: {
        serializedName: "oracles",
        type: {
          name: "String"
        }
      },
      oracleQueries: {
        serializedName: "oracle_queries",
        type: {
          name: "String"
        }
      },
      pendingRewards: {
        serializedName: "pending_rewards",
        type: {
          name: "String"
        }
      },
      total: {
        serializedName: "total",
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAAttachTx = {
  type: {
    name: "Composite",
    className: "GAAttachTx",
    modelProperties: {
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      },
      authFun: {
        constraints: {
          Pattern: new RegExp("^(0x|0X)?[a-fA-F0-9]+$")
        },
        serializedName: "auth_fun",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const GAMetaTx = {
  type: {
    name: "Composite",
    className: "GAMetaTx",
    modelProperties: {
      gaId: {
        serializedName: "ga_id",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      ttl: {
        serializedName: "ttl",
        type: {
          name: "String"
        }
      },
      authData: {
        serializedName: "auth_data",
        required: true,
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      }
    }
  }
};
const PayingForTx = {
  type: {
    name: "Composite",
    className: "PayingForTx",
    modelProperties: {
      payerId: {
        serializedName: "payer_id",
        required: true,
        type: {
          name: "String"
        }
      },
      fee: {
        serializedName: "fee",
        required: true,
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Composite",
          className: "SignedTx"
        }
      }
    }
  }
};
const CheckTxInPoolResponse = {
  type: {
    name: "Composite",
    className: "CheckTxInPoolResponse",
    modelProperties: {
      status: {
        serializedName: "status",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainTransfer = {
  serializedName: "OffChainTransfer",
  type: {
    name: "Composite",
    className: "OffChainTransfer",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      from: {
        serializedName: "from",
        required: true,
        type: {
          name: "String"
        }
      },
      to: {
        serializedName: "to",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainWithdrawal = {
  serializedName: "OffChainWithdrawal",
  type: {
    name: "Composite",
    className: "OffChainWithdrawal",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      to: {
        serializedName: "to",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainDeposit = {
  serializedName: "OffChainDeposit",
  type: {
    name: "Composite",
    className: "OffChainDeposit",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      from: {
        serializedName: "from",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainNewContract = {
  serializedName: "OffChainNewContract",
  type: {
    name: "Composite",
    className: "OffChainNewContract",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      owner: {
        serializedName: "owner",
        required: true,
        type: {
          name: "String"
        }
      },
      vmVersion: {
        serializedName: "vm_version",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      code: {
        serializedName: "code",
        type: {
          name: "Composite",
          className: "ByteCode"
        }
      },
      deposit: {
        serializedName: "deposit",
        required: true,
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const OffChainCallContract = {
  serializedName: "OffChainCallContract",
  type: {
    name: "Composite",
    className: "OffChainCallContract",
    uberParent: "OffChainUpdate",
    polymorphicDiscriminator: OffChainUpdate.type.polymorphicDiscriminator,
    modelProperties: {
      ...OffChainUpdate.type.modelProperties,
      caller: {
        serializedName: "caller",
        required: true,
        type: {
          name: "String"
        }
      },
      contract: {
        serializedName: "contract",
        required: true,
        type: {
          name: "String"
        }
      },
      abiVersion: {
        serializedName: "abi_version",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "String"
        }
      },
      gas: {
        serializedName: "gas",
        required: true,
        type: {
          name: "String"
        }
      },
      gasPrice: {
        serializedName: "gas_price",
        required: true,
        type: {
          name: "String"
        }
      },
      callData: {
        serializedName: "call_data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const CreateContractUnsignedTx = {
  type: {
    name: "Composite",
    className: "CreateContractUnsignedTx",
    modelProperties: {
      ...UnsignedTx.type.modelProperties,
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
let discriminators = {
  "Tx.Tx": Tx,
  OffChainUpdate: OffChainUpdate,
  "OffChainUpdate.OffChainTransfer": OffChainTransfer,
  "OffChainUpdate.OffChainWithdrawal": OffChainWithdrawal,
  "OffChainUpdate.OffChainDeposit": OffChainDeposit,
  "OffChainUpdate.OffChainNewContract": OffChainNewContract,
  "OffChainUpdate.OffChainCallContract": OffChainCallContract
};
;// CONCATENATED MODULE: ./src/apis/node/models/parameters.ts

const accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
const $host = {
  parameterPath: "$host",
  mapper: {
    serializedName: "$host",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
const intAsString = {
  parameterPath: "intAsString",
  mapper: {
    defaultValue: false,
    serializedName: "int-as-string",
    type: {
      name: "Boolean"
    }
  }
};
const parameters_hash = {
  parameterPath: "hash",
  mapper: {
    serializedName: "hash",
    required: true,
    type: {
      name: "String"
    }
  }
};
const height = {
  parameterPath: "height",
  mapper: {
    constraints: {
      InclusiveMaximum: 18446744073709552000,
      InclusiveMinimum: 0
    },
    serializedName: "height",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const index = {
  parameterPath: "index",
  mapper: {
    constraints: {
      InclusiveMinimum: 1
    },
    serializedName: "index",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const pubkey = {
  parameterPath: "pubkey",
  mapper: {
    serializedName: "pubkey",
    required: true,
    type: {
      name: "String"
    }
  }
};
const strategy = {
  parameterPath: ["options", "strategy"],
  mapper: {
    defaultValue: "max",
    serializedName: "strategy",
    type: {
      name: "Enum",
      allowedValues: ["max", "continuity"]
    }
  }
};
const contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
const body = {
  parameterPath: "body",
  mapper: DryRunInput
};
const body1 = {
  parameterPath: "body",
  mapper: EncodedTx
};
const from = {
  parameterPath: ["options", "from"],
  mapper: {
    serializedName: "from",
    type: {
      name: "String"
    }
  }
};
const limit = {
  parameterPath: ["options", "limit"],
  mapper: {
    defaultValue: 20,
    constraints: {
      InclusiveMaximum: 1000,
      InclusiveMinimum: 1
    },
    serializedName: "limit",
    type: {
      name: "Number"
    }
  }
};
const type = {
  parameterPath: ["options", "type"],
  mapper: {
    defaultValue: "all",
    serializedName: "type",
    type: {
      name: "Enum",
      allowedValues: ["open", "closed", "all"]
    }
  }
};
const queryId = {
  parameterPath: "queryId",
  mapper: {
    serializedName: "query-id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const parameters_name = {
  parameterPath: "name",
  mapper: {
    serializedName: "name",
    required: true,
    type: {
      name: "String"
    }
  }
};
;// CONCATENATED MODULE: ./src/apis/node/node.ts



class Node extends core_client_.ServiceClient {
  /**
   * Initializes a new instance of the Node class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint;
    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-node/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      endpoint: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);
    // Parameter assignments
    this.$host = $host;
  }

  /**
   * Get the top header (either key or micro block)
   * @param options The options parameters.
   */
  getTopHeader(options) {
    return this.sendOperationRequest({
      options
    }, getTopHeaderOperationSpec);
  }

  /**
   * Get the current key block
   * @param options The options parameters.
   */
  getCurrentKeyBlock(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockOperationSpec);
  }

  /**
   * Get the hash of the current key block
   * @param options The options parameters.
   */
  getCurrentKeyBlockHash(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockHashOperationSpec);
  }

  /**
   * Get the height of the current key block
   * @param options The options parameters.
   */
  getCurrentKeyBlockHeight(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentKeyBlockHeightOperationSpec);
  }

  /**
   * Get the pending key block
   * @param options The options parameters.
   */
  getPendingKeyBlock(options) {
    return this.sendOperationRequest({
      options
    }, getPendingKeyBlockOperationSpec);
  }

  /**
   * Get a key block by hash
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */
  getKeyBlockByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getKeyBlockByHashOperationSpec);
  }

  /**
   * Get a key block by height
   * @param height The height
   * @param options The options parameters.
   */
  getKeyBlockByHeight(height, options) {
    return this.sendOperationRequest({
      height,
      options
    }, getKeyBlockByHeightOperationSpec);
  }

  /**
   * Get a micro block header by hash
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */
  getMicroBlockHeaderByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockHeaderByHashOperationSpec);
  }

  /**
   * Get micro block transactions by hash
   * @param hash The hash of the micro block
   * @param options The options parameters.
   */
  getMicroBlockTransactionsByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockTransactionsByHashOperationSpec);
  }

  /**
   * Get a micro block transaction by hash and index
   * @param hash The hash of the micro block
   * @param index The index of the transaction in a block
   * @param options The options parameters.
   */
  getMicroBlockTransactionByHashAndIndex(hash, index, options) {
    return this.sendOperationRequest({
      hash,
      index,
      options
    }, getMicroBlockTransactionByHashAndIndexOperationSpec);
  }

  /**
   * Get micro block transaction count by hash
   * @param hash The hash of the micro block
   * @param options The options parameters.
   */
  getMicroBlockTransactionsCountByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockTransactionsCountByHashOperationSpec);
  }

  /**
   * Get the current generation
   * @param options The options parameters.
   */
  getCurrentGeneration(options) {
    return this.sendOperationRequest({
      options
    }, getCurrentGenerationOperationSpec);
  }

  /**
   * Get a generation by hash
   * @param hash The hash of the key block
   * @param options The options parameters.
   */
  getGenerationByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getGenerationByHashOperationSpec);
  }

  /**
   * Get a generation by height
   * @param height The height
   * @param options The options parameters.
   */
  getGenerationByHeight(height, options) {
    return this.sendOperationRequest({
      height,
      options
    }, getGenerationByHeightOperationSpec);
  }

  /**
   * Get an account by public key
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */
  getAccountByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getAccountByPubkeyOperationSpec);
  }

  /**
   * Get an account by public key after the opening key block of the generation at height
   * @param pubkey The public key of the account
   * @param height The height
   * @param options The options parameters.
   */
  getAccountByPubkeyAndHeight(pubkey, height, options) {
    return this.sendOperationRequest({
      pubkey,
      height,
      options
    }, getAccountByPubkeyAndHeightOperationSpec);
  }

  /**
   * Get an account by public key after the block indicated by hash. Can be either a micro block or a
   * keyblock hash
   * @param pubkey The public key of the account
   * @param hash The hash of the block - either a keyblock or a microblock
   * @param options The options parameters.
   */
  getAccountByPubkeyAndHash(pubkey, hash, options) {
    return this.sendOperationRequest({
      pubkey,
      hash,
      options
    }, getAccountByPubkeyAndHashOperationSpec);
  }

  /**
   * Get pending account transactions by public key
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */
  getPendingAccountTransactionsByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getPendingAccountTransactionsByPubkeyOperationSpec);
  }

  /**
   * Get an account's next nonce; This is computed according to whatever is the current account nonce and
   * what transactions are currently present in the transaction pool
   * @param pubkey The public key of the account
   * @param options The options parameters.
   */
  getAccountNextNonce(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getAccountNextNonceOperationSpec);
  }

  /**
   * Dry-run transactions on top of a given block. Supports all TXs except GAMetaTx, PayingForTx and
   * OffchainTx. The maximum gas limit of all calls is capped. The maximum gas limit per request is a
   * global node setting. Since DryRunCallReq object do not have a mandatory gas field, if not set a
   * default value of 1000000 is being used instead.
   * @param body transactions
   * @param options The options parameters.
   */
  protectedDryRunTxs(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, protectedDryRunTxsOperationSpec);
  }

  /**
   * Get a transaction by hash
   * @param hash The hash of the transaction
   * @param options The options parameters.
   */
  getTransactionByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getTransactionByHashOperationSpec);
  }

  /**
   * @param hash The hash of the transaction
   * @param options The options parameters.
   */
  getTransactionInfoByHash(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getTransactionInfoByHashOperationSpec);
  }

  /**
   * Post a new transaction
   * @param body The new transaction
   * @param options The options parameters.
   */
  postTransaction(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, postTransactionOperationSpec);
  }

  /**
   * Get a contract by pubkey
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */
  getContract(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractOperationSpec);
  }

  /**
   * Get contract code by pubkey
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */
  getContractCode(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractCodeOperationSpec);
  }

  /**
   * Get a proof of inclusion for a contract
   * @param pubkey Contract pubkey to get proof for
   * @param options The options parameters.
   */
  getContractPoI(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getContractPoIOperationSpec);
  }

  /**
   * Get an oracle by public key
   * @param pubkey The public key of the oracle
   * @param options The options parameters.
   */
  getOracleByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getOracleByPubkeyOperationSpec);
  }

  /**
   * Get oracle queries by public key
   * @param pubkey The public key of the oracle
   * @param options The options parameters.
   */
  getOracleQueriesByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getOracleQueriesByPubkeyOperationSpec);
  }

  /**
   * Get an oracle query by public key and query ID
   * @param pubkey The public key of the oracle
   * @param queryId The ID of the query
   * @param options The options parameters.
   */
  getOracleQueryByPubkeyAndQueryId(pubkey, queryId, options) {
    return this.sendOperationRequest({
      pubkey,
      queryId,
      options
    }, getOracleQueryByPubkeyAndQueryIdOperationSpec);
  }

  /**
   * Get name entry from naming system
   * @param name The name key of the name entry
   * @param options The options parameters.
   */
  getNameEntryByName(name, options) {
    return this.sendOperationRequest({
      name,
      options
    }, getNameEntryByNameOperationSpec);
  }

  /**
   * Get channel by public key
   * @param pubkey The pubkey of the channel
   * @param options The options parameters.
   */
  getChannelByPubkey(pubkey, options) {
    return this.sendOperationRequest({
      pubkey,
      options
    }, getChannelByPubkeyOperationSpec);
  }

  /**
   * Get peer public key
   * @param options The options parameters.
   */
  getPeerPubkey(options) {
    return this.sendOperationRequest({
      options
    }, getPeerPubkeyOperationSpec);
  }

  /**
   * Get the status of a node
   * @param options The options parameters.
   */
  getStatus(options) {
    return this.sendOperationRequest({
      options
    }, getStatusOperationSpec);
  }

  /**
   * Get oldest keyblock hashes counting from genesis including orphans
   * @param options The options parameters.
   */
  getChainEnds(options) {
    return this.sendOperationRequest({
      options
    }, getChainEndsOperationSpec);
  }
}
// Operation Specifications
const serializer = core_client_.createSerializer(mappers_namespaceObject, /* isXml */false);
const getTopHeaderOperationSpec = {
  path: "/v3/headers/top",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Header
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockOperationSpec = {
  path: "/v3/key-blocks/current",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockHashOperationSpec = {
  path: "/v3/key-blocks/current/hash",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: HashResponse
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getCurrentKeyBlockHeightOperationSpec = {
  path: "/v3/key-blocks/current/height",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: HeightResponse
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getPendingKeyBlockOperationSpec = {
  path: "/v3/key-blocks/pending",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getKeyBlockByHashOperationSpec = {
  path: "/v3/key-blocks/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getKeyBlockByHeightOperationSpec = {
  path: "/v3/key-blocks/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: KeyBlock
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, height],
  headerParameters: [accept],
  serializer
};
const getMicroBlockHeaderByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/header",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: MicroBlockHeader
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionsByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTxs
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionByHashAndIndexOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions/index/{index}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTx
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash, index],
  headerParameters: [accept],
  serializer
};
const getMicroBlockTransactionsCountByHashOperationSpec = {
  path: "/v3/micro-blocks/hash/{hash}/transactions/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: CountResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getCurrentGenerationOperationSpec = {
  path: "/v3/generations/current",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getGenerationByHashOperationSpec = {
  path: "/v3/generations/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getGenerationByHeightOperationSpec = {
  path: "/v3/generations/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Generation
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, height],
  headerParameters: [accept],
  serializer
};
const getAccountByPubkeyOperationSpec = {
  path: "/v3/accounts/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getAccountByPubkeyAndHeightOperationSpec = {
  path: "/v3/accounts/{pubkey}/height/{height}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, height, pubkey],
  headerParameters: [accept],
  serializer
};
const getAccountByPubkeyAndHashOperationSpec = {
  path: "/v3/accounts/{pubkey}/hash/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Account
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash, pubkey],
  headerParameters: [accept],
  serializer
};
const getPendingAccountTransactionsByPubkeyOperationSpec = {
  path: "/v3/accounts/{pubkey}/transactions/pending",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTxs
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getAccountNextNonceOperationSpec = {
  path: "/v3/accounts/{pubkey}/next-nonce",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NextNonceResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString, strategy],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const protectedDryRunTxsOperationSpec = {
  path: "/v3/dry-run",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DryRunResults
    },
    403: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  requestBody: body,
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
const getTransactionByHashOperationSpec = {
  path: "/v3/transactions/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: SignedTx
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const getTransactionInfoByHashOperationSpec = {
  path: "/v3/transactions/{hash}/info",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: TxInfoObject
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_hash],
  headerParameters: [accept],
  serializer
};
const postTransactionOperationSpec = {
  path: "/v3/transactions",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: PostTxResponse
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  requestBody: body1,
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept, contentType],
  mediaType: "json",
  serializer
};
const getContractOperationSpec = {
  path: "/v3/contracts/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ContractObject
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getContractCodeOperationSpec = {
  path: "/v3/contracts/{pubkey}/code",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ByteCode
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getContractPoIOperationSpec = {
  path: "/v3/contracts/{pubkey}/poi",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PoI
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getOracleByPubkeyOperationSpec = {
  path: "/v3/oracles/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: RegisteredOracle
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getOracleQueriesByPubkeyOperationSpec = {
  path: "/v3/oracles/{pubkey}/queries",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: OracleQueries
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString, from, limit, type],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getOracleQueryByPubkeyAndQueryIdOperationSpec = {
  path: "/v3/oracles/{pubkey}/queries/{query-id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: OracleQuery
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey, queryId],
  headerParameters: [accept],
  serializer
};
const getNameEntryByNameOperationSpec = {
  path: "/v3/names/{name}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NameEntry
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, parameters_name],
  headerParameters: [accept],
  serializer
};
const getChannelByPubkeyOperationSpec = {
  path: "/v3/channels/{pubkey}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Channel
    },
    400: {
      bodyMapper: ErrorModel,
      isError: true
    },
    404: {
      bodyMapper: ErrorModel,
      isError: true
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host, pubkey],
  headerParameters: [accept],
  serializer
};
const getPeerPubkeyOperationSpec = {
  path: "/v3/peers/pubkey",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PeerPubKey
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getStatusOperationSpec = {
  path: "/v3/status",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Status
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
const getChainEndsOperationSpec = {
  path: "/v3/status/chain-ends",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  },
  queryParameters: [intAsString],
  urlParameters: [$host],
  headerParameters: [accept],
  serializer
};
;// CONCATENATED MODULE: ./src/Node.ts


function Node_classPrivateFieldInitSpec(obj, privateMap, value) { Node_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function Node_classPrivateMethodInitSpec(obj, privateSet) { Node_checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function Node_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function Node_classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
// eslint-disable-next-line max-classes-per-file






const bigIntPropertyNames = ['balance', 'queryFee', 'fee', 'amount', 'nameFee', 'channelAmount', 'initiatorAmount', 'responderAmount', 'channelReserve', 'initiatorAmountFinal', 'responderAmountFinal', 'gasPrice', 'deposit'];
const numberPropertyNames = ['time', 'gas', 'gasUsed', 'nameSalt', 'nonce', 'nextNonce', 'height', 'blockHeight', 'topBlockHeight', 'ttl', 'nameTtl', 'clientTtl', 'inbound', 'outbound', 'peerCount', 'pendingTransactionsCount', 'effectiveAtHeight', 'version', 'solutions', 'round'];
var _mapData = /*#__PURE__*/new WeakSet();
var _encodeArg = /*#__PURE__*/new WeakSet();
var _decodeRes = /*#__PURE__*/new WeakSet();
class NodeTransformed extends Node {
  constructor(...args) {
    super(...args);
    Node_classPrivateMethodInitSpec(this, _decodeRes);
    Node_classPrivateMethodInitSpec(this, _encodeArg);
    Node_classPrivateMethodInitSpec(this, _mapData);
  }
  async sendOperationRequest(operationArguments, operationSpec) {
    const args = mapObject(operationArguments, ([key, value]) => [key, Node_classPrivateMethodGet(this, _encodeArg, _encodeArg2).call(this, value)]);
    return Node_classPrivateMethodGet(this, _decodeRes, _decodeRes2).call(this, await super.sendOperationRequest(args, operationSpec));
  }
}
function _mapData2(data, transform) {
  if (Array.isArray(data)) return data.map(d => Node_classPrivateMethodGet(this, _mapData, _mapData2).call(this, d, transform));
  if (data != null && typeof data === 'object') {
    return mapObject(data, ([key, value]) => {
      if (value == null) return [key, value];
      if (bigIntPropertyNames.some(k => k === key)) return [key, transform.bigInt(value)];
      if (numberPropertyNames.some(k => k === key)) return [key, transform.number(value)];
      return [key, Node_classPrivateMethodGet(this, _mapData, _mapData2).call(this, value, transform)];
    });
  }
  return data;
}
function _encodeArg2(data) {
  return Node_classPrivateMethodGet(this, _mapData, _mapData2).call(this, data, {
    bigInt: value => {
      if (value instanceof (external_bignumber_js_default())) return value.toFixed();
      return value.toString();
    },
    number: value => value.toString()
  });
}
function _decodeRes2(data) {
  return Node_classPrivateMethodGet(this, _mapData, _mapData2).call(this, data, {
    bigInt: value => BigInt(value),
    number: value => +value
  });
}
var _networkIdPromise = /*#__PURE__*/new WeakMap();
class Node_Node extends NodeTransformed {
  /**
   * @param url - Url for node API
   * @param options - Options
   * @param options.ignoreVersion - Don't ensure that the node is supported
   * @param options.retryCount - Amount of extra requests to do in case of failure
   * @param options.retryOverallDelay - Time in ms to wait between all retries
   */
  constructor(url, {
    ignoreVersion = false,
    retryCount = 3,
    retryOverallDelay = 800,
    ...options
  } = {}) {
    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genRetryOnFailurePolicy(retryCount, retryOverallDelay), genErrorFormatterPolicy(body => ` ${body.reason}`)],
      ...options
    });
    Node_classPrivateFieldInitSpec(this, _networkIdPromise, {
      writable: true,
      value: void 0
    });
    if (!ignoreVersion) {
      const statusPromise = this.getStatus();
      const versionPromise = statusPromise.then(({
        nodeVersion
      }) => nodeVersion, error => error);
      classPrivateFieldSet_default()(this, _networkIdPromise, statusPromise.then(({
        networkId
      }) => networkId, error => error));
      this.pipeline.addPolicy(genVersionCheckPolicy('node', '/v3/status', versionPromise, '6.2.0', '7.0.0'));
    }
    this.intAsString = true;
  }
  async getNetworkId() {
    var _classPrivateFieldGet2;
    (_classPrivateFieldGet2 = classPrivateFieldGet_default()(this, _networkIdPromise)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : classPrivateFieldSet_default()(this, _networkIdPromise, this.getStatus().then(({
      networkId
    }) => networkId));
    const networkId = await classPrivateFieldGet_default()(this, _networkIdPromise);
    if (networkId instanceof Error) throw networkId;
    return networkId;
  }
  async getNodeInfo() {
    const {
      nodeVersion,
      networkId: nodeNetworkId,
      protocols,
      topBlockHeight
    } = await this.getStatus();
    const consensusProtocolVersion = protocols.filter(({
      effectiveAtHeight
    }) => topBlockHeight >= effectiveAtHeight).reduce((acc, p) => p.effectiveAtHeight > acc.effectiveAtHeight ? p : acc, {
      effectiveAtHeight: -1,
      version: 0
    }).version;
    if (ConsensusProtocolVersion[consensusProtocolVersion] == null) {
      const version = consensusProtocolVersion.toString();
      const versions = Object.values(ConsensusProtocolVersion).filter(el => typeof el === 'number').map(el => +el);
      const geVersion = Math.min(...versions).toString();
      const ltVersion = (Math.max(...versions) + 1).toString();
      throw new UnsupportedVersionError('consensus protocol', version, geVersion, ltVersion);
    }
    return {
      url: this.$host,
      nodeNetworkId,
      version: nodeVersion,
      consensusProtocolVersion
    };
  }
}
;// CONCATENATED MODULE: ./src/tx/transaction-signer.ts




/**
 * Returns account address that signed a transaction
 * @param transaction - transaction to get a signer of
 */
function getTransactionSignerAddress(transaction) {
  var _getSchema$find;
  const params = unpackTx(transaction);
  switch (params.tag) {
    case Tag.SignedTx:
      return getTransactionSignerAddress(buildTx(params.encodedTx));
    case Tag.GaMetaTx:
      return params.gaId;
    default:
  }
  const nonce = (_getSchema$find = getSchema(params.tag, params.version).find(([name]) => name === 'nonce')) === null || _getSchema$find === void 0 ? void 0 : _getSchema$find[1];
  if (nonce == null) throw new TransactionError(`Transaction doesn't have nonce: ${Tag[params.tag]}`);
  if (!('senderKey' in nonce)) throw new UnexpectedTsError();
  const address = params[nonce.senderKey];
  return address.replace(/^ok_/, 'ak_');
}
;// CONCATENATED MODULE: ./src/account/Base.ts

/**
 * Account is one of the three basic building blocks of an
 * {@link AeSdk} and provides access to a signing key pair.
 */
class AccountBase {
  /**
   * Sign encoded transaction
   * @param tx - Transaction to sign
   * @param options - Options
   * @param options.innerTx - Sign as inner transaction for PayingFor
   * @param options.authData - Object with gaMeta params
   * @returns Signed transaction
   */

  /**
   * Sign message
   * @param message - Message to sign
   * @param options - Options
   * @returns Signature
   */

  /**
   * Sign typed data
   * @param type - Type of data to sign
   * @param data - Encoded data to sign
   * @param options - Options
   * @returns Signature
   */
  // TODO: make abstract in the next major release
  // eslint-disable-next-line class-methods-use-this
  async signTypedData( /* eslint-disable @typescript-eslint/no-unused-vars */
  data, aci, options
  /* eslint-enable @typescript-eslint/no-unused-vars */) {
    throw new NotImplementedError('signTypedData method');
  }

  /**
   * Sign delegation of AENS, oracle operations to a contract
   * @param contractAddress - Address of a contract to delegate permissions to
   * @param options - Options
   * @returns Signature
   */
  // TODO: make abstract in the next major release
  // eslint-disable-next-line class-methods-use-this
  async signDelegationToContract( /* eslint-disable @typescript-eslint/no-unused-vars */
  contractAddress, options
  /* eslint-enable @typescript-eslint/no-unused-vars */) {
    throw new NotImplementedError('signDelegationToContract method');
  }

  /**
   * Sign delegation of an AENS name to a contract
   * @param contractAddress - Address of a contract to delegate permissions to
   * @param name - AENS name to manage by a contract
   * @param options - Options
   * @returns Signature
   */
  // TODO: make abstract in the next major release
  // eslint-disable-next-line class-methods-use-this
  async signNameDelegationToContract( /* eslint-disable @typescript-eslint/no-unused-vars */
  contractAddress, name, options
  /* eslint-enable @typescript-eslint/no-unused-vars */) {
    throw new NotImplementedError('signNameDelegationToContract method');
  }

  /**
   * Sign delegation of oracle query to a contract
   *
   * Warning! Implementations needs to ensure that decoded oracle query id is not equal to decoded
   * current account address unless https://github.com/aeternity/aesophia/issues/475 is fixed.
   *
   * Warning! Implementations needs to ensure that oracle query and contract exists unless
   * https://github.com/aeternity/aesophia/issues/474 is fixed.
   *
   * @param contractAddress - Address of a contract to delegate permissions to
   * @param oracleQueryId - Oracle query ID to reply by a contract
   * @param options - Options
   * @returns Signature
   */
  // TODO: make abstract in the next major release
  // eslint-disable-next-line class-methods-use-this
  async signOracleQueryDelegationToContract( /* eslint-disable @typescript-eslint/no-unused-vars */
  contractAddress, oracleQueryId, options
  /* eslint-enable @typescript-eslint/no-unused-vars */) {
    throw new NotImplementedError('signOracleQueryDelegationToContract method');
  }

  /**
   * Sign data blob
   * @param data - Data blob to sign
   * @param options - Options
   * @returns Signature
   */

  /**
   * Account address
   */
}
// EXTERNAL MODULE: external "@aeternity/aepp-calldata"
var aepp_calldata_ = __webpack_require__(7946);
// EXTERNAL MODULE: external "canonicalize"
var external_canonicalize_ = __webpack_require__(6667);
var external_canonicalize_default = /*#__PURE__*/__webpack_require__.n(external_canonicalize_);
;// CONCATENATED MODULE: ./src/utils/typed-data.ts






/**
 * Hashes arbitrary object, can be used to inline the aci hash to contract source code
 */
function hashJson(data) {
  var _canonicalize;
  return hash((_canonicalize = external_canonicalize_default()(data)) !== null && _canonicalize !== void 0 ? _canonicalize : '');
}

// TODO: move this type to calldata library https://github.com/aeternity/aepp-calldata-js/issues/215
// based on https://github.com/aeternity/aepp-calldata-js/blob/82b5a98f9b308482627da8d7484d213e9cf87151/src/AciTypeResolver.js#L129
/**
 * Hashes domain object, can be used to inline domain hash to contract source code
 */
function hashDomain(domain) {
  const domainAci = {
    record: [{
      name: 'name',
      type: {
        option: ['string']
      }
    }, {
      name: 'version',
      type: {
        option: ['int']
      }
    }, {
      name: 'networkId',
      type: {
        option: ['string']
      }
    }, {
      name: 'contractAddress',
      type: {
        option: ['contract_pubkey']
      }
    }]
  };
  const domainType = new aepp_calldata_.TypeResolver().resolveType(domainAci, {});
  const fateValue = new aepp_calldata_.ContractByteArrayEncoder().encodeWithType(domain, domainType);
  return hash(decode(fateValue));
}
function hashTypedData(data, aci, domain) {
  return hash(concatBuffers([messagePrefixLength, new Uint8Array([0]), hashDomain(domain), hashJson(aci), hash(decode(data))]));
}
;// CONCATENATED MODULE: ./src/account/Memory.ts









const secretKeys = new WeakMap();
function getBufferToSign(transaction, networkId, innerTx) {
  const prefixes = [networkId];
  if (innerTx) prefixes.push('inner_tx');
  const rlpBinaryTx = decode(transaction);
  return concatBuffers([Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)]);
}

/**
 * In-memory account class
 */
class AccountMemory extends AccountBase {
  /**
   * @param secretKey - Secret key
   */
  constructor(secretKey) {
    super();
    secretKey = typeof secretKey === 'string' ? Buffer.from(secretKey, 'hex') : secretKey;
    if (secretKey.length !== 64) {
      throw new ArgumentError('secretKey', '64 bytes', secretKey.length);
    }
    secretKeys.set(this, secretKey);
    this.address = encode(generateKeyPairFromSecret(secretKeys.get(this)).publicKey, Encoding.AccountAddress);
  }

  /**
   * Generates a new AccountMemory using a random secret key
   */
  static generate() {
    return new AccountMemory(generateKeyPair().secretKey);
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async sign(data, options) {
    return sign(data, secretKeys.get(this));
  }
  async signTransaction(transaction, {
    innerTx,
    networkId,
    ...options
  } = {}) {
    if (networkId == null) {
      throw new ArgumentError('networkId', 'provided', networkId);
    }
    const rlpBinaryTx = decode(transaction);
    const txWithNetworkId = getBufferToSign(transaction, networkId, innerTx === true);
    const signatures = [await this.sign(txWithNetworkId, options)];
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: rlpBinaryTx,
      signatures
    });
  }
  async signMessage(message, options) {
    return this.sign(messageToHash(message), options);
  }
  async signTypedData(data, aci, {
    name,
    version,
    networkId,
    contractAddress,
    ...options
  } = {}) {
    const dHash = hashTypedData(data, aci, {
      name,
      version,
      networkId,
      contractAddress
    });
    const signature = await this.sign(dHash, options);
    return encode(signature, Encoding.Signature);
  }
  async signDelegationToContract(contractAddress, {
    networkId
  } = {}) {
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const payload = concatBuffers([Buffer.from(networkId), decode(this.address), decode(contractAddress)]);
    const signature = await this.sign(payload);
    return encode(signature, Encoding.Signature);
  }
  async signNameDelegationToContract(contractAddress, name, {
    networkId
  } = {}) {
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const payload = concatBuffers([Buffer.from(networkId), decode(this.address), decode(produceNameId(name)), decode(contractAddress)]);
    const signature = await this.sign(payload);
    return encode(signature, Encoding.Signature);
  }
  async signOracleQueryDelegationToContract(contractAddress, oracleQueryId, {
    networkId
  } = {}) {
    const oracleQueryIdDecoded = decode(oracleQueryId);
    const addressDecoded = decode(this.address);
    // TODO: remove after fixing https://github.com/aeternity/aesophia/issues/475
    if (oracleQueryIdDecoded.compare(addressDecoded) === 0) {
      throw new ArgumentError('oracleQueryId', 'not equal to account address', oracleQueryId);
    }
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const payload = concatBuffers([Buffer.from(networkId), oracleQueryIdDecoded, decode(contractAddress)]);
    const signature = await this.sign(payload);
    return encode(signature, Encoding.Signature);
  }
}
;// CONCATENATED MODULE: ./src/tx/execution-cost.ts







/**
 * Calculates the cost of transaction execution
 * Provides an upper cost of contract-call-related transactions because of `gasLimit`.
 * Also assumes that oracle query fee is 0 unless it is provided in options.
 *
 * The idea is that if you need to show transaction details with some accuracy you can define
 * expense fields that you want to show separately. And to show `getExecutionCost` result as a fee,
 * subtracting all fields shown separately.
 *
 * @example
 * ```vue
 * <template>
 * Amount: {{ txUnpacked.amount }}
 * Name fee: {{ txUnpacked.nameFee }}
 * Other fees: {{ getExecutionCost(txEncoded) - txUnpacked.amount - txUnpacked.nameFee }}
 * </template>
 * ```
 *
 * Doing this way you won't worry to show wrong fee for a transaction you may not support. Because
 * the SDK calculates the overall price of any transaction on its side.
 *
 * @param transaction - Transaction to calculate the cost of
 * @param innerTx - Should be provided if transaction wrapped with Tag.PayingForTx
 * @param gasUsed - Amount of gas actually used to make calculation more accurate
 * @param queryFee - Oracle query fee
 * @param isInitiator - Is transaction signer an initiator of state channel
 */
function getExecutionCost(transaction, {
  innerTx,
  gasUsed,
  queryFee,
  isInitiator
} = {}) {
  const params = unpackTx(transaction);
  if (params.tag === Tag.SignedTx) {
    throw new IllegalArgumentError('Transaction shouldn\'t be a SignedTx, use `getExecutionCostBySignedTx` instead');
  }
  let res = 0n;
  if ('fee' in params && innerTx !== 'freeloader') {
    res += BigInt(params.fee);
  }
  if (params.tag === Tag.NameClaimTx) {
    res += BigInt(params.nameFee);
  }
  if (params.tag === Tag.OracleQueryTx) {
    res += BigInt(params.queryFee);
  }
  if (params.tag === Tag.OracleResponseTx) {
    res -= BigInt(queryFee !== null && queryFee !== void 0 ? queryFee : 0);
  }
  if (params.tag === Tag.ChannelSettleTx) {
    if (isInitiator === true) res -= BigInt(params.initiatorAmountFinal);
    if (isInitiator === false) res -= BigInt(params.responderAmountFinal);
  }
  if ((params.tag === Tag.SpendTx && params.senderId !== params.recipientId || params.tag === Tag.ContractCreateTx || params.tag === Tag.ContractCallTx || params.tag === Tag.ChannelDepositTx) && innerTx !== 'fee-payer') {
    res += BigInt(params.amount);
  }
  if (params.tag === Tag.ContractCreateTx) res += BigInt(params.deposit);
  if ((params.tag === Tag.ContractCreateTx || params.tag === Tag.ContractCallTx || params.tag === Tag.GaAttachTx || params.tag === Tag.GaMetaTx) && innerTx !== 'freeloader') {
    res += BigInt(params.gasPrice) * BigInt(gasUsed !== null && gasUsed !== void 0 ? gasUsed : params.gasLimit);
  }
  if (params.tag === Tag.GaMetaTx || params.tag === Tag.PayingForTx) {
    res += getExecutionCost(buildTx(params.tx.encodedTx), params.tag === Tag.PayingForTx ? {
      innerTx: 'fee-payer'
    } : {});
  }
  return res;
}

/**
 * Calculates the cost of signed transaction execution
 * @param transaction - Transaction to calculate the cost of
 * @param networkId - Network id used to sign the transaction
 * @param options - Options
 */
function getExecutionCostBySignedTx(transaction, networkId, options) {
  const params = unpackTx(transaction, Tag.SignedTx);
  if (params.encodedTx.tag === Tag.GaMetaTx) {
    return getExecutionCost(buildTx(params.encodedTx), options);
  }
  const tx = buildTx(params.encodedTx);
  const address = getTransactionSignerAddress(tx);
  const [isInnerTx, isNotInnerTx] = [true, false].map(f => verify(getBufferToSign(tx, networkId, f), params.signatures[0], address));
  if (!isInnerTx && !isNotInnerTx) throw new TransactionError('Can\'t verify signature');
  return getExecutionCost(buildTx(params.encodedTx), {
    ...(isInnerTx && {
      innerTx: 'freeloader'
    }),
    ...options
  });
}

/**
 * Calculates the cost of signed and not signed transaction execution using node
 * @param transaction - Transaction to calculate the cost of
 * @param node - Node to use
 * @param isMined - Is transaction already mined or not
 * @param options - Options
 */
async function getExecutionCostUsingNode(transaction, node, {
  isMined,
  ...options
} = {}) {
  let params = unpackTx(transaction);
  const isSignedTx = params.tag === Tag.SignedTx;
  const txHash = isSignedTx && isMined === true && buildTxHash(transaction);
  if (params.tag === Tag.SignedTx) params = params.encodedTx;

  // TODO: set gasUsed for PayingForTx after solving https://github.com/aeternity/aeternity/issues/4087
  if (options.gasUsed == null && txHash !== false && [Tag.ContractCreateTx, Tag.ContractCallTx, Tag.GaAttachTx, Tag.GaMetaTx].includes(params.tag)) {
    const {
      callInfo,
      gaInfo
    } = await node.getTransactionInfoByHash(txHash);
    const combinedInfo = callInfo !== null && callInfo !== void 0 ? callInfo : gaInfo;
    if (combinedInfo == null) {
      throw new InternalError(`callInfo and gaInfo is not available for transaction ${txHash}`);
    }
    options.gasUsed = combinedInfo.gasUsed;
  }
  if (options.queryFee == null && Tag.OracleResponseTx === params.tag) {
    options.queryFee = (await node.getOracleByPubkey(params.oracleId)).queryFee.toString();
  }
  if (options.isInitiator == null && Tag.ChannelSettleTx === params.tag && isMined !== true) {
    const {
      initiatorId
    } = await node.getChannelByPubkey(params.channelId);
    options.isInitiator = params.fromId === initiatorId;
  }
  return isSignedTx ? getExecutionCostBySignedTx(transaction, await node.getNetworkId(), options) : getExecutionCost(transaction, options);
}
;// CONCATENATED MODULE: ./src/tx/validator.ts












const validators = [];
async function verifyTransactionInternal(tx, node, parentTxTypes) {
  const address = getTransactionSignerAddress(buildTx(tx));
  const [account, {
    height
  }, {
    consensusProtocolVersion,
    nodeNetworkId
  }] = await Promise.all([node.getAccountByPubkey(address).catch(error => {
    if (!isAccountNotFoundError(error)) throw error;
    return {
      id: address,
      balance: 0n,
      nonce: 0
    };
  })
  // TODO: remove after fixing https://github.com/aeternity/aepp-sdk-js/issues/1537
  .then(acc => ({
    ...acc,
    id: acc.id
  })), node.getCurrentKeyBlockHeight(), node.getNodeInfo()]);
  return (await Promise.all(validators.map(async v => v(tx, {
    node,
    account,
    height,
    consensusProtocolVersion,
    nodeNetworkId,
    parentTxTypes
  })))).flat();
}

/**
 * Transaction Validator
 * This function validates some transaction properties,
 * to make sure it can be posted it to the chain
 * @category transaction builder
 * @param transaction - Base64Check-encoded transaction
 * @param nodeNotCached - Node to validate transaction against
 * @returns Array with verification errors
 * @example const errors = await verifyTransaction(transaction, node)
 */
async function verifyTransaction(transaction, nodeNotCached) {
  const node = new Node_Node(nodeNotCached.$host, {
    ignoreVersion: true,
    pipeline: nodeNotCached.pipeline.clone(),
    additionalPolicies: [genAggressiveCacheGetResponsesPolicy()]
  });
  return verifyTransactionInternal(unpackTx(transaction), node, []);
}
validators.push((tx, {
  account,
  nodeNetworkId,
  parentTxTypes
}) => {
  if (tx.tag !== Tag.SignedTx) return [];
  const {
    encodedTx,
    signatures
  } = tx;
  if ((encodedTx !== null && encodedTx !== void 0 ? encodedTx : signatures) == null) return [];
  if (signatures.length !== 1) return []; // TODO: Support multisignature like in state channels
  const prefix = Buffer.from([nodeNetworkId, ...(parentTxTypes.includes(Tag.PayingForTx) ? ['inner_tx'] : [])].join('-'));
  const txBinary = decode(buildTx(encodedTx));
  const txWithNetworkId = concatBuffers([prefix, txBinary]);
  const txHashWithNetworkId = concatBuffers([prefix, hash(txBinary)]);
  if (verify(txWithNetworkId, signatures[0], account.id) || verify(txHashWithNetworkId, signatures[0], account.id)) return [];
  return [{
    message: 'Signature cannot be verified, please ensure that you transaction have' + ' the correct prefix and the correct private key for the sender address',
    key: 'InvalidSignature',
    checkedKeys: ['encodedTx', 'signatures']
  }];
}, async (tx, {
  node,
  parentTxTypes
}) => {
  let nestedTx;
  if ('encodedTx' in tx) nestedTx = tx.encodedTx;
  if ('tx' in tx) nestedTx = tx.tx;
  if (nestedTx == null) return [];
  return verifyTransactionInternal(nestedTx, node, [...parentTxTypes, tx.tag]);
}, (tx, {
  height
}) => {
  if (!('ttl' in tx)) return [];
  if (tx.ttl === 0 || tx.ttl >= height) return [];
  return [{
    message: `TTL ${tx.ttl} is already expired, current height is ${height}`,
    key: 'ExpiredTTL',
    checkedKeys: ['ttl']
  }];
}, async (tx, {
  account,
  parentTxTypes,
  node
}) => {
  if (parentTxTypes.length !== 0) return [];
  const cost = await getExecutionCostUsingNode(buildTx(tx), node).catch(() => 0n);
  if (cost <= account.balance) return [];
  return [{
    message: `Account balance ${account.balance} is not enough to execute the transaction that costs ${cost}`,
    key: 'InsufficientBalance',
    checkedKeys: ['amount', 'fee', 'nameFee', 'gasLimit', 'gasPrice']
  }];
}, (tx, {
  account
}) => {
  let message;
  if (tx.tag === Tag.SignedTx && account.kind === 'generalized' && tx.signatures.length !== 0) {
    message = 'Generalized account can\'t be used to generate SignedTx with signatures';
  }
  if (tx.tag === Tag.GaMetaTx && account.kind === 'basic') {
    message = 'Basic account can\'t be used to generate GaMetaTx';
  }
  if (message == null) return [];
  return [{
    message,
    key: 'InvalidAccountType',
    checkedKeys: ['tag']
  }];
},
// TODO: revert nonce check
// TODO: ensure nonce valid when paying for own tx
(tx, {
  consensusProtocolVersion
}) => {
  var _ref, _ref2;
  const oracleCall = Tag.Oracle === tx.tag || Tag.OracleRegisterTx === tx.tag;
  const contractCreate = Tag.ContractCreateTx === tx.tag || Tag.GaAttachTx === tx.tag;
  const contractCall = Tag.ContractCallTx === tx.tag || Tag.GaMetaTx === tx.tag;
  const type = (_ref = (_ref2 = oracleCall ? 'oracle-call' : null) !== null && _ref2 !== void 0 ? _ref2 : contractCreate ? 'contract-create' : null) !== null && _ref !== void 0 ? _ref : contractCall ? 'contract-call' : null;
  if (type == null) return [];
  const protocol = ProtocolToVmAbi[consensusProtocolVersion][type];
  let ctVersion;
  if ('abiVersion' in tx) ctVersion = {
    abiVersion: tx.abiVersion
  };
  if ('ctVersion' in tx) ctVersion = tx.ctVersion;
  if (ctVersion == null) throw new UnexpectedTsError();
  if (!protocol.abiVersion.includes(ctVersion.abiVersion) || contractCreate && !protocol.vmVersion.includes(ctVersion.vmVersion)) {
    return [{
      message: `ABI/VM version ${JSON.stringify(ctVersion)} is wrong, supported is: ${JSON.stringify(protocol)}`,
      key: 'VmAndAbiVersionMismatch',
      checkedKeys: ['ctVersion', 'abiVersion']
    }];
  }
  return [];
}, async (tx, {
  node
}) => {
  if (Tag.ContractCallTx !== tx.tag) return [];
  try {
    const {
      active
    } = await node.getContract(tx.contractId);
    if (active) return [];
    return [{
      message: `Contract ${tx.contractId} is not active`,
      key: 'ContractNotActive',
      checkedKeys: ['contractId']
    }];
  } catch (error) {
    var _error$response;
    if (!(error instanceof core_rest_pipeline_.RestError) || ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.bodyAsText) == null) throw error;
    return [{
      message: JSON.parse(error.response.bodyAsText).reason,
      // TODO: use parsedBody instead
      key: 'ContractNotFound',
      checkedKeys: ['contractId']
    }];
  }
});
;// CONCATENATED MODULE: ./src/chain.ts









/**
 * @category chain
 */
function _getPollInterval(type,
// TODO: rename to 'key-block' | 'micro-block'
{
  _expectedMineRate = 180000,
  _microBlockCycle = 3000,
  _maxPollInterval = 5000
}) {
  const base = {
    block: _expectedMineRate,
    microblock: _microBlockCycle
  }[type];
  return Math.min(base / 3, _maxPollInterval);
}

/**
 * @category exception
 */
class InvalidTxError extends TransactionError {
  constructor(message, validation, transaction) {
    super(message);
    this.name = 'InvalidTxError';
    this.validation = validation;
    this.transaction = transaction;
  }
}

/**
 * Obtain current height of the chain
 * @category chain
 * @returns Current chain height
 */
async function getHeight({
  onNode
}) {
  return (await onNode.getCurrentKeyBlockHeight()).height;
}

/**
 * Wait for a transaction to be mined
 * @category chain
 * @param th - The hash of transaction to poll
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.blocks - Number of blocks mined after which to fail
 * @param options.onNode - Node to use
 * @returns The transaction as it was mined
 */
async function poll(th, {
  blocks = 5,
  interval,
  onNode,
  ...options
}) {
  var _interval;
  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);
  const max = (await getHeight({
    onNode
  })) + blocks;
  do {
    const tx = await onNode.getTransactionByHash(th);
    if (tx.blockHeight !== -1) return tx;
    await pause(interval);
  } while ((await getHeight({
    onNode
  })) < max);
  throw new TxTimedOutError(blocks, th);
}

/**
 * Wait for the chain to reach a specific height
 * @category chain
 * @param height - Height to wait for
 * @param options - Options
 * @param options.interval - Interval (in ms) at which to poll the chain
 * @param options.onNode - Node to use
 * @returns Current chain height
 */
async function awaitHeight(height, {
  interval,
  onNode,
  ...options
}) {
  var _interval2;
  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('block', options);
  let currentHeight;
  do {
    if (currentHeight != null) await pause(interval);
    currentHeight = (await onNode.getCurrentKeyBlockHeight()).height;
  } while (currentHeight < height);
  return currentHeight;
}

/**
 * Wait for transaction confirmation
 * @category chain
 * @param txHash - Transaction hash
 * @param options - Options
 * @param options.confirm - Number of micro blocks to wait for transaction confirmation
 * @param options.onNode - Node to use
 * @returns Current Height
 */
async function waitForTxConfirm(txHash, {
  confirm = 3,
  onNode,
  ...options
}) {
  const {
    blockHeight
  } = await onNode.getTransactionByHash(txHash);
  const height = await awaitHeight(blockHeight + confirm, {
    onNode,
    ...options
  });
  const {
    blockHeight: newBlockHeight
  } = await onNode.getTransactionByHash(txHash);
  switch (newBlockHeight) {
    case -1:
      throw new TxNotInChainError(txHash);
    case blockHeight:
      return height;
    default:
      return waitForTxConfirm(txHash, {
        onNode,
        confirm,
        ...options
      });
  }
}

/**
 * Signs and submits transaction for mining
 * @category chain
 * @param txUnsigned - Transaction to sign and submit
 * @param options - Options
 * @param options.onNode - Node to use
 * @param options.onAccount - Account to use
 * @param options.verify - Verify transaction before broadcast, throw error if not
 * @param options.waitMined - Ensure that transaction get into block
 * @param options.confirm - Number of micro blocks that should be mined after tx get included
 * @returns Transaction details
 */
async function sendTransaction(txUnsigned, {
  onNode,
  onAccount,
  verify = true,
  waitMined = true,
  confirm,
  innerTx,
  ...options
}) {
  const tx = await onAccount.signTransaction(txUnsigned, {
    ...options,
    onNode,
    innerTx,
    networkId: await onNode.getNetworkId()
  });
  if (innerTx === true) return {
    hash: buildTxHash(tx),
    rawTx: tx
  };
  if (verify) {
    const validation = await verifyTransaction(tx, onNode);
    if (validation.length > 0) {
      const message = `Transaction verification errors: ${validation.map(v => v.message).join(', ')}`;
      throw new InvalidTxError(message, validation, tx);
    }
  }
  try {
    let __queue;
    try {
      __queue = onAccount != null ? `tx-${onAccount.address}` : null;
    } catch (error) {
      __queue = null;
    }
    const {
      txHash
    } = await onNode.postTransaction({
      tx
    }, __queue != null ? {
      requestOptions: {
        customHeaders: {
          __queue
        }
      }
    } : {});
    if (waitMined) {
      const pollResult = await poll(txHash, {
        onNode,
        ...options
      });
      const txData = {
        ...pollResult,
        hash: pollResult.hash,
        rawTx: tx
      };
      // wait for transaction confirmation
      if (confirm != null && +confirm > 0) {
        const c = typeof confirm === 'boolean' ? undefined : confirm;
        return {
          ...txData,
          confirmationHeight: await waitForTxConfirm(txHash, {
            onNode,
            confirm: c,
            ...options
          })
        };
      }
      return txData;
    }
    return {
      hash: txHash,
      rawTx: tx
    };
  } catch (error) {
    ensureError(error);
    throw Object.assign(error, {
      rawTx: tx,
      verifyTx: async () => verifyTransaction(tx, onNode)
    });
  }
}
/**
 * Get account by account public key
 * @category chain
 * @param address - Account address (public key)
 * @param options - Options
 * @param options.height - Get account on specific block by block height
 * @param options.hash - Get account on specific block by micro block hash or key block hash
 * @param options.onNode - Node to use
 */
async function getAccount(address, {
  height,
  hash,
  onNode
}) {
  if (height != null) return onNode.getAccountByPubkeyAndHeight(address, height);
  if (hash != null) return onNode.getAccountByPubkeyAndHash(address, hash);
  return onNode.getAccountByPubkey(address);
}

/**
 * Request the balance of specified account
 * @category chain
 * @param address - The public account address to obtain the balance for
 * @param options - Options
 * @param options.format
 * @param options.height - The chain height at which to obtain the balance for
 * (default: top of chain)
 * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)
 */
async function getBalance(address, {
  format = AE_AMOUNT_FORMATS.AETTOS,
  ...options
}) {
  const addr = address.startsWith('ok_') ? encode(decode(address), Encoding.AccountAddress) : address;
  const {
    balance
  } = await getAccount(addr, options).catch(error => {
    if (!isAccountNotFoundError(error)) throw error;
    return {
      balance: 0n
    };
  });
  return formatAmount(balance, {
    targetDenomination: format
  });
}

/**
 * Obtain current generation
 * @category chain
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Current Generation
 */
async function getCurrentGeneration({
  onNode
}) {
  return onNode.getCurrentGeneration();
}

/**
 * Get generation by hash or height
 * @category chain
 * @param hashOrHeight - Generation hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Generation
 */
async function getGeneration(hashOrHeight, {
  onNode
}) {
  if (typeof hashOrHeight === 'number') return onNode.getGenerationByHeight(hashOrHeight);
  return onNode.getGenerationByHash(hashOrHeight);
}

/**
 * Get micro block transactions
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transactions
 */
async function getMicroBlockTransactions(hash, {
  onNode
}) {
  return (await onNode.getMicroBlockTransactionsByHash(hash)).transactions;
}

/**
 * Get key block
 * @category chain
 * @param hashOrHeight - Key block hash or height
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Key Block
 */
async function getKeyBlock(hashOrHeight, {
  onNode
}) {
  if (typeof hashOrHeight === 'number') return onNode.getKeyBlockByHeight(hashOrHeight);
  return onNode.getKeyBlockByHash(hashOrHeight);
}

/**
 * Get micro block header
 * @category chain
 * @param hash - Micro block hash
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Micro block header
 */
async function getMicroBlockHeader(hash, {
  onNode
}) {
  return onNode.getMicroBlockHeaderByHash(hash);
}
const txDryRunRequests = new Map();
async function txDryRunHandler(key, onNode) {
  const rs = txDryRunRequests.get(key);
  txDryRunRequests.delete(key);
  if (rs == null) throw new InternalError('Can\'t get dry-run request');
  let dryRunRes;
  try {
    const top = typeof rs[0].top === 'number' ? (await getKeyBlock(rs[0].top, {
      onNode
    })).hash : rs[0].top;
    dryRunRes = await onNode.protectedDryRunTxs({
      top,
      txEvents: rs[0].txEvents,
      txs: rs.map(req => ({
        tx: req.tx
      })),
      accounts: Array.from(new Set(rs.map(req => req.accountAddress))).map(pubKey => ({
        pubKey,
        amount: DRY_RUN_ACCOUNT.amount
      }))
    });
  } catch (error) {
    rs.forEach(({
      reject
    }) => reject(error));
    return;
  }
  const {
    results,
    txEvents
  } = dryRunRes;
  results.forEach(({
    result,
    reason,
    ...resultPayload
  }, idx) => {
    const {
      resolve,
      reject,
      tx,
      accountAddress
    } = rs[idx];
    if (result === 'ok') resolve({
      ...resultPayload,
      txEvents
    });else reject(Object.assign(new DryRunError(reason), {
      tx,
      accountAddress
    }));
  });
}

/**
 * Transaction dry-run
 * @category chain
 * @param tx - transaction to execute
 * @param accountAddress - address that will be used to execute transaction
 * @param options - Options
 * @param options.top - hash of block on which to make dry-run
 * @param options.txEvents - collect and return on-chain tx events that would result from the call
 * @param options.combine - Enables combining of similar requests to a single dry-run call
 * @param options.onNode - Node to use
 */
async function txDryRun(tx, accountAddress, {
  top,
  txEvents,
  combine,
  onNode
}) {
  var _txDryRunRequests$get;
  const key = combine === true ? [top, txEvents].join() : 'immediate';
  const requests = (_txDryRunRequests$get = txDryRunRequests.get(key)) !== null && _txDryRunRequests$get !== void 0 ? _txDryRunRequests$get : [];
  txDryRunRequests.set(key, requests);
  return new Promise((resolve, reject) => {
    var _requests$timeout;
    requests.push({
      tx,
      accountAddress,
      top,
      txEvents,
      resolve,
      reject
    });
    if (combine !== true) {
      void txDryRunHandler(key, onNode);
      return;
    }
    (_requests$timeout = requests.timeout) !== null && _requests$timeout !== void 0 ? _requests$timeout : requests.timeout = setTimeout(() => {
      void txDryRunHandler(key, onNode);
    });
  });
}

/**
 * Get contract byte code
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 */
async function getContractByteCode(contractId, {
  onNode
}) {
  return onNode.getContractCode(contractId);
}

/**
 * Get contract entry
 * @category contract
 * @param contractId - Contract address
 * @param options - Options
 * @param options.onNode - Node to use
 */
async function getContract(contractId, {
  onNode
}) {
  return onNode.getContract(contractId);
}

/**
 * Get name entry
 * @category AENS
 * @param name - AENS name
 * @param options - Options
 * @param options.onNode - Node to use
 */
async function getName(name, {
  onNode
}) {
  return onNode.getNameEntryByName(name);
}

/**
 * Resolve AENS name and return name hash
 * @category AENS
 * @param nameOrId - AENS name or address
 * @param key - in AENS pointers record
 * @param options - Options
 * @param options.verify - To ensure that name exist and have a corresponding pointer
 * // TODO: avoid that to don't trust to current api gateway
 * @param options.resolveByNode - Enables pointer resolving using node
 * @param options.onNode - Node to use
 * @returns Address or AENS name hash
 */
async function resolveName(nameOrId, key, {
  verify = true,
  resolveByNode = false,
  onNode
}) {
  if (isNameValid(nameOrId)) {
    if (verify || resolveByNode) {
      const name = await onNode.getNameEntryByName(nameOrId);
      const pointer = name.pointers.find(p => p.key === key);
      if (pointer == null) throw new AensPointerContextError(nameOrId, key);
      if (resolveByNode) return pointer.id;
    }
    return produceNameId(nameOrId);
  }
  try {
    decode(nameOrId);
    return nameOrId;
  } catch (error) {
    throw new InvalidAensNameError(`Invalid name or address: ${nameOrId}`);
  }
}
// EXTERNAL MODULE: external "@aeternity/uuid"
var uuid_ = __webpack_require__(3983);
// EXTERNAL MODULE: external "@aeternity/argon2"
var argon2_ = __webpack_require__(7417);
;// CONCATENATED MODULE: ./src/utils/keystore.ts





const DERIVED_KEY_FUNCTIONS = {
  async argon2id(pass, salt, params) {
    const {
      memlimit_kib: memoryCost,
      opslimit: timeCost
    } = params;
    return (0,argon2_.hash)(pass, {
      hashLength: 32,
      salt,
      timeCost,
      memoryCost,
      type: argon2_.argon2id
    });
  }
};
const CRYPTO_FUNCTIONS = {
  'xsalsa20-poly1305': {
    encrypt: (external_tweetnacl_default()).secretbox,
    decrypt(...args) {
      const res = external_tweetnacl_default().secretbox.open(...args);
      if (res == null) throw new InvalidPasswordError();
      return res;
    }
  }
};
const CRYPTO_DEFAULTS = {
  secret_type: 'ed25519',
  symmetric_alg: 'xsalsa20-poly1305',
  kdf: 'argon2id',
  kdf_params: {
    memlimit_kib: 65536,
    opslimit: 3,
    parallelism: 1
  }
};

/**
 * Symmetric private key encryption using secret (derived) key.
 * @category keystore
 * @param plaintext - Data to be encrypted.
 * @param key - Secret key.
 * @param nonce - Randomly generated nonce.
 * @param algo - Encryption algorithm.
 * @returns Encrypted data.
 */
function encrypt(plaintext, key, nonce, algo = CRYPTO_DEFAULTS.symmetric_alg) {
  return CRYPTO_FUNCTIONS[algo].encrypt(plaintext, nonce, key);
}

/**
 * Symmetric private key decryption using secret (derived) key.
 * @category keystore
 * @param ciphertext - Data to be decrypted.
 * @param key - Secret key.
 * @param nonce - Nonce from key-object.
 * @param algo - Encryption algorithm.
 * @returns Decrypted data.
 */
function decrypt(ciphertext, key, nonce, algo = CRYPTO_DEFAULTS.symmetric_alg) {
  return CRYPTO_FUNCTIONS[algo].decrypt(ciphertext, nonce, key);
}

/**
 * Derive secret key from password with key derivation function.
 * @category keystore
 * @param password - User-supplied password.
 * @param nonce - Randomly generated nonce.
 * @param kdf - Key derivation function.
 * @param kdfParams - KDF parameters.
 * @returns Secret key derived from password.
 */
async function deriveKey(password, nonce, kdf, kdfParams) {
  return DERIVED_KEY_FUNCTIONS[kdf](password, nonce, kdfParams);
}

/**
 * Recover plaintext private key from secret-storage key object.
 * @category keystore
 * @param password - Keystore object password.
 * @param keystore - Keystore object.
 * @returns Plaintext private key.
 */
async function recover(password, {
  crypto
}) {
  const salt = Buffer.from(crypto.kdf_params.salt, 'hex');
  return Buffer.from(decrypt(Buffer.from(crypto.ciphertext, 'hex'), await deriveKey(password, salt, crypto.kdf, crypto.kdf_params), Buffer.from(crypto.cipher_params.nonce, 'hex'), crypto.symmetric_alg)).toString('hex');
}

/**
 * Export private key to keystore secret-storage format.
 * @category keystore
 * @param name - Key name.
 * @param password - User-supplied password.
 * @param privateKey - Private key as hex-string or a Buffer.
 * @param nonce - Randomly generated 24byte nonce.
 * @param salt - Randomly generated 16byte salt.
 * @param options - Encryption parameters.
 * @param options.kdf - Key derivation function.
 * @param options.kdf_params - KDF parameters.
 */
async function dump(name, password, privateKey, nonce = external_tweetnacl_default().randomBytes(24), salt = external_tweetnacl_default().randomBytes(16), options) {
  const opt = {
    ...CRYPTO_DEFAULTS,
    ...options
  };
  const derivedKey = await deriveKey(password, salt, opt.kdf, opt.kdf_params);
  const payload = typeof privateKey === 'string' ? Buffer.from(privateKey, 'hex') : privateKey;
  return {
    name,
    version: 1,
    public_key: getAddressFromPriv(payload),
    id: (0,uuid_.v4)(),
    crypto: {
      secret_type: opt.secret_type,
      symmetric_alg: opt.symmetric_alg,
      ciphertext: Buffer.from(encrypt(payload, derivedKey, nonce, opt.symmetric_alg)).toString('hex'),
      cipher_params: {
        nonce: Buffer.from(nonce).toString('hex')
      },
      kdf: opt.kdf,
      kdf_params: {
        ...opt.kdf_params,
        salt: Buffer.from(salt).toString('hex')
      }
    }
  };
}
// EXTERNAL MODULE: external "tweetnacl-auth"
var external_tweetnacl_auth_ = __webpack_require__(9882);
// EXTERNAL MODULE: external "bip32-path"
var external_bip32_path_ = __webpack_require__(1986);
// EXTERNAL MODULE: external "aes-js"
var external_aes_js_ = __webpack_require__(8236);
var external_aes_js_default = /*#__PURE__*/__webpack_require__.n(external_aes_js_);
;// CONCATENATED MODULE: ./src/utils/hd-wallet.ts







const Ecb = (external_aes_js_default()).ModeOfOperation.ecb;

// TODO: use mnemonic encryption instead of AES
/**
 * Encrypt given data using `password`
 * @param password - Password to encrypt with
 * @param binaryData - Data to encrypt
 * @returns Encrypted data
 */
function encryptKey(password, binaryData) {
  const hashedPasswordBytes = sha256hash(password);
  const aesEcb = new Ecb(hashedPasswordBytes);
  return aesEcb.encrypt(binaryData);
}

/**
 * Decrypt given data using `password`
 * @param password - Password to decrypt with
 * @param encrypted - Data to decrypt
 * @returns Decrypted data
 */
function decryptKey(password, encrypted) {
  const encryptedBytes = Buffer.from(encrypted);
  const hashedPasswordBytes = sha256hash(password);
  const aesEcb = new Ecb(hashedPasswordBytes);
  return aesEcb.decrypt(encryptedBytes);
}

/**
 * @category exception
 */
class DerivationError extends CryptographyError {
  constructor(message) {
    super(message);
    this.name = 'DerivationError';
  }
}
const ED25519_CURVE = Buffer.from('ed25519 seed');
const HARDENED_OFFSET = 0x80000000;
/**
 * @category hd-wallet
 */
function deriveChild({
  secretKey,
  chainCode
}, index) {
  if (index < HARDENED_OFFSET) {
    throw new DerivationError(`Segment ${index} is not hardened`);
  }
  const indexBuffer = Buffer.allocUnsafe(4);
  indexBuffer.writeUInt32BE(index, 0);
  const data = concatBuffers([Buffer.alloc(1, 0), secretKey, indexBuffer]);
  const I = (0,external_tweetnacl_auth_.full)(data, chainCode);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}

/**
 * @category hd-wallet
 */
function derivePathFromKey(path, key) {
  const segments = path === '' ? [] : (0,external_bip32_path_.fromString)(path).toPathArray();
  segments.forEach((segment, i) => {
    if (segment < HARDENED_OFFSET) {
      throw new DerivationError(`Segment #${i + 1} is not hardened`);
    }
  });
  return segments.reduce((parentKey, segment) => deriveChild(parentKey, segment), key);
}

/**
 * @category hd-wallet
 */
function getMasterKeyFromSeed(seed) {
  const I = (0,external_tweetnacl_auth_.full)(seed, ED25519_CURVE);
  const IL = I.slice(0, 32);
  const IR = I.slice(32);
  return {
    secretKey: IL,
    chainCode: IR
  };
}

/**
 * @category hd-wallet
 */
function derivePathFromSeed(path, seed) {
  if (!['m', 'm/'].includes(path.slice(0, 2))) {
    throw new DerivationError('Root element is required');
  }
  const masterKey = getMasterKeyFromSeed(seed);
  return derivePathFromKey(path.slice(2), masterKey);
}
function formatAccount(keys) {
  const {
    secretKey,
    publicKey
  } = keys;
  return {
    secretKey: Buffer.from(secretKey).toString('hex'),
    publicKey: encode(publicKey, Encoding.AccountAddress)
  };
}

/**
 * @category hd-wallet
 */
function getKeyPair(secretKey) {
  return external_tweetnacl_default().sign.keyPair.fromSeed(secretKey);
}

/**
 * @category hd-wallet
 */
function generateSaveHDWalletFromSeed(seed, password) {
  const walletKey = derivePathFromSeed('m/44h/457h', seed);
  return {
    secretKey: Buffer.from(encryptKey(password, walletKey.secretKey)).toString('hex'),
    chainCode: Buffer.from(encryptKey(password, walletKey.chainCode)).toString('hex')
  };
}

/**
 * @category hd-wallet
 */
function getSaveHDWalletAccounts(saveHDWallet, password, accountCount) {
  const walletKey = {
    secretKey: decryptKey(password, Buffer.from(saveHDWallet.secretKey, 'hex')),
    chainCode: decryptKey(password, Buffer.from(saveHDWallet.chainCode, 'hex'))
  };
  return new Array(accountCount).fill(undefined).map((_, idx) => formatAccount(getKeyPair(derivePathFromKey(`${idx}h/0h/0h`, walletKey).secretKey)));
}

/**
 * @category hd-wallet
 */
const getHdWalletAccountFromSeed = (seed, accountIdx) => {
  const walletKey = derivePathFromSeed('m/44h/457h', seed);
  const derived = derivePathFromKey(`${accountIdx}h/0h/0h`, walletKey);
  const keyPair = getKeyPair(derived.secretKey);
  return {
    ...formatAccount(keyPair),
    idx: accountIdx
  };
};
;// CONCATENATED MODULE: ./src/aens.ts
/**
 * Aens methods - routines to interact with the ternity naming system
 *
 * The high-level description of the naming system is
 * https://github.com/aeternity/protocol/blob/master/AENS.md in the protocol
 * repository.
 */







/**
 * Revoke a name
 * @category AENS
 * @param name - Name hash
 * @param options - Options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @returns Transaction result
 * @example
 * ```js
 * const name = 'test.chain'
 * const nameObject = await sdkInstance.aensQuery(name)
 *
 * await sdkInstance.aensRevoke(name, { fee, ttl , nonce })
 * // or
 * await nameObject.revoke({ fee, ttl, nonce })
 * ```
 */
async function aensRevoke(name, options) {
  const nameRevokeTx = await buildTxAsync({
    ...options,
    tag: Tag.NameRevokeTx,
    nameId: name,
    accountId: options.onAccount.address
  });
  return sendTransaction(nameRevokeTx, options);
}
/**
 * Update a name
 * @category AENS
 * @param name - AENS name
 * @param pointers - Map of pointer keys to corresponding addresses
 * @param options - Options
 * @param options.extendPointers - Get the pointers from the node and merge with provided
 * ones. Pointers with the same type will be overwritten
 * @param options.onAccount - Make operation on specific account from sdk (you
 * pass publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @param options.nameTtl - Name ttl represented in number of
 * blocks (Max value is 50000 blocks)
 * @param options.clientTtl=84600 a suggestion as to how long any
 * clients should cache this information
 * @throws Invalid pointer array error
 * @example
 * ```js
 * const name = 'test.chain'
 * const pointersArray = ['ak_asd23dasdas...,' 'ct_asdf34fasdasd...']
 * const nameObject = await sdkInstance.aensQuery(name)
 *
 * await sdkInstance.aensUpdate(name, pointersArray, { nameTtl, ttl, fee, nonce, clientTtl })
 * // or
 * await nameObject.update(pointers, { nameTtl, ttl, fee, nonce, clientTtl })
 * ```
 */
async function aensUpdate(name, pointers, {
  extendPointers,
  ...options
}) {
  const allPointers = {
    ...(extendPointers === true && Object.fromEntries((await getName(name, options)).pointers.map(({
      key,
      id
    }) => [key, id]))),
    ...pointers
  };
  const nameUpdateTx = await buildTxAsync({
    clientTtl: CLIENT_TTL,
    nameTtl: NAME_TTL,
    ...options,
    tag: Tag.NameUpdateTx,
    nameId: name,
    accountId: options.onAccount.address,
    pointers: Object.entries(allPointers).map(([key, id]) => ({
      key,
      id
    }))
  });
  return sendTransaction(nameUpdateTx, options);
}
/**
 * Transfer a domain to another account
 * @category AENS
 * @param name - AENS name
 * @param account - Recipient account publick key
 * @param options - Options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @returns Transaction result
 * @example
 * ```js
 * const name = 'test.chain'
 * const recipientPub = 'ak_asd23dasdas...'
 * const nameObject = await sdkInstance.aensQuery(name)
 *
 * await sdkInstance.aensTransfer(name, recipientPub, { ttl, fee, nonce })
 * // or
 * await nameObject.transfer(recipientPub, { ttl, fee, nonce })
 * ```
 */
async function aensTransfer(name, account, options) {
  const nameTransferTx = await buildTxAsync({
    ...options,
    tag: Tag.NameTransferTx,
    nameId: name,
    accountId: options.onAccount.address,
    recipientId: account
  });
  return sendTransaction(nameTransferTx, options);
}
/**
 * Query the AENS name info from the node
 * and return the object with info and predefined functions for manipulating name
 * @category AENS
 * @param name - AENS name
 * @param opt - Options
 * @returns
 * @example
 * ```js
 * const nameObject = sdkInstance.aensQuery('test.chain')
 * console.log(nameObject)
 * {
 *  id, // name hash
 *  pointers, // array of pointers
 *  update, // Update name function
 *  extendTtl, // Extend Ttl name function
 *  transfer, // Transfer name function
 *  revoke // Revoke name function
 * }
 * ```
 */
async function aensQuery(name, opt) {
  const nameEntry = await getName(name, opt);
  return Object.freeze({
    ...nameEntry,
    id: nameEntry.id,
    owner: nameEntry.owner,
    async update(pointers, options) {
      return {
        ...(await aensUpdate(name, pointers, {
          ...opt,
          ...options
        })),
        ...(await aensQuery(name, {
          ...opt,
          ...options
        }))
      };
    },
    async transfer(account, options) {
      return {
        ...(await aensTransfer(name, account, {
          ...opt,
          ...options
        })),
        ...(await aensQuery(name, {
          ...opt,
          ...options
        }))
      };
    },
    async revoke(options) {
      return aensRevoke(name, {
        ...opt,
        ...options
      });
    },
    async extendTtl(nameTtl = NAME_TTL, options = {}) {
      if (nameTtl > NAME_TTL || nameTtl <= 0) {
        throw new ArgumentError('nameTtl', `a number between 1 and ${NAME_TTL} blocks`, nameTtl);
      }
      return {
        ...(await aensUpdate(name, {}, {
          ...opt,
          ...options,
          nameTtl,
          extendPointers: true
        })),
        ...(await aensQuery(name, {
          ...opt,
          ...options
        }))
      };
    }
  });
}

/**
 * Claim a previously preclaimed registration. This can only be done after the
 * preclaim step
 * @category AENS
 * @param name - AENS name
 * @param salt - Salt from pre-claim, or 0 if it's a bid
 * @param options - options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @param options.nameFee - Name Fee (By default calculated by sdk)
 * @returns the result of the claim
 * @example
 * ```js
 * const name = 'test.chain'
 * const salt = preclaimResult.salt // salt from pre-claim transaction
 *
 * await sdkInstance.aensClaim(name, salt, { ttl, fee, nonce, nameFee })
 * ```
 */
async function aensClaim(name, salt, options) {
  const claimTx = await buildTxAsync({
    ...options,
    tag: Tag.NameClaimTx,
    accountId: options.onAccount.address,
    nameSalt: salt,
    name
  });
  const result = await sendTransaction(claimTx, options);
  if (!isAuctionName(name)) {
    const nameInter = result.blockHeight != null && result.blockHeight > 0 ? await aensQuery(name, options) : {};
    return Object.assign(result, nameInter);
  }
  return result;
}
/**
 * Preclaim a name. Sends a hash of the name and a random salt to the node
 * @category AENS
 * @param name - AENS name
 * @param options - Options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @example
 * ```js
 * const name = 'test.chain'
 * const salt = preclaimResult.salt // salt from pre-claim transaction
 *
 * await sdkInstance.aensPreclaim(name, { ttl, fee, nonce })
 * {
 *   ...transactionResult,
 *   claim, // Claim function (options={}) => claimTransactionResult
 *   salt,
 *   commitmentId
 * }
 * ```
 */
async function aensPreclaim(name, options) {
  const salt = genSalt();
  const commitmentId = commitmentHash(name, salt);
  const preclaimTx = await buildTxAsync({
    ...options,
    tag: Tag.NamePreclaimTx,
    accountId: options.onAccount.address,
    commitmentId
  });
  return Object.freeze({
    ...(await sendTransaction(preclaimTx, options)),
    salt,
    commitmentId,
    async claim(opts) {
      const {
        version,
        ...otherOptions
      } = options;
      return aensClaim(name, salt, {
        ...otherOptions,
        ...opts
      });
    }
  });
}
/**
 * Bid to name auction
 * @category AENS
 * @param name - Domain name
 * @param nameFee - Name fee (bid fee)
 * @param options - Options
 * @param options.onAccount - Make operation on specific account from sdk (you pass
 * publickKey) or using provided KeyPair(Can be keypair object or MemoryAccount)
 * @param options.fee - fee
 * @param options.ttl - ttl
 * @param options.nonce - nonce
 * @returns Transaction result
 * @example
 * ```js
 * const name = 'test.chain'
 * const bidFee = computeBidFee(name, { startFee, increment: 0.42 })
 *
 * await sdkInstance.aensBid(name, 213109412839123, { ttl, fee, nonce })
 * ```
 */
async function aensBid(name, nameFee, options) {
  return aensClaim(name, 0, {
    ...options,
    nameFee
  });
}
;// CONCATENATED MODULE: ./src/contract/Contract.ts


function Contract_classPrivateFieldInitSpec(obj, privateMap, value) { Contract_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function Contract_classPrivateMethodInitSpec(obj, privateSet) { Contract_checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function Contract_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function Contract_classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
/**
 * Contract module - routines to interact with the ternity contract
 *
 * High level documentation of the contracts are available at
 * https://github.com/aeternity/protocol/tree/master/contracts and
 */










var _getCallResult = /*#__PURE__*/new WeakSet();
var _sendAndProcess = /*#__PURE__*/new WeakSet();
var _getFunctionAci = /*#__PURE__*/new WeakSet();
var _getContractNameByEvent = /*#__PURE__*/new WeakSet();
var _aciContract = /*#__PURE__*/new WeakMap();
/**
 * Generate contract ACI object with predefined js methods for contract usage - can be used for
 * creating a reference to already deployed contracts
 * @category contract
 * @param options - Options object
 * @returns JS Contract API
 * @example
 * ```js
 * const contractIns = await aeSdk.initializeContract({ sourceCode })
 * await contractIns.$deploy([321]) or await contractIns.init(321)
 * const callResult = await contractIns.$call('setState', [123])
 * const staticCallResult = await contractIns.$call('setState', [123], { callStatic: true })
 * ```
 * Also you can call contract like: `await contractIns.setState(123, options)`
 * Then sdk decide to make on-chain or static call (dry-run API) transaction based on function is
 * stateful or not
 */
class Contract {
  /**
   * Compile contract
   * @returns bytecode
   */
  async $compile() {
    if (this.$options.bytecode != null) return this.$options.bytecode;
    if (this.$options.onCompiler == null) throw new IllegalArgumentError('Can\'t compile without compiler');
    if (this.$options.sourceCode != null) {
      const {
        bytecode
      } = await this.$options.onCompiler.compileBySourceCode(this.$options.sourceCode, this.$options.fileSystem);
      this.$options.bytecode = bytecode;
    }
    if (this.$options.sourceCodePath != null) {
      const {
        bytecode
      } = await this.$options.onCompiler.compile(this.$options.sourceCodePath);
      this.$options.bytecode = bytecode;
    }
    if (this.$options.bytecode == null) {
      throw new IllegalArgumentError('Can\'t compile without sourceCode and sourceCodePath');
    }
    return this.$options.bytecode;
  }
  async $getCallResultByTxHash(hash, fnName, options) {
    const {
      callInfo
    } = await this.$options.onNode.getTransactionInfoByHash(hash);
    if (callInfo == null) {
      throw new ContractError(`callInfo is not available for transaction ${hash}`);
    }
    const callInfoTyped = callInfo;
    return {
      ...Contract_classPrivateMethodGet(this, _getCallResult, _getCallResult2).call(this, callInfoTyped, fnName, undefined, options),
      result: callInfoTyped
    };
  }
  async _estimateGas(name, params, options = {}) {
    const {
      result
    } = await this.$call(name, params, {
      ...options,
      callStatic: true
    });
    if (result == null) throw new UnexpectedTsError();
    const {
      gasUsed
    } = result;
    // taken from https://github.com/aeternity/aepp-sdk-js/issues/1286#issuecomment-977814771
    return Math.floor(gasUsed * 1.25);
  }

  /**
   * Deploy contract
   * @param params - Contract init function arguments array
   * @param options - Options
   * @returns deploy info
   */
  async $deploy(params, options) {
    var _opt$gasLimit, _other$result;
    const {
      callStatic,
      ...opt
    } = {
      ...this.$options,
      ...options
    };
    if (this.$options.bytecode == null) await this.$compile();
    if (callStatic === true) return this.$call('init', params, {
      ...opt,
      callStatic
    });
    if (this.$options.address != null) throw new DuplicateContractError();
    if (opt.onAccount == null) throw new IllegalArgumentError('Can\'t deploy without account');
    const ownerId = opt.onAccount.address;
    if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\'t deploy without bytecode');
    const tx = await buildTxAsync({
      ...opt,
      tag: Tag.ContractCreateTx,
      gasLimit: (_opt$gasLimit = opt.gasLimit) !== null && _opt$gasLimit !== void 0 ? _opt$gasLimit : await this._estimateGas('init', params, opt),
      callData: this._calldata.encode(this._name, 'init', params),
      code: this.$options.bytecode,
      ownerId
    });
    const {
      hash,
      ...other
    } = await Contract_classPrivateMethodGet(this, _sendAndProcess, _sendAndProcess2).call(this, tx, 'init', {
      ...opt,
      onAccount: opt.onAccount
    });
    this.$options.address = buildContractIdByContractTx(tx);
    return {
      ...other,
      ...(((_other$result = other.result) === null || _other$result === void 0 ? void 0 : _other$result.log) != null && {
        decodedEvents: this.$decodeEvents(other.result.log, opt)
      }),
      owner: ownerId,
      transaction: hash,
      address: this.$options.address
    };
  }

  /**
   * Get function schema from contract ACI object
   * @param name - Function name
   * @returns function ACI
   */

  /**
   * Call contract function
   * @param fn - Function name
   * @param params - Array of function arguments
   * @param options - Array of function arguments
   * @returns CallResult
   */
  async $call(fn, params, options = {}) {
    var _opt$gasLimit2;
    const {
      callStatic,
      top,
      ...opt
    } = {
      ...this.$options,
      ...options
    };
    const fnAci = Contract_classPrivateMethodGet(this, _getFunctionAci, _getFunctionAci2).call(this, fn);
    const contractId = this.$options.address;
    const {
      onNode
    } = opt;
    if (fn == null) throw new MissingFunctionNameError();
    if (fn === 'init' && callStatic !== true) throw new InvalidMethodInvocationError('"init" can be called only via dryRun');
    if (fn !== 'init' && opt.amount != null && Number(opt.amount) > 0 && !fnAci.payable) {
      throw new NotPayableFunctionError(opt.amount, fn);
    }
    let callerId;
    try {
      if (opt.onAccount == null) throw new InternalError('Use fallback account');
      callerId = opt.onAccount.address;
    } catch (error) {
      const useFallbackAccount = callStatic === true && (error instanceof errors_TypeError && error.message === 'Account should be an address (ak-prefixed string), or instance of AccountBase, got undefined instead' || error instanceof NoWalletConnectedError || error instanceof InternalError && error.message === 'Use fallback account');
      if (!useFallbackAccount) throw error;
      callerId = DRY_RUN_ACCOUNT.pub;
    }
    const callData = this._calldata.encode(this._name, fn, params);
    if (callStatic === true) {
      if (opt.nonce == null) {
        const topOption = top != null && {
          [typeof top === 'number' ? 'height' : 'hash']: top
        };
        const account = await getAccount(callerId, {
          ...topOption,
          onNode
        }).catch(error => {
          if (!isAccountNotFoundError(error)) throw error;
          return {
            kind: 'basic',
            nonce: 0
          };
        });
        opt.nonce = account.kind === 'generalized' ? 0 : account.nonce + 1;
      }
      const txOpt = {
        ...opt,
        onNode,
        callData
      };
      let tx;
      if (fn === 'init') {
        if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\'t dry-run "init" without bytecode');
        tx = await buildTxAsync({
          ...txOpt,
          tag: Tag.ContractCreateTx,
          code: this.$options.bytecode,
          ownerId: callerId
        });
      } else {
        if (contractId == null) throw new MissingContractAddressError('Can\'t dry-run contract without address');
        tx = await buildTxAsync({
          ...txOpt,
          tag: Tag.ContractCallTx,
          callerId,
          contractId
        });
      }
      const {
        callObj,
        ...dryRunOther
      } = await txDryRun(tx, callerId, {
        ...opt,
        top
      });
      if (callObj == null) {
        throw new InternalError(`callObj is not available for transaction ${tx}`);
      }
      const callInfoTyped = callObj;
      return {
        ...dryRunOther,
        ...Contract_classPrivateMethodGet(this, _getCallResult, _getCallResult2).call(this, callInfoTyped, fn, tx, opt),
        tx: unpackTx(tx),
        result: callInfoTyped,
        rawTx: tx,
        hash: buildTxHash(tx),
        txData: undefined
      };
    }
    if (top != null) throw new IllegalArgumentError('Can\'t handle `top` option in on-chain contract call');
    if (contractId == null) throw new MissingContractAddressError('Can\'t call contract without address');
    const tx = await buildTxAsync({
      ...opt,
      tag: Tag.ContractCallTx,
      gasLimit: (_opt$gasLimit2 = opt.gasLimit) !== null && _opt$gasLimit2 !== void 0 ? _opt$gasLimit2 : await this._estimateGas(fn, params, opt),
      callerId,
      contractId,
      callData
    });
    if (opt.onAccount == null) throw new IllegalArgumentError('Can\'t call contract on chain without account');
    return Contract_classPrivateMethodGet(this, _sendAndProcess, _sendAndProcess2).call(this, tx, fn, {
      ...opt,
      onAccount: opt.onAccount
    });
  }

  /**
   * @param ctAddress - Contract address that emitted event
   * @param nameHash - Hash of emitted event name
   * @param options - Options
   * @returns Contract name
   * @throws {@link MissingEventDefinitionError}
   * @throws {@link AmbiguousEventDefinitionError}
   */

  /**
   * Decode Events
   * @param events - Array of encoded events (callRes.result.log)
   * @param options - Options
   * @returns DecodedEvents
   */
  $decodeEvents(events, {
    omitUnknown,
    ...opt
  } = {}) {
    return events.map(event => {
      const topics = event.topics.map(t => BigInt(t));
      let contractName;
      try {
        contractName = Contract_classPrivateMethodGet(this, _getContractNameByEvent, _getContractNameByEvent2).call(this, event.address, topics[0], opt);
      } catch (error) {
        if ((omitUnknown !== null && omitUnknown !== void 0 ? omitUnknown : false) && error instanceof MissingEventDefinitionError) return null;
        throw error;
      }
      const decoded = this._calldata.decodeEvent(contractName, event.data, topics);
      const [name, args] = Object.entries(decoded)[0];
      return {
        name,
        args,
        contract: {
          name: contractName,
          address: event.address
        }
      };
    }).filter(e => e != null);
  }
  static async initialize({
    onCompiler,
    onNode,
    bytecode,
    aci,
    address,
    sourceCodePath,
    sourceCode,
    fileSystem,
    validateBytecode,
    ...otherOptions
  }) {
    if (aci == null && onCompiler != null) {
      let res;
      if (sourceCodePath != null) res = await onCompiler.compile(sourceCodePath);
      if (sourceCode != null) res = await onCompiler.compileBySourceCode(sourceCode, fileSystem);
      if (res != null) {
        var _bytecode;
        aci = res.aci;
        (_bytecode = bytecode) !== null && _bytecode !== void 0 ? _bytecode : bytecode = res.bytecode;
      }
    }
    if (aci == null) throw new MissingContractDefError();
    if (address != null) {
      address = await resolveName(address, 'contract_pubkey', {
        resolveByNode: true,
        onNode
      });
    }
    if (address == null && sourceCode == null && sourceCodePath == null && bytecode == null) {
      throw new MissingContractAddressError('Can\'t create instance by ACI without address');
    }
    if (address != null) {
      const contract = await getContract(address, {
        onNode
      });
      if (contract.active == null) throw new InactiveContractError(address);
    }
    if (validateBytecode === true) {
      if (address == null) throw new MissingContractAddressError('Can\'t validate bytecode without contract address');
      const onChanBytecode = (await getContractByteCode(address, {
        onNode
      })).bytecode;
      let isValid = false;
      if (bytecode != null) isValid = bytecode === onChanBytecode;else if (sourceCode != null) {
        if (onCompiler == null) throw new IllegalArgumentError('Can\'t validate bytecode without compiler');
        isValid = await onCompiler.validateBySourceCode(onChanBytecode, sourceCode, fileSystem);
      } else if (sourceCodePath != null) {
        if (onCompiler == null) throw new IllegalArgumentError('Can\'t validate bytecode without compiler');
        isValid = await onCompiler.validate(onChanBytecode, sourceCodePath);
      }
      if (!isValid) {
        throw new BytecodeMismatchError((sourceCode !== null && sourceCode !== void 0 ? sourceCode : sourceCodePath) != null ? 'source code' : 'bytecode');
      }
    }
    return new ContractWithMethods({
      onCompiler,
      onNode,
      sourceCode,
      sourceCodePath,
      bytecode,
      aci,
      address,
      fileSystem,
      ...otherOptions
    });
  }
  constructor({
    aci,
    ...otherOptions
  }) {
    Contract_classPrivateMethodInitSpec(this, _getContractNameByEvent);
    Contract_classPrivateMethodInitSpec(this, _getFunctionAci);
    Contract_classPrivateMethodInitSpec(this, _sendAndProcess);
    Contract_classPrivateMethodInitSpec(this, _getCallResult);
    Contract_classPrivateFieldInitSpec(this, _aciContract, {
      writable: true,
      value: void 0
    });
    this._aci = aci;
    const aciLast = aci[aci.length - 1];
    if (aciLast.contract == null) {
      throw new IllegalArgumentError(`The last 'aci' item should have 'contract' key, got ${Object.keys(aciLast)} keys instead`);
    }
    classPrivateFieldSet_default()(this, _aciContract, aciLast.contract);
    this._name = classPrivateFieldGet_default()(this, _aciContract).name;
    this._calldata = new aepp_calldata_.Encoder(aci);
    this.$options = otherOptions;

    /**
     * Generate proto function based on contract function using Contract ACI schema
     * All function can be called like:
     * ```js
     * await contract.testFunction()
     * ```
     * then sdk will decide to use dry-run or send tx
     * on-chain base on if function stateful or not.
     * Also, you can manually do that:
     * ```js
     * await contract.testFunction({ callStatic: true }) // use call-static (dry-run)
     * await contract.testFunction({ callStatic: false }) // send tx on-chain
     * ```
     */
    Object.assign(this, Object.fromEntries(classPrivateFieldGet_default()(this, _aciContract).functions.map(({
      name,
      arguments: aciArgs,
      stateful
    }) => {
      const callStatic = name !== 'init' && !stateful;
      return [name, async (...args) => {
        const options = args.length === aciArgs.length + 1 ? args.pop() : {};
        if (typeof options !== 'object') throw new errors_TypeError(`Options should be an object: ${options}`);
        if (name === 'init') return this.$deploy(args, {
          callStatic,
          ...options
        });
        return this.$call(name, args, {
          callStatic,
          ...options
        });
      }];
    })));
  }
}
function _getCallResult2({
  returnType,
  returnValue,
  log
}, fnName, transaction, options) {
  let message;
  switch (returnType) {
    case 'ok':
      {
        const fnAci = Contract_classPrivateMethodGet(this, _getFunctionAci, _getFunctionAci2).call(this, fnName);
        return {
          decodedResult: this._calldata.decode(this._name, fnAci.name, returnValue),
          decodedEvents: this.$decodeEvents(log, options)
        };
      }
    case 'revert':
      message = this._calldata.decodeFateString(returnValue);
      break;
    case 'error':
      message = decode(returnValue).toString();
      break;
    default:
      throw new InternalError(`Unknown return type: ${returnType}`);
  }
  throw new NodeInvocationError(message, transaction);
}
async function _sendAndProcess2(tx, fnName, options) {
  const txData = await sendTransaction(tx, {
    ...this.$options,
    ...options
  });
  return {
    hash: txData.hash,
    tx: unpackTx(txData.rawTx),
    txData,
    rawTx: txData.rawTx,
    ...(txData.blockHeight != null && (await this.$getCallResultByTxHash(txData.hash, fnName, options)))
  };
}
function _getFunctionAci2(name) {
  const fn = classPrivateFieldGet_default()(this, _aciContract).functions.find(f => f.name === name);
  if (fn != null) {
    return fn;
  }
  if (name === 'init') {
    return {
      arguments: [],
      name: 'init',
      payable: false,
      returns: 'unit',
      stateful: true
    };
  }
  throw new NoSuchContractFunctionError(`Function ${name} doesn't exist in contract`);
}
function _getContractNameByEvent2(ctAddress, nameHash, {
  contractAddressToName
}) {
  const addressToName = {
    ...this.$options.contractAddressToName,
    ...contractAddressToName
  };
  if (addressToName[ctAddress] != null) return addressToName[ctAddress];

  // TODO: consider using a third-party library
  const isEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);
  const contracts = this._aci.map(({
    contract
  }) => contract).filter(contract => contract === null || contract === void 0 ? void 0 : contract.event);
  const matchedEvents = contracts.map(contract => [contract.name, contract.event.variant]).map(([name, events]) => events.map(event => [name, Object.keys(event)[0], Object.values(event)[0]])).flat().filter(([, eventName]) => BigInt(`0x${hash(eventName).toString('hex')}`) === nameHash).filter(([,, type], idx, arr) => !arr.slice(0, idx).some(el => isEqual(el[2], type)));
  switch (matchedEvents.length) {
    case 0:
      throw new MissingEventDefinitionError(nameHash.toString(), ctAddress);
    case 1:
      return matchedEvents[0][0];
    default:
      throw new AmbiguousEventDefinitionError(ctAddress, matchedEvents);
  }
}
// eslint-disable-next-line @typescript-eslint/no-redeclare
const ContractWithMethods = Contract;
/* harmony default export */ const contract_Contract = (ContractWithMethods);
;// CONCATENATED MODULE: ./src/oracle.ts
/**
 * Oracle methods - routines to interact with the ternity oracle system
 *
 * The high-level description of the oracle system is
 * https://github.com/aeternity/protocol/blob/master/ORACLE.md in the protocol
 * repository.
 */









/**
 * Poll for oracle queries
 * @category oracle
 * @param oracleId - Oracle public key
 * @param onQuery - OnQuery callback
 * @param options - Options object
 * @param options.interval - Poll interval(default: 5000)
 * @param options.onNode - Node to use
 * @returns Callback to stop polling function
 */
function pollForQueries(oracleId, onQuery, {
  interval,
  onNode,
  ...options
}) {
  var _interval;
  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);
  const knownQueryIds = new Set();
  const checkNewQueries = async () => {
    var _await$onNode$getOrac;
    const queries = ((_await$onNode$getOrac = (await onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries) !== null && _await$onNode$getOrac !== void 0 ? _await$onNode$getOrac : []).filter(({
      id
    }) => !knownQueryIds.has(id));
    queries.forEach(query => {
      knownQueryIds.add(query.id);
      onQuery(query);
    });
  };
  let stopped = false;

  // eslint-disable-next-line @typescript-eslint/no-floating-promises
  (async () => {
    while (!stopped) {
      // eslint-disable-line no-unmodified-loop-condition
      // TODO: allow to handle this error somehow
      await checkNewQueries().catch(console.error);
      await pause(interval);
    }
  })();
  return () => {
    stopped = true;
  };
}

/**
 * Poll for oracle query response
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle Query id
 * @param options - Options object
 * @param options.interval - Poll interval
 * @param options.onNode - Node to use
 * @returns OracleQuery object
 */
async function pollForQueryResponse(oracleId, queryId, {
  interval,
  onNode,
  ...options
}) {
  var _interval2;
  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('microblock', options);
  let height;
  let ttl;
  let response;
  do {
    ({
      response,
      ttl
    } = await onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId));
    const responseBuffer = decode(response);
    if (responseBuffer.length > 0) return responseBuffer.toString();
    await pause(interval);
    height = await getHeight({
      onNode
    });
  } while (ttl >= height);
  throw new RequestTimedOutError(height);
}

/**
 * Constructor for OracleQuery Object (helper object for using OracleQuery)
 * @category oracle
 * @param oracleId - Oracle public key
 * @param queryId - Oracle Query id
 * @param options - Options
 * @returns OracleQuery object
 */
async function getQueryObject(oracleId, queryId, options) {
  const record = await options.onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId);
  return {
    ...record,
    decodedQuery: decode(record.query).toString(),
    decodedResponse: decode(record.response).toString(),
    respond: async (response, opt) =>
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    respondToQuery(queryId, response, {
      ...options,
      ...opt
    }),
    pollForResponse: async opt => pollForQueryResponse(oracleId, queryId, {
      ...options,
      ...opt
    })
  };
}
/**
 * Post query to oracle
 * @category oracle
 * @param oracleId - Oracle public key
 * @param query - Oracle query object
 * @param options - Options object
 * @param options.queryTtl - queryTtl Oracle query time to leave
 * @param options.responseTtl - queryFee Oracle query response time to leave
 * @param options.queryFee - queryFee Oracle query fee
 * @param options.fee - fee Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Query object
 */
async function postQueryToOracle(oracleId, query, options) {
  var _options$queryFee;
  (_options$queryFee = options.queryFee) !== null && _options$queryFee !== void 0 ? _options$queryFee : options.queryFee = (await options.onNode.getOracleByPubkey(oracleId)).queryFee.toString();
  const senderId = options.onAccount.address;
  const oracleQueryTx = await buildTxAsync({
    queryTtlType: QUERY_TTL.type,
    queryTtlValue: QUERY_TTL.value,
    responseTtlType: RESPONSE_TTL.type,
    responseTtlValue: RESPONSE_TTL.value,
    ...options,
    tag: Tag.OracleQueryTx,
    oracleId,
    senderId,
    query
  });
  const {
    nonce
  } = unpackTx(oracleQueryTx, Tag.OracleQueryTx);
  const queryId = oracleQueryId(senderId, nonce, oracleId);
  return {
    ...(await sendTransaction(oracleQueryTx, options)),
    ...(await getQueryObject(oracleId, queryId, options))
  };
}
/**
 * Extend oracle ttl
 * @category oracle
 * @param options - Options object
 * @param options.fee - fee Transaction fee
 * @param options.ttl - Transaction time to leave
 * @param options.oracleTtlType - Oracle time to leave for extend
 * @param options.oracleTtlValue - Oracle time to leave for extend
 * @returns Oracle object
 */
async function extendOracleTtl(options) {
  const oracleId = encode(decode(options.onAccount.address), Encoding.OracleAddress);
  const oracleExtendTx = await buildTxAsync({
    oracleTtlType: ORACLE_TTL.type,
    oracleTtlValue: ORACLE_TTL.value,
    ...options,
    tag: Tag.OracleExtendTx,
    oracleId
  });
  return {
    ...(await sendTransaction(oracleExtendTx, options)),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    ...(await getOracleObject(oracleId, options))
  };
}
/**
 * Extend oracle ttl
 * @category oracle
 * @param queryId - Oracle query id
 * @param response - Oracle query response
 * @param options - Options object
 * @param options.responseTtl - responseTtl Query response time to leave
 * @param options.fee - Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Oracle object
 */
async function respondToQuery(queryId, response, options) {
  const oracleId = encode(decode(options.onAccount.address), Encoding.OracleAddress);
  const oracleRespondTx = await buildTxAsync({
    responseTtlType: RESPONSE_TTL.type,
    responseTtlValue: RESPONSE_TTL.value,
    ...options,
    tag: Tag.OracleResponseTx,
    oracleId,
    queryId,
    response
  });
  return {
    ...(await sendTransaction(oracleRespondTx, options)),
    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    ...(await getOracleObject(oracleId, options))
  };
}
/**
 * Constructor for Oracle Object (helper object for using Oracle)
 * @category oracle
 * @param oracleId - Oracle public key
 * @param options - Options
 * @returns Oracle object
 */
async function getOracleObject(oracleId, options) {
  return {
    ...(await options.onNode.getOracleByPubkey(oracleId)),
    queries: (await options.onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries,
    ...mapObject({
      pollQueries: pollForQueries,
      postQuery: postQueryToOracle,
      respondToQuery,
      extendOracle: extendOracleTtl,
      getQuery: getQueryObject
    }, ([name, handler]) => [name, (...args) => {
      const lastArg = args[args.length - 1];
      if (lastArg != null && typeof lastArg === 'object' && lastArg.constructor === Object) {
        Object.assign(lastArg, {
          ...options,
          ...lastArg
        });
      } else args.push(options);
      return handler(...(['extendOracle', 'respondToQuery'].includes(name) ? [] : [oracleId]), ...args);
    }])
  };
}
/**
 * Register oracle
 * @category oracle
 * @param queryFormat - Format of query
 * @param responseFormat - Format of query response
 * @param options - Options
 * @param options.queryFee - Oracle query Fee
 * @param options - Options object
 * @param options.abiVersion - Always 0 (do not use virtual machine)
 * @param options.fee - Transaction fee
 * @param options.ttl - Transaction time to leave
 * @returns Oracle object
 */
async function registerOracle(queryFormat, responseFormat, options) {
  const accountId = options.onAccount.address;
  const oracleRegisterTx = await buildTxAsync({
    oracleTtlValue: ORACLE_TTL.value,
    oracleTtlType: ORACLE_TTL.type,
    ...options,
    tag: Tag.OracleRegisterTx,
    accountId,
    queryFormat,
    responseFormat
  });
  return {
    ...(await sendTransaction(oracleRegisterTx, options)),
    ...(await getOracleObject(encode(decode(accountId), Encoding.OracleAddress), options))
  };
}
;// CONCATENATED MODULE: ./src/spend.ts





/**
 * Send coins to another account
 * @category chain
 * @param amount - Amount to spend
 * @param recipientIdOrName - Address or name of recipient account
 * @param options - Options
 * @returns Transaction
 */
async function spend(amount, recipientIdOrName, options) {
  return sendTransaction(await buildTxAsync({
    ...options,
    tag: Tag.SpendTx,
    senderId: options.onAccount.address,
    recipientId: await resolveName(recipientIdOrName, 'account_pubkey', options),
    amount
  }), options);
}
// TODO: Rename to spendFraction
/**
 * Spend a fraction of coin balance to another account. Useful if needed to drain account balance
 * completely, sending funds to another account (with fraction set to 1).
 * @category chain
 * @param fraction - Fraction of balance to spend (between 0 and 1)
 * @param recipientIdOrName - Address or name of recipient account
 * @param options - Options
 * @example
 * ```js
 * // `fraction` * 100 = % of AE to be transferred (e.g. `0.42` for 42% or `1` for 100%)
 * const { blockHeight } = await aeSdk.transferFunds(
 *   0.42,
 *   'ak_21A27UVVt3hDkBE5J7rhhqnH5YNb4Y1dqo4PnSybrH85pnWo7E',
 * );
 * console.log('Transaction mined at', blockHeight);
 * ```
 */
async function transferFunds(fraction,
// TODO: accept only number
recipientIdOrName, options) {
  if (+fraction < 0 || +fraction > 1) {
    throw new ArgumentError('fraction', 'a number between 0 and 1', fraction);
  }
  const recipientId = await resolveName(recipientIdOrName, 'account_pubkey', options);
  const senderId = options.onAccount.address;
  const balance = new (external_bignumber_js_default())(await getBalance.bind(options.onAccount)(senderId, options));
  const desiredAmount = balance.times(fraction).integerValue((external_bignumber_js_default()).ROUND_HALF_UP);
  const {
    fee
  } = unpackTx(await buildTxAsync({
    ...options,
    tag: Tag.SpendTx,
    senderId,
    recipientId,
    amount: desiredAmount
  }), Tag.SpendTx);
  // Reducing of the amount may reduce transaction fee, so this is not completely accurate
  const amount = desiredAmount.plus(fee).gt(balance) ? balance.minus(fee) : desiredAmount;
  return sendTransaction(await buildTxAsync({
    ...options,
    tag: Tag.SpendTx,
    senderId,
    recipientId,
    amount
  }), options);
}
/**
 * Submit transaction of another account paying for it (fee and gas)
 * @category chain
 * @param transaction - tx_<base64>-encoded transaction
 * @param options - Options
 * @returns Object Transaction
 */
async function payForTransaction(transaction, options) {
  return sendTransaction(await buildTxAsync({
    ...options,
    tag: Tag.PayingForTx,
    payerId: options.onAccount.address,
    tx: transaction
  }), options);
}
;// CONCATENATED MODULE: ./src/contract/ga.ts
/**
 * Generalized Account module - routines to use generalized account
 */









/**
 * Convert current account to GA
 * @category contract
 * @param authFnName - Authorization function name
 * @param sourceCode - Auth contract source code
 * @param args - init arguments
 * @param options - Options
 * @returns General Account Object
 */
async function createGeneralizedAccount(authFnName, args, {
  onAccount,
  onCompiler,
  onNode,
  bytecode,
  aci,
  sourceCodePath,
  sourceCode,
  fileSystem,
  ...options
}) {
  var _options$gasLimit;
  const ownerId = onAccount.address;
  if ((await getAccount(ownerId, {
    onNode
  })).kind === 'generalized') {
    throw new IllegalArgumentError(`Account ${ownerId} is already GA`);
  }
  const contract = await contract_Contract.initialize({
    onAccount,
    onCompiler,
    onNode,
    bytecode,
    aci,
    sourceCodePath,
    sourceCode,
    fileSystem
  });
  const tx = await buildTxAsync({
    ...options,
    tag: Tag.GaAttachTx,
    onNode,
    code: await contract.$compile(),
    gasLimit: (_options$gasLimit = options.gasLimit) !== null && _options$gasLimit !== void 0 ? _options$gasLimit : await contract._estimateGas('init', args, options),
    ownerId,
    callData: contract._calldata.encode(contract._name, 'init', args),
    authFun: hash(authFnName)
  });
  const contractId = buildContractIdByContractTx(tx);
  const {
    hash: transaction,
    rawTx
  } = await sendTransaction(tx, {
    onNode,
    onAccount,
    onCompiler,
    ...options
  });
  return Object.freeze({
    owner: ownerId,
    transaction,
    rawTx,
    gaContractId: contractId
  });
}
/**
 * Build a transaction hash the same as `Auth.tx_hash` by GaMetaTx payload
 * @category contract
 * @param transaction - tx-encoded transaction
 * @param options - Options
 * @param options.fee - GaMetaTx fee, required in Ceres
 * @param options.gasPrice - GaMetaTx gasPrice, required in Ceres
 * @param options.onNode - Node to use
 * @returns Transaction hash
 */
async function buildAuthTxHash(transaction, {
  fee,
  gasPrice,
  onNode
}) {
  const {
    nodeNetworkId,
    consensusProtocolVersion
  } = await onNode.getNodeInfo();
  let payload = hash(concatBuffers([Buffer.from(nodeNetworkId), decode(transaction)]));
  if (consensusProtocolVersion === ConsensusProtocolVersion.Ceres) {
    if (fee == null) throw new ArgumentError('fee', 'provided (in Ceres)', fee);
    if (gasPrice == null) throw new ArgumentError('gasPrice', 'provided (in Ceres)', gasPrice);
    payload = hash(decode(buildTx({
      tag: Tag.GaMetaTxAuthData,
      fee,
      gasPrice,
      txHash: encode(payload, Encoding.TxHash)
    })));
  }
  return payload;
}

/**
 * Build a transaction hash the same as `Auth.tx_hash` by GaMetaTx
 * @category contract
 * @param transaction - tx-encoded signed GaMeta transaction
 * @param options - Options
 * @param options.onNode - Node to use
 * @returns Transaction hash
 */
async function buildAuthTxHashByGaMetaTx(transaction, {
  onNode
}) {
  const txParams = unpackTx(transaction, Tag.SignedTx);
  if (txParams.encodedTx.tag !== Tag.GaMetaTx) {
    throw new ArgumentError('transaction', 'to include GaMetaTx', Tag[txParams.encodedTx.tag]);
  }
  return buildAuthTxHash(buildTx(txParams.encodedTx.tx.encodedTx), {
    fee: txParams.encodedTx.fee,
    gasPrice: txParams.encodedTx.gasPrice,
    onNode
  });
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/helpers/defineProperty.js
var defineProperty = __webpack_require__(1125);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty);
;// CONCATENATED MODULE: ./src/contract/delegation-signature.ts



function ensureOracleQuery(oq) {
  if (!oq.startsWith('oq_')) throw new ArgumentError('oq', 'oracle query', oq);
}

/**
 * Helper to generate a signature to delegate
 *  - pre-claim/claim/transfer/revoke of a name to a contract.
 *  - register/extend/respond of an Oracle to a contract.
 * @category contract
 * @param contractAddress - Address of contract to delegate access
 * @param ids - The list of id's to prepend
 * @param options - Options
 * @param options.omitAddress - Prepend delegation signature with an account address
 * @param options.onAccount - Account to use
 * @param options.onNode - Node to use
 * @returns Signature
 * @deprecated use methods `sign*DelegationToContract` of Account instance instead
 * @example
 * ```js
 * const aeSdk = new AeSdk({ ... })
 * const contractAddress = 'ct_asd2ks...'
 * const aensName = 'example.chain'
 * const onAccount = new MemoryAccount(...) // Sign with a specific account
 * // Preclaim signature
 * const preclaimSig = await aeSdk.createDelegationSignature(contractAddress, [], { onAccount })
 * // Claim, transfer and revoke signature
 * const aensDelegationSig = await aeSdk
 *   .createDelegationSignature(contractAddress, [aensName], { onAccount })
 *
 * const oracleQueryId = 'oq_...'
 * const onAccount = new MemoryAccount(...) // Sign with a specific account
 * // Oracle register and extend signature
 * const oracleDelegationSig = await aeSdk
 *   .createDelegationSignature(contractAddress, [], { onAccount })
 * // Oracle respond signature
 * const respondSig = await aeSdk
 *   .createDelegationSignature(contractAddress, [oracleQueryId], { onAccount, omitAddress: true })
 * ```
 */
async function createDelegationSignature(contractAddress, ids, {
  onAccount,
  omitAddress,
  ...options
}) {
  if (ids.length > 1) throw new ArgumentError('ids', 'shorter than 2', ids);
  const networkId = await options.onNode.getNetworkId();
  if (ids.length === 0) {
    if (omitAddress === true) {
      throw new ArgumentError('omitAddress', 'equal false', omitAddress);
    }
    return decode(await onAccount.signDelegationToContract(contractAddress, {
      networkId
    }));
  }
  const [payload] = ids;
  if (isNameValid(payload)) {
    if (omitAddress === true) {
      throw new ArgumentError('omitAddress', 'equal false', omitAddress);
    }
    return decode(await onAccount.signNameDelegationToContract(contractAddress, payload, {
      networkId
    }));
  }
  ensureOracleQuery(payload);
  if (omitAddress !== true) {
    throw new ArgumentError('omitAddress', 'equal true', omitAddress);
  }
  return decode(await onAccount.signOracleQueryDelegationToContract(contractAddress, payload, {
    networkId
  }));
}
;// CONCATENATED MODULE: ./src/AeSdkMethods.ts










function getValueOrErrorProxy(valueCb) {
  return new Proxy({}, Object.fromEntries(['apply', 'construct', 'defineProperty', 'deleteProperty', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf', 'get', 'has'].map(name => [name, (t, ...args) => {
    const target = valueCb(); // to get a native exception in case it missed
    const res = Reflect[name](target, ...args);
    return typeof res === 'function' && name === 'get' ? res.bind(target) // otherwise it fails with attempted to get private field on non-instance
    : res;
  }])));
}
const {
  InvalidTxError: _2,
  ...chainMethodsOther
} = chain_namespaceObject;
const methods = {
  ...chainMethodsOther,
  ...aens_namespaceObject,
  ...spend_namespaceObject,
  ...oracle_namespaceObject,
  createDelegationSignature: createDelegationSignature,
  ...ga_namespaceObject
};
/**
 * AeSdkMethods is the composition of:
 * - chain methods
 * - tx methods
 * - aens methods
 * - spend methods
 * - oracle methods
 * - contract methods
 * - contract ga methods
 *
 * While these methods can be used separately, this class provides a handy way to store
 * their context (current account, network, and compiler to use).
 */
class AeSdkMethods {
  /**
   * @param options - Options
   */
  constructor(options = {}) {
    defineProperty_default()(this, "_options", {});
    Object.assign(this._options, options);
  }
  _getOptions(callOptions = {}) {
    return {
      ...this._options,
      onAccount: getValueOrErrorProxy(() => this._options.onAccount),
      onNode: getValueOrErrorProxy(() => this._options.onNode),
      onCompiler: getValueOrErrorProxy(() => this._options.onCompiler),
      ...callOptions
    };
  }
  async buildTx(options) {
    return buildTxAsync({
      ...this._getOptions(),
      ...options
    });
  }
  async initializeContract(options) {
    return contract_Contract.initialize(this._getOptions(options));
  }
}
Object.assign(AeSdkMethods.prototype, mapObject(methods, ([name, handler]) => [name, function methodWrapper(...args) {
  args.length = handler.length;
  const options = args[args.length - 1];
  args[args.length - 1] = this._getOptions(options);
  return handler(...args);
}]));
// eslint-disable-next-line @typescript-eslint/no-redeclare
const AeSdkMethodsTyped = AeSdkMethods;
/* harmony default export */ const src_AeSdkMethods = (AeSdkMethodsTyped);
;// CONCATENATED MODULE: ./src/AeSdkBase.ts



/**
 * Basic AeSdk class implements:
 * - node selector,
 * - integrated compiler support,
 * - wrappers of account methods mapped to the current account.
 */
class AeSdkBase extends src_AeSdkMethods {
  /**
   * @param options - Options
   * @param options.nodes - Array of nodes
   */
  constructor({
    nodes = [],
    ...options
  } = {}) {
    super(options);
    defineProperty_default()(this, "pool", new Map());
    nodes.forEach(({
      name,
      instance
    }, i) => this.addNode(name, instance, i === 0));
  }

  // TODO: consider dropping this getter, because:
  // compiler is not intended to be used separately any more (functionality limited to sdk needs)
  // and user creates its instance by himself
  get compilerApi() {
    if (this._options.onCompiler == null) {
      throw new CompilerError('You can\'t use Compiler API. Compiler is not ready!');
    }
    return this._options.onCompiler;
  }
  get api() {
    this.ensureNodeConnected();
    return this.pool.get(this.selectedNodeName);
  }

  /**
   * Add Node
   * @param name - Node name
   * @param node - Node instance
   * @param select - Select this node as current
   * @example
   * ```js
   * // add and select new node with name 'testNode'
   * aeSdkBase.addNode('testNode', new Node({ url }), true)
   * ```
   */
  addNode(name, node, select = false) {
    if (this.pool.has(name)) throw new DuplicateNodeError(name);
    this.pool.set(name, node);
    if (select || this.selectedNodeName == null) {
      this.selectNode(name);
    }
  }

  /**
   * Select Node
   * @param name - Node name
   * @example
   * nodePool.selectNode('testNode')
   */
  selectNode(name) {
    if (!this.pool.has(name)) throw new NodeNotFoundError(`Node with name ${name} not in pool`);
    this.selectedNodeName = name;
  }

  /**
   * Check if you have selected node
   * @example
   * nodePool.isNodeConnected()
   */
  isNodeConnected() {
    return this.selectedNodeName != null;
  }
  ensureNodeConnected() {
    if (!this.isNodeConnected()) {
      throw new NodeNotFoundError('You can\'t use Node API. Node is not connected or not defined!');
    }
  }

  /**
   * Get information about node
   * @example
   * ```js
   * nodePool.getNodeInfo() // { name, version, networkId, protocol, ... }
   * ```
   */
  async getNodeInfo() {
    this.ensureNodeConnected();
    return {
      name: this.selectedNodeName,
      ...(await this.api.getNodeInfo())
    };
  }

  /**
   * Get array of available nodes
   * @example
   * nodePool.getNodesInPool()
   */
  async getNodesInPool() {
    return Promise.all(Array.from(this.pool.entries()).map(async ([name, node]) => ({
      name,
      ...(await node.getNodeInfo())
    })));
  }

  // eslint-disable-next-line class-methods-use-this
  addresses() {
    return [];
  }

  /**
   * Resolves an account
   * @param account - ak-address, instance of AccountBase, or keypair
   */
  _resolveAccount(account = this._options.onAccount) {
    if (typeof account === 'string') throw new NotImplementedError('Address in AccountResolver');
    if (typeof account === 'object') return account;
    throw new errors_TypeError('Account should be an address (ak-prefixed string), ' + `or instance of AccountBase, got ${String(account)} instead`);
  }
  get address() {
    return this._resolveAccount().address;
  }
  async sign(data, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).sign(data, options);
  }
  async signTransaction(tx, {
    onAccount,
    ...options
  } = {}) {
    const networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signTransaction(tx, {
      networkId,
      ...options
    });
  }
  async signMessage(message, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).signMessage(message, options);
  }
  async signTypedData(data, aci, {
    onAccount,
    ...options
  } = {}) {
    return this._resolveAccount(onAccount).signTypedData(data, aci, options);
  }
  async signDelegationToContract(contractAddress, {
    onAccount,
    ...options
  } = {}) {
    var _options$networkId;
    (_options$networkId = options.networkId) !== null && _options$networkId !== void 0 ? _options$networkId : options.networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signDelegationToContract(contractAddress, options);
  }
  async signNameDelegationToContract(contractAddress, name, {
    onAccount,
    ...options
  } = {}) {
    var _options$networkId2;
    (_options$networkId2 = options.networkId) !== null && _options$networkId2 !== void 0 ? _options$networkId2 : options.networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signNameDelegationToContract(contractAddress, name, options);
  }
  async signOracleQueryDelegationToContract(contractAddress, oracleQueryId, {
    onAccount,
    ...options
  } = {}) {
    var _options$networkId3;
    (_options$networkId3 = options.networkId) !== null && _options$networkId3 !== void 0 ? _options$networkId3 : options.networkId = this.selectedNodeName !== null ? await this.api.getNetworkId() : undefined;
    return this._resolveAccount(onAccount).signOracleQueryDelegationToContract(contractAddress, oracleQueryId, options);
  }
  _getOptions(callOptions = {}) {
    return {
      ...this._options,
      onNode: getValueOrErrorProxy(() => this.api),
      onCompiler: getValueOrErrorProxy(() => this.compilerApi),
      ...callOptions,
      onAccount: getValueOrErrorProxy(() => this._resolveAccount(callOptions.onAccount))
    };
  }
}
;// CONCATENATED MODULE: ./src/AeSdk.ts




class AeSdk extends AeSdkBase {
  constructor({
    accounts,
    ...options
  } = {}) {
    super(options);
    defineProperty_default()(this, "accounts", {});
    accounts === null || accounts === void 0 ? void 0 : accounts.forEach((account, idx) => this.addAccount(account, {
      select: idx === 0
    }));
  }
  _resolveAccount(account = this.selectedAddress) {
    if (typeof account === 'string') {
      const address = account;
      decode(address);
      if (this.accounts[address] == null) throw new UnavailableAccountError(account);
      account = this.accounts[address];
    }
    return super._resolveAccount(account);
  }

  /**
   * Get accounts addresses
   * @example addresses()
   */
  addresses() {
    return Object.keys(this.accounts);
  }

  /**
   * Add specific account
   * @param account - Account instance
   * @param options - Options
   * @param options.select - Select account
   * @example addAccount(account)
   */
  addAccount(account, {
    select
  } = {}) {
    const {
      address
    } = account;
    this.accounts[address] = account;
    if (select === true) this.selectAccount(address);
  }

  /**
   * Remove specific account
   * @param address - Address of account to remove
   * @example removeAccount(address)
   */
  removeAccount(address) {
    if (this.accounts[address] == null) throw new UnavailableAccountError(address);
    delete this.accounts[address]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
    if (this.selectedAddress === address) delete this.selectedAddress;
  }

  /**
   * Select specific account
   * @param address - Address of account to select
   * @example selectAccount('ak_xxxxxxxx')
   */
  selectAccount(address) {
    decode(address);
    if (this.accounts[address] == null) throw new UnavailableAccountError(address);
    this.selectedAddress = address;
  }
}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/schema.ts

// eslint-disable-next-line max-classes-per-file



/**
 * @category aepp wallet communication
 */
let MESSAGE_DIRECTION = /*#__PURE__*/function (MESSAGE_DIRECTION) {
  MESSAGE_DIRECTION["to_waellet"] = "to_waellet";
  MESSAGE_DIRECTION["to_aepp"] = "to_aepp";
  return MESSAGE_DIRECTION;
}({});

/**
 * @category aepp wallet communication
 */
let WALLET_TYPE = /*#__PURE__*/function (WALLET_TYPE) {
  WALLET_TYPE["window"] = "window";
  WALLET_TYPE["extension"] = "extension";
  return WALLET_TYPE;
}({});

/**
 * @category aepp wallet communication
 */
let SUBSCRIPTION_TYPES = /*#__PURE__*/function (SUBSCRIPTION_TYPES) {
  SUBSCRIPTION_TYPES["subscribe"] = "subscribe";
  SUBSCRIPTION_TYPES["unsubscribe"] = "unsubscribe";
  return SUBSCRIPTION_TYPES;
}({});

/**
 * @category aepp wallet communication
 */
let METHODS = /*#__PURE__*/function (METHODS) {
  METHODS["readyToConnect"] = "connection.announcePresence";
  METHODS["updateAddress"] = "address.update";
  METHODS["address"] = "address.get";
  METHODS["connect"] = "connection.open";
  METHODS["sign"] = "transaction.sign";
  METHODS["signMessage"] = "message.sign";
  METHODS["signTypedData"] = "typedData.sign";
  METHODS["signDelegationToContract"] = "delegationToContract.sign";
  METHODS["subscribeAddress"] = "address.subscribe";
  METHODS["updateNetwork"] = "networkId.update";
  METHODS["closeConnection"] = "connection.close";
  return METHODS;
}({});

/**
 * @category aepp wallet communication
 */
let RPC_STATUS = /*#__PURE__*/function (RPC_STATUS) {
  RPC_STATUS["CONNECTED"] = "CONNECTED";
  RPC_STATUS["DISCONNECTED"] = "DISCONNECTED";
  RPC_STATUS["WAITING_FOR_CONNECTION_REQUEST"] = "WAITING_FOR_CONNECTION_REQUEST";
  return RPC_STATUS;
}({});
const rpcErrors = [];

/**
 * @category exception
 */
class RpcError extends BaseError {
  toJSON() {
    return {
      code: this.code,
      message: this.message,
      data: this.data
    };
  }
  static deserialize(json) {
    const RpcErr = rpcErrors.find(cl => cl.code === json.code);
    if (RpcErr == null) throw new InternalError(`Can't find RpcError with code: ${json.code}`);
    return new RpcErr(json.data);
  }
}

/**
 * @category exception
 */
class RpcInvalidTransactionError extends RpcError {
  constructor(data) {
    super('Invalid transaction');
    defineProperty_default()(this, "code", 2);
    this.data = data;
    this.name = 'RpcInvalidTransactionError';
  }
}
defineProperty_default()(RpcInvalidTransactionError, "code", 2);
rpcErrors.push(RpcInvalidTransactionError);

/**
 * @category exception
 */
class RpcRejectedByUserError extends RpcError {
  constructor(data) {
    super('Operation rejected by user');
    defineProperty_default()(this, "code", 4);
    this.data = data;
    this.name = 'RpcRejectedByUserError';
  }
}
defineProperty_default()(RpcRejectedByUserError, "code", 4);
rpcErrors.push(RpcRejectedByUserError);

/**
 * @category exception
 */
class RpcUnsupportedProtocolError extends RpcError {
  constructor() {
    super('Unsupported Protocol Version');
    defineProperty_default()(this, "code", 5);
    this.name = 'RpcUnsupportedProtocolError';
  }
}
defineProperty_default()(RpcUnsupportedProtocolError, "code", 5);
rpcErrors.push(RpcUnsupportedProtocolError);

/**
 * @category exception
 */
class RpcConnectionDenyError extends RpcError {
  constructor(data) {
    super('Wallet deny your connection request');
    defineProperty_default()(this, "code", 9);
    this.data = data;
    this.name = 'RpcConnectionDenyError';
  }
}
defineProperty_default()(RpcConnectionDenyError, "code", 9);
rpcErrors.push(RpcConnectionDenyError);

/**
 * @category exception
 */
class RpcNotAuthorizeError extends RpcError {
  constructor() {
    super('You are not connected to the wallet');
    defineProperty_default()(this, "code", 10);
    this.name = 'RpcNotAuthorizeError';
  }
}
defineProperty_default()(RpcNotAuthorizeError, "code", 10);
rpcErrors.push(RpcNotAuthorizeError);

/**
 * @category exception
 */
class RpcPermissionDenyError extends RpcError {
  constructor(address) {
    super(`You are not subscribed for account ${address}`);
    defineProperty_default()(this, "code", 11);
    this.data = address;
    this.name = 'RpcPermissionDenyError';
  }
}
defineProperty_default()(RpcPermissionDenyError, "code", 11);
rpcErrors.push(RpcPermissionDenyError);

/**
 * @category exception
 */
class RpcInternalError extends RpcError {
  constructor() {
    super('The peer failed to execute your request due to unknown error');
    defineProperty_default()(this, "code", 12);
    this.name = 'RpcInternalError';
  }
}
defineProperty_default()(RpcInternalError, "code", 12);
rpcErrors.push(RpcInternalError);

/**
 * @category exception
 */
class RpcMethodNotFoundError extends RpcError {
  constructor() {
    super('Method not found');
    defineProperty_default()(this, "code", -32601);
    this.name = 'RpcMethodNotFoundError';
  }
}
defineProperty_default()(RpcMethodNotFoundError, "code", -32601);
rpcErrors.push(RpcMethodNotFoundError);
;// CONCATENATED MODULE: ./src/account/Rpc.ts



/**
 * Account provided by wallet
 * @param params - Params
 * @param params.rpcClient - RpcClient instance
 * @param params.address - RPC account address
 * @returns AccountRpc instance
 */
class AccountRpc extends AccountBase {
  constructor(rpcClient, address) {
    super();
    this._rpcClient = rpcClient;
    this.address = address;
  }

  // eslint-disable-next-line class-methods-use-this
  async sign() {
    throw new NotImplementedError('RAW signing using wallet');
  }
  async signTransaction(tx, {
    innerTx,
    networkId
  } = {}) {
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const res = await this._rpcClient.request(METHODS.sign, {
      onAccount: this.address,
      tx,
      returnSigned: true,
      networkId,
      innerTx
    });
    if (res.signedTransaction == null) {
      throw new UnsupportedProtocolError('signedTransaction is missed in wallet response');
    }
    return res.signedTransaction;
  }
  async signMessage(message) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signMessage, {
      onAccount: this.address,
      message
    });
    return Buffer.from(signature, 'hex');
  }
  async signTypedData(data, aci, {
    name,
    version,
    contractAddress,
    networkId
  } = {}) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signTypedData, {
      onAccount: this.address,
      domain: {
        name,
        version,
        networkId,
        contractAddress
      },
      aci,
      data
    });
    return signature;
  }
  async signDelegationToContract(contractAddress) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signDelegationToContract, {
      onAccount: this.address,
      contractAddress
    });
    return signature;
  }
  async signNameDelegationToContract(contractAddress, name) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signDelegationToContract, {
      onAccount: this.address,
      contractAddress,
      name
    });
    return signature;
  }
  async signOracleQueryDelegationToContract(contractAddress, oracleQueryId) {
    const {
      signature
    } = await this._rpcClient.request(METHODS.signDelegationToContract, {
      onAccount: this.address,
      contractAddress,
      oracleQueryId
    });
    return signature;
  }
}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/rpc/types.ts

const RPC_VERSION = 1;
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/rpc/RpcClient.ts


function RpcClient_classPrivateMethodInitSpec(obj, privateSet) { RpcClient_checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function RpcClient_classPrivateFieldInitSpec(obj, privateMap, value) { RpcClient_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function RpcClient_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function RpcClient_classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }



var _callbacks = /*#__PURE__*/new WeakMap();
var _messageId = /*#__PURE__*/new WeakMap();
var _methods = /*#__PURE__*/new WeakMap();
var _handleMessage = /*#__PURE__*/new WeakSet();
var _sendRequest = /*#__PURE__*/new WeakSet();
var _sendResponse = /*#__PURE__*/new WeakSet();
var _processResponse = /*#__PURE__*/new WeakSet();
/**
 * Contain functionality for using RPC conection
 * @category aepp wallet communication
 * @param connection - Connection object
 * @param onDisconnect - Disconnect callback
 * @param methods - Object containing handlers for each request by name
 */
class RpcClient {
  constructor(connection, onDisconnect, methods) {
    /**
     * Process response message
     * @param msg - Message object
     */
    RpcClient_classPrivateMethodInitSpec(this, _processResponse);
    RpcClient_classPrivateMethodInitSpec(this, _sendResponse);
    RpcClient_classPrivateMethodInitSpec(this, _sendRequest);
    RpcClient_classPrivateMethodInitSpec(this, _handleMessage);
    RpcClient_classPrivateFieldInitSpec(this, _callbacks, {
      writable: true,
      value: new Map()
    });
    RpcClient_classPrivateFieldInitSpec(this, _messageId, {
      writable: true,
      value: 0
    });
    RpcClient_classPrivateFieldInitSpec(this, _methods, {
      writable: true,
      value: void 0
    });
    this.connection = connection;
    classPrivateFieldSet_default()(this, _methods, methods);
    connection.connect(RpcClient_classPrivateMethodGet(this, _handleMessage, _handleMessage2).bind(this), onDisconnect);
  }
  /**
   * Make a request
   * @param name - Method name
   * @param params - Method params
   * @returns Promise which will be resolved after receiving response message
   */
  async request(name, params) {
    RpcClient_classPrivateMethodGet(this, _sendRequest, _sendRequest2).call(this, classPrivateFieldSet_default()(this, _messageId, classPrivateFieldGet_default()(this, _messageId) + 1), name, params);
    return new Promise((resolve, reject) => {
      classPrivateFieldGet_default()(this, _callbacks).set(classPrivateFieldGet_default()(this, _messageId), {
        resolve,
        reject
      });
    });
  }

  /**
   * Make a notification
   * @param name - Method name
   * @param params - Method params
   */
  notify(name, params) {
    RpcClient_classPrivateMethodGet(this, _sendRequest, _sendRequest2).call(this, undefined, name, params);
  }
}
async function _handleMessage2(msg, origin) {
  if ((msg === null || msg === void 0 ? void 0 : msg.jsonrpc) !== '2.0') throw new InvalidRpcMessageError(JSON.stringify(msg));
  if ('result' in msg || 'error' in msg) {
    RpcClient_classPrivateMethodGet(this, _processResponse, _processResponse2).call(this, msg);
    return;
  }
  const request = msg;
  let result;
  let error;
  try {
    if (!(request.method in classPrivateFieldGet_default()(this, _methods))) throw new RpcMethodNotFoundError();
    const methodName = request.method;
    result = await classPrivateFieldGet_default()(this, _methods)[methodName](request.params, origin);
  } catch (e) {
    ensureError(e);
    error = e;
  }
  if (request.id != null) {
    RpcClient_classPrivateMethodGet(this, _sendResponse, _sendResponse2).call(this, request.id, request.method, result, error == null || error instanceof RpcError ? error : new RpcInternalError());
  }
  if (error != null && !(error instanceof RpcError)) throw error;
}
function _sendRequest2(id, method, params) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    ...(id != null ? {
      id
    } : {}),
    method,
    ...(params != null ? {
      params
    } : {})
  });
}
function _sendResponse2(id, method,
// TODO: remove as far it is not required in JSON RPC
result, error) {
  this.connection.sendMessage({
    jsonrpc: '2.0',
    id,
    method,
    ...(error != null ? {
      error: error.toJSON()
    } : {
      result
    })
  });
}
function _processResponse2({
  id,
  error,
  result
}) {
  const callbacks = classPrivateFieldGet_default()(this, _callbacks).get(id);
  if (callbacks == null) throw new MissingCallbackError(id);
  if (error != null) callbacks.reject(RpcError.deserialize(error));else callbacks.resolve(result);
  classPrivateFieldGet_default()(this, _callbacks).delete(id);
}
;// CONCATENATED MODULE: ./src/AeSdkAepp.ts








/**
 * RPC handler for AEPP side
 * Contain functionality for wallet interaction and connect it to sdk
 * @category aepp wallet communication
 */
class AeSdkAepp extends AeSdkBase {
  /**
   * @param options - Options
   * @param options.name - Aepp name
   * @param options.onAddressChange - Call-back function for update address event
   * @param options.onDisconnect - Call-back function for disconnect event
   * @param options.onNetworkChange - Call-back function for update network event
   */
  constructor({
    name,
    onAddressChange = () => {},
    onDisconnect = () => {},
    onNetworkChange = () => {},
    ...other
  }) {
    super(other);
    this.onAddressChange = onAddressChange;
    this.onDisconnect = onDisconnect;
    this.onNetworkChange = onNetworkChange;
    this.name = name;
  }
  _resolveAccount(account = this.addresses()[0]) {
    if (typeof account === 'string') {
      const address = account;
      decode(address);
      if (!this.addresses().includes(address)) throw new UnAuthorizedAccountError(address);
      this._ensureConnected();
      account = new AccountRpc(this.rpcClient, address);
    }
    if (account == null) this._ensureAccountAccess();
    return super._resolveAccount(account);
  }
  addresses() {
    if (this._accounts == null) return [];
    const current = Object.keys(this._accounts.current)[0];
    return [...(current != null ? [current] : []), ...Object.keys(this._accounts.connected)];
  }

  /**
   * Connect to wallet
   * @param connection - Wallet connection object
   * @param options - Options
   * @param options.connectNode - Request wallet to bind node
   * @param options.name - Node name
   * @param options.select - Select this node as current
   */
  async connectToWallet(connection, {
    connectNode = false,
    name = 'wallet-node'
  } = {}) {
    if (this.rpcClient != null) throw new AlreadyConnectedError('You are already connected to wallet');
    let disconnectParams;
    const updateNetwork = params => {
      if (connectNode) {
        var _params$node;
        if (((_params$node = params.node) === null || _params$node === void 0 ? void 0 : _params$node.url) == null) throw new RpcConnectionError('Missing URLs of the Node');
        this.pool.delete(name);
        this.addNode(name, new Node_Node(params.node.url), true);
      }
      this.onNetworkChange(params);
    };
    const client = new RpcClient(connection, () => {
      delete this.rpcClient;
      delete this._accounts;
      this.onDisconnect(disconnectParams);
    }, {
      [METHODS.updateAddress]: params => {
        this._accounts = params;
        this.onAddressChange(params);
      },
      [METHODS.updateNetwork]: updateNetwork,
      [METHODS.closeConnection]: params => {
        disconnectParams = params;
        client.connection.disconnect();
      },
      [METHODS.readyToConnect]: () => {}
    });
    const walletInfo = await client.request(METHODS.connect, {
      name: this.name,
      version: RPC_VERSION,
      connectNode
    });
    updateNetwork(walletInfo);
    this.rpcClient = client;
    return walletInfo;
  }

  /**
   * Disconnect from wallet
   */
  disconnectWallet() {
    this._ensureConnected();
    this.rpcClient.notify(METHODS.closeConnection, {
      reason: 'bye'
    });
    this.rpcClient.connection.disconnect();
  }

  /**
   * Ask addresses from wallet
   * @returns Addresses from wallet
   */
  async askAddresses() {
    this._ensureAccountAccess();
    return this.rpcClient.request(METHODS.address, undefined);
  }

  /**
   * Subscribe for addresses from wallet
   * @param type - Subscription type
   * @param value - Should be one of 'current' (the selected account), 'connected' (all)
   * @returns Accounts from wallet
   */
  async subscribeAddress(type, value) {
    this._ensureConnected();
    const result = await this.rpcClient.request(METHODS.subscribeAddress, {
      type,
      value
    });
    this._accounts = result.address;
    return result;
  }
  _ensureConnected() {
    if (this.rpcClient != null) return;
    throw new NoWalletConnectedError('You are not connected to Wallet');
  }
  _ensureAccountAccess() {
    this._ensureConnected();
    if (this.addresses().length !== 0) return;
    throw new UnsubscribedAccountError();
  }
}
// EXTERNAL MODULE: external "json-bigint"
var external_json_bigint_ = __webpack_require__(2716);
var external_json_bigint_default = /*#__PURE__*/__webpack_require__.n(external_json_bigint_);
;// CONCATENATED MODULE: ./src/utils/json-big.ts



const jsonBig = external_json_bigint_default()({
  storeAsString: true
});
const convertValuesToBigNumbers = value => {
  if (typeof value === 'object' && value !== null && value.constructor === Object) {
    return mapObject(value, ([k, v]) => [k, convertValuesToBigNumbers(v)]);
  }
  if (Array.isArray(value)) {
    return value.map(item => convertValuesToBigNumbers(item));
  }
  if (typeof value === 'string' && new (external_bignumber_js_default())(value).toString(10) === value) {
    const bn = new (external_bignumber_js_default())(value);
    bn.toJSON = () => bn.toString(10);
    return bn;
  }
  return value;
};
/* harmony default export */ const json_big = ({
  stringify: (...args) => jsonBig.stringify(convertValuesToBigNumbers(args[0]), ...args.slice(1)),
  parse: jsonBig.parse
});
;// CONCATENATED MODULE: ./src/AeSdkWallet.ts









/**
 * Contain functionality for aepp interaction and managing multiple aepps
 * @category aepp wallet communication
 */
class AeSdkWallet extends AeSdk {
  /**
   * @param options - Options
   * @param options.name - Wallet name
   * @param options.id - Wallet id
   * @param options.type - Wallet type
   * @param options.onConnection - Call-back function for incoming AEPP connection
   * @param options.onSubscription - Call-back function for incoming AEPP account subscription
   * @param options.onAskAccounts - Call-back function for incoming AEPP get address request
   * @param options.onDisconnect - Call-back function for disconnect event
   */
  constructor({
    name,
    id,
    type,
    onConnection,
    onSubscription,
    onDisconnect,
    onAskAccounts,
    ...options
  }) {
    super(options);
    defineProperty_default()(this, "_clients", new Map());
    this.onConnection = onConnection;
    this.onSubscription = onSubscription;
    this.onDisconnect = onDisconnect;
    this.onAskAccounts = onAskAccounts;
    this.name = name;
    this.id = id;
    this._type = type;
  }
  _getAccountsForClient({
    addressSubscription
  }) {
    const {
      current,
      connected
    } = this.getAccounts();
    return {
      current: addressSubscription.has('current') || addressSubscription.has('connected') ? current : {},
      connected: addressSubscription.has('connected') ? connected : {}
    };
  }
  _pushAccountsToApps() {
    if (this._clients == null) return;
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).filter(client => client.addressSubscription.size !== 0).forEach(client => client.rpc.notify(METHODS.updateAddress, this._getAccountsForClient(client)));
  }
  selectAccount(address) {
    super.selectAccount(address);
    this._pushAccountsToApps();
  }
  addAccount(account, options) {
    super.addAccount(account, options);
    this._pushAccountsToApps();
  }
  _getNode() {
    this.ensureNodeConnected();
    return {
      node: {
        url: this.api.$host,
        name: this.selectedNodeName
      }
    };
  }
  async selectNode(name) {
    super.selectNode(name);
    const networkId = await this.api.getNetworkId();
    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).forEach(client => {
      client.rpc.notify(METHODS.updateNetwork, {
        networkId,
        ...(client.connectNode && this._getNode())
      });
    });
  }
  _getClient(clientId) {
    const client = this._clients.get(clientId);
    if (client == null) throw new UnknownRpcClientError(clientId);
    return client;
  }
  _isRpcClientConnected(clientId) {
    return RPC_STATUS.CONNECTED === this._getClient(clientId).status && this._getClient(clientId).rpc.connection.isConnected();
  }
  _disconnectRpcClient(clientId) {
    const client = this._getClient(clientId);
    client.rpc.connection.disconnect();
    client.status = RPC_STATUS.DISCONNECTED;
    client.addressSubscription = new Set();
  }

  /**
   * Remove specific RpcClient by ID
   * @param id - Client ID
   */
  removeRpcClient(id) {
    this._disconnectRpcClient(id);
    this._clients.delete(id);
  }

  /**
   * Add new client by AEPP connection
   * @param clientConnection - AEPP connection object
   * @returns Client ID
   */
  addRpcClient(clientConnection) {
    // @TODO  detect if aepp has some history based on origin????
    // if yes use this instance for connection
    const id = (0,uuid_.v4)();
    let disconnectParams;
    const client = {
      id,
      status: RPC_STATUS.WAITING_FOR_CONNECTION_REQUEST,
      addressSubscription: new Set(),
      connectNode: false,
      rpc: new RpcClient(clientConnection, () => {
        this._clients.delete(id);
        this.onDisconnect(id, disconnectParams); // also related info
      }, {
        [METHODS.closeConnection]: params => {
          disconnectParams = params;
          this._disconnectRpcClient(id);
        },
        // Store client info and prepare two fn for each client `connect` and `denyConnection`
        // which automatically prepare and send response for that client
        [METHODS.connect]: async ({
          name,
          version,
          icons,
          connectNode
        }, origin) => {
          if (version !== RPC_VERSION) throw new RpcUnsupportedProtocolError();
          await this.onConnection(id, {
            name,
            icons,
            connectNode
          }, origin);
          client.status = RPC_STATUS.CONNECTED;
          client.connectNode = connectNode;
          return {
            ...(await this.getWalletInfo()),
            ...(connectNode && this._getNode())
          };
        },
        [METHODS.subscribeAddress]: async ({
          type,
          value
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          switch (type) {
            case SUBSCRIPTION_TYPES.subscribe:
              // TODO: remove `type` as it always subscribe
              await this.onSubscription(id, {
                type,
                value
              }, origin);
              client.addressSubscription.add(value);
              break;
            case SUBSCRIPTION_TYPES.unsubscribe:
              client.addressSubscription.delete(value);
              break;
            default:
              throw new InternalError(`Unknown subscription type: ${type}`);
          }
          return {
            subscription: Array.from(client.addressSubscription),
            address: this._getAccountsForClient(client)
          };
        },
        [METHODS.address]: async (params, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          await this.onAskAccounts(id, params, origin);
          return this.addresses();
        },
        [METHODS.sign]: async ({
          tx,
          onAccount = this.address,
          returnSigned,
          innerTx
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id,
            innerTx
          };
          if (returnSigned || innerTx === true) {
            return {
              signedTransaction: await this.signTransaction(tx, parameters)
            };
          }
          try {
            return json_big.parse(json_big.stringify({
              transactionHash: await this.sendTransaction(tx, {
                ...parameters,
                verify: false
              })
            }));
          } catch (error) {
            const validation = await verifyTransaction(tx, this.api);
            if (validation.length > 0) throw new RpcInvalidTransactionError(validation);
            throw error;
          }
        },
        [METHODS.signMessage]: async ({
          message,
          onAccount = this.address
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          return {
            signature: Buffer.from(await this.signMessage(message, parameters)).toString('hex')
          };
        },
        [METHODS.signTypedData]: async ({
          domain,
          aci,
          data,
          onAccount = this.address
        }, origin) => {
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            ...domain,
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          return {
            signature: await this.signTypedData(data, aci, parameters)
          };
        },
        [METHODS.signDelegationToContract]: async ({
          contractAddress,
          name,
          oracleQueryId,
          onAccount = this.address
        }, origin) => {
          var _ref, _ref2;
          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();
          if (!this.addresses().includes(onAccount)) {
            throw new RpcPermissionDenyError(onAccount);
          }
          const parameters = {
            onAccount,
            aeppOrigin: origin,
            aeppRpcClientId: id
          };
          const signature = await ((_ref = (_ref2 = name == null ? null : this.signNameDelegationToContract(contractAddress, name, parameters)) !== null && _ref2 !== void 0 ? _ref2 : oracleQueryId == null ? null : this.signOracleQueryDelegationToContract(contractAddress, oracleQueryId, parameters)) !== null && _ref !== void 0 ? _ref : this.signDelegationToContract(contractAddress, parameters));
          return {
            signature
          };
        }
      })
    };
    this._clients.set(id, client);
    return id;
  }

  /**
   * Send shareWalletInfo message to notify AEPP about wallet
   * @param clientId - ID of RPC client send message to
   */
  async shareWalletInfo(clientId) {
    this._getClient(clientId).rpc.notify(METHODS.readyToConnect, await this.getWalletInfo());
  }

  /**
   * Get Wallet info object
   * @returns Object with wallet information
   */
  async getWalletInfo() {
    return {
      id: this.id,
      name: this.name,
      networkId: await this.api.getNetworkId(),
      origin: window.location.origin,
      type: this._type
    };
  }

  /**
   * Get Wallet accounts
   * @returns Object with accounts information (\{ connected: Object, current: Object \})
   */
  getAccounts() {
    return {
      current: this.selectedAddress != null ? {
        [this.selectedAddress]: {}
      } : {},
      connected: this.addresses().filter(a => a !== this.selectedAddress).reduce((acc, a) => ({
        ...acc,
        [a]: {}
      }), {})
    };
  }
}
;// CONCATENATED MODULE: ./src/account/Generalized.ts


function Generalized_classPrivateFieldInitSpec(obj, privateMap, value) { Generalized_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function Generalized_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }








/**
 * Generalized account class
 */
var _authFun = /*#__PURE__*/new WeakMap();
class AccountGeneralized extends AccountBase {
  /**
   * @param address - Address of generalized account
   */
  constructor(address) {
    super();
    Generalized_classPrivateFieldInitSpec(this, _authFun, {
      writable: true,
      value: void 0
    });
    decode(address);
    this.address = address;
  }

  // eslint-disable-next-line class-methods-use-this
  async sign() {
    throw new NotImplementedError('Can\'t sign using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signMessage() {
    throw new NotImplementedError('Can\'t sign using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signTypedData() {
    throw new NotImplementedError('Can\'t sign using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signNameDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using generalized account');
  }

  // eslint-disable-next-line class-methods-use-this
  async signOracleQueryDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using generalized account');
  }
  async signTransaction(tx, {
    authData,
    onCompiler,
    onNode
  }) {
    if (authData == null || onCompiler == null || onNode == null) {
      throw new ArgumentError('authData, onCompiler, onNode', 'provided', null);
    }
    const {
      callData,
      sourceCode,
      args,
      fee,
      gasLimit,
      gasPrice
    } = typeof authData === 'function' ? await authData(tx) : authData;
    const authCallData = callData !== null && callData !== void 0 ? callData : await (async () => {
      if (classPrivateFieldGet_default()(this, _authFun) == null) {
        const account = await getAccount(this.address, {
          onNode
        });
        if (account.kind !== 'generalized') {
          throw new ArgumentError('account kind', 'generalized', account.kind);
        }
        classPrivateFieldSet_default()(this, _authFun, account.authFun);
      }
      if (classPrivateFieldGet_default()(this, _authFun) == null) {
        throw new InternalError('Account in generalised, but authFun not provided');
      }
      if (sourceCode == null || args == null) {
        throw new InvalidAuthDataError('Auth data must contain sourceCode and args or callData.');
      }
      const contract = await contract_Contract.initialize({
        onCompiler,
        onNode,
        sourceCode
      });
      return contract._calldata.encode(contract._name, classPrivateFieldGet_default()(this, _authFun), args);
    })();
    const gaMetaTx = await buildTxAsync({
      tag: Tag.GaMetaTx,
      tx: {
        tag: Tag.SignedTx,
        encodedTx: decode(tx),
        signatures: []
      },
      gaId: this.address,
      authData: authCallData,
      fee,
      gasLimit,
      gasPrice,
      onNode
    });
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: decode(gaMetaTx),
      signatures: []
    });
  }
}
;// CONCATENATED MODULE: ./src/account/Ledger.ts





const CLA = 0xe0;
const GET_ADDRESS = 0x02;
const SIGN_TRANSACTION = 0x04;
const GET_APP_CONFIGURATION = 0x06;
const SIGN_PERSONAL_MESSAGE = 0x08;

/**
 * Ledger wallet account class
 */
class AccountLedger extends AccountBase {
  /**
   * @param transport - Connection to Ledger to use
   * @param index - Index of account
   * @param address - Address of account
   */
  constructor(transport, index, address) {
    super();
    this.transport = transport;
    this.index = index;
    this.address = address;
    const scrambleKey = 'w0w';
    transport.decorateAppAPIMethods(this, ['signTransaction', 'signMessage'], scrambleKey);
  }

  // eslint-disable-next-line class-methods-use-this
  async sign() {
    throw new NotImplementedError('RAW signing using Ledger HW');
  }

  // eslint-disable-next-line class-methods-use-this
  async signTypedData() {
    throw new NotImplementedError('Typed data signing using Ledger HW');
  }

  // eslint-disable-next-line class-methods-use-this
  async signDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using Ledger HW');
  }

  // eslint-disable-next-line class-methods-use-this
  async signNameDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using Ledger HW');
  }

  // eslint-disable-next-line class-methods-use-this
  async signOracleQueryDelegationToContract() {
    throw new NotImplementedError('signing delegation to contract using Ledger HW');
  }
  async signTransaction(tx, {
    innerTx,
    networkId
  } = {}) {
    if (innerTx != null) throw new NotImplementedError('innerTx option in AccountLedger');
    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);
    const rawTx = decode(tx);
    let offset = 0;
    const headerLength = 4 + 1 + 4;
    const networkIdBuffer = Buffer.from(networkId);
    const toSend = [];
    while (offset !== rawTx.length) {
      const maxChunkSize = offset === 0 ? 150 - headerLength - networkIdBuffer.length : 150;
      const chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;
      const buffer = Buffer.alloc(offset === 0 ? headerLength + networkIdBuffer.length + chunkSize : chunkSize);
      if (offset === 0) {
        let bufferOffset = buffer.writeUInt32BE(this.index, 0);
        bufferOffset = buffer.writeUInt32BE(rawTx.length, bufferOffset);
        bufferOffset = buffer.writeUInt8(networkIdBuffer.length, bufferOffset);
        bufferOffset += networkIdBuffer.copy(buffer, bufferOffset, 0, networkIdBuffer.length);
        rawTx.copy(buffer, bufferOffset, 0, 150 - bufferOffset);
      } else {
        rawTx.copy(buffer, 0, offset, offset + chunkSize);
      }
      toSend.push(buffer);
      offset += chunkSize;
    }
    const response = await toSend.reduce(async (previous, data, i) => {
      await previous;
      return this.transport.send(CLA, SIGN_TRANSACTION, i === 0 ? 0x00 : 0x80, 0x00, data);
    }, Promise.resolve(Buffer.alloc(0)));
    const signatures = [response.subarray(0, 64)];
    return buildTx({
      tag: Tag.SignedTx,
      encodedTx: rawTx,
      signatures
    });
  }
  async signMessage(messageStr) {
    let offset = 0;
    const message = Buffer.from(messageStr);
    const toSend = [];
    while (offset !== message.length) {
      const maxChunkSize = offset === 0 ? 150 - 4 - 4 : 150;
      const chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;
      const buffer = Buffer.alloc(offset === 0 ? 4 + 4 + chunkSize : chunkSize);
      if (offset === 0) {
        buffer.writeUInt32BE(this.index, 0);
        buffer.writeUInt32BE(message.length, 4);
        message.copy(buffer, 4 + 4, offset, offset + chunkSize);
      } else {
        message.copy(buffer, 0, offset, offset + chunkSize);
      }
      toSend.push(buffer);
      offset += chunkSize;
    }
    const response = await toSend.reduce(async (previous, data, i) => {
      await previous;
      return this.transport.send(CLA, SIGN_PERSONAL_MESSAGE, i === 0 ? 0x00 : 0x80, 0x00, data);
    }, Promise.resolve(Buffer.alloc(0)));
    return response.subarray(0, 64);
  }
}
;// CONCATENATED MODULE: ./src/account/LedgerFactory.ts



/**
 * A factory class that generates instances of AccountLedger based on provided transport.
 */
class AccountLedgerFactory {
  /**
   * @param transport - Connection to Ledger to use
   */
  constructor(transport) {
    this.transport = transport;
    this.versionCheckPromise = this.getAppConfiguration().then(({
      version
    }) => {
      const args = [version, '0.4.4', '0.5.0'];
      if (!semverSatisfies(...args)) throw new UnsupportedVersionError('app on ledger', ...args);
    });
    const scrambleKey = 'w0w';
    transport.decorateAppAPIMethods(this, ['getAddress', 'getAppConfiguration'], scrambleKey);
  }

  /**
   * @returns the version of app installed on Ledger wallet
   */
  async getAppConfiguration() {
    await this.versionCheckPromise;
    const response = await this.transport.send(CLA, GET_APP_CONFIGURATION, 0x00, 0x00);
    return {
      version: [response[1], response[2], response[3]].join('.')
    };
  }

  /**
   * Get `ak_`-prefixed address for a given account index.
   * @param accountIndex - Index of account
   * @param verify - Ask user to confirm address by showing it on the device screen
   */
  async getAddress(accountIndex, verify = false) {
    await this.versionCheckPromise;
    const buffer = Buffer.alloc(4);
    buffer.writeUInt32BE(accountIndex, 0);
    const response = await this.transport.send(CLA, GET_ADDRESS, verify ? 0x01 : 0x00, 0x00, buffer);
    const addressLength = response[0];
    return response.subarray(1, 1 + addressLength).toString('ascii');
  }

  /**
   * Get an instance of AccountLedger for a given account index.
   * @param accountIndex - Index of account
   */
  async initialize(accountIndex) {
    await this.versionCheckPromise;
    return new AccountLedger(this.transport, accountIndex, await this.getAddress(accountIndex));
  }

  /**
   * Discovers accounts on Ledger that already have been used (has any on-chain transactions).
   * It returns an empty array if none of accounts been used.
   * If a used account is preceded by an unused account then it would be ignored.
   * @param node - Instance of Node to get account information from
   */
  async discover(node) {
    let index = 0;
    const result = [];
    let account;
    do {
      if (account != null) result.push(account);
      account = await this.initialize(index);
      index += 1;
    } while (await node.getAccountByPubkey(account.address).then(() => true, () => false));
    return result;
  }
}
;// CONCATENATED MODULE: ./src/contract/compiler/Base.ts
/**
 * A base class for all compiler implementations
 */
class CompilerBase {}
;// CONCATENATED MODULE: ./src/apis/compiler/models/mappers.ts
const mappers_Contract = {
  type: {
    name: "Composite",
    className: "Contract",
    modelProperties: {
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      }
    }
  }
};
const CompileOpts = {
  type: {
    name: "Composite",
    className: "CompileOpts",
    modelProperties: {
      fileSystem: {
        serializedName: "file_system",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      srcFile: {
        serializedName: "src_file",
        type: {
          name: "String"
        }
      }
    }
  }
};
const mappers_CompilerError = {
  type: {
    name: "Composite",
    className: "CompilerError",
    modelProperties: {
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      },
      pos: {
        serializedName: "pos",
        type: {
          name: "Composite",
          className: "ErrorPos"
        }
      },
      message: {
        serializedName: "message",
        required: true,
        type: {
          name: "String"
        }
      },
      context: {
        serializedName: "context",
        type: {
          name: "String"
        }
      }
    }
  }
};
const ErrorPos = {
  type: {
    name: "Composite",
    className: "ErrorPos",
    modelProperties: {
      file: {
        serializedName: "file",
        type: {
          name: "String"
        }
      },
      line: {
        serializedName: "line",
        required: true,
        type: {
          name: "Number"
        }
      },
      col: {
        serializedName: "col",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const CompileResult = {
  type: {
    name: "Composite",
    className: "CompileResult",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      aci: {
        serializedName: "aci",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      }
    }
  }
};
const SophiaCallResultInput = {
  type: {
    name: "Composite",
    className: "SophiaCallResultInput",
    modelProperties: {
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      callResult: {
        serializedName: "call-result",
        required: true,
        type: {
          name: "String"
        }
      },
      callValue: {
        serializedName: "call-value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const BytecodeCallResultInput = {
  type: {
    name: "Composite",
    className: "BytecodeCallResultInput",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      callResult: {
        serializedName: "call-result",
        required: true,
        type: {
          name: "String"
        }
      },
      callValue: {
        serializedName: "call-value",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodedCallresult = {
  type: {
    name: "Composite",
    className: "DecodedCallresult",
    modelProperties: {
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      result: {
        serializedName: "result",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const FunctionCallInput = {
  type: {
    name: "Composite",
    className: "FunctionCallInput",
    modelProperties: {
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      arguments: {
        serializedName: "arguments",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      }
    }
  }
};
const Calldata = {
  type: {
    name: "Composite",
    className: "Calldata",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodeCalldataBytecode = {
  type: {
    name: "Composite",
    className: "DecodeCalldataBytecode",
    modelProperties: {
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      },
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodedCalldata = {
  type: {
    name: "Composite",
    className: "DecodedCalldata",
    modelProperties: {
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      arguments: {
        serializedName: "arguments",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      }
    }
  }
};
const mappers_ErrorModel = {
  type: {
    name: "Composite",
    className: "ErrorModel",
    modelProperties: {
      reason: {
        serializedName: "reason",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const DecodeCalldataSource = {
  type: {
    name: "Composite",
    className: "DecodeCalldataSource",
    modelProperties: {
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      },
      calldata: {
        serializedName: "calldata",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ByteCodeInput = {
  type: {
    name: "Composite",
    className: "ByteCodeInput",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const FateAssembler = {
  type: {
    name: "Composite",
    className: "FateAssembler",
    modelProperties: {
      fateAssembler: {
        serializedName: "fate-assembler",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ValidateByteCodeInput = {
  type: {
    name: "Composite",
    className: "ValidateByteCodeInput",
    modelProperties: {
      bytecode: {
        serializedName: "bytecode",
        required: true,
        type: {
          name: "String"
        }
      },
      source: {
        serializedName: "source",
        required: true,
        type: {
          name: "String"
        }
      },
      options: {
        serializedName: "options",
        type: {
          name: "Composite",
          className: "CompileOpts"
        }
      }
    }
  }
};
const CompilerVersion = {
  type: {
    name: "Composite",
    className: "CompilerVersion",
    modelProperties: {
      version: {
        serializedName: "version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ApiVersion = {
  type: {
    name: "Composite",
    className: "ApiVersion",
    modelProperties: {
      apiVersion: {
        serializedName: "api-version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SophiaBinaryData = {
  type: {
    name: "Composite",
    className: "SophiaBinaryData",
    modelProperties: {
      sophiaType: {
        serializedName: "sophia-type",
        required: true,
        type: {
          name: "String"
        }
      },
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const SophiaJsonData = {
  type: {
    name: "Composite",
    className: "SophiaJsonData",
    modelProperties: {
      data: {
        serializedName: "data",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
;// CONCATENATED MODULE: ./src/apis/compiler/models/parameters.ts

const parameters_contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
const parameters_body = {
  parameterPath: "body",
  mapper: mappers_Contract
};
const parameters_accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
const parameters_$host = {
  parameterPath: "$host",
  mapper: {
    serializedName: "$host",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
const parameters_body1 = {
  parameterPath: "body",
  mapper: SophiaCallResultInput
};
const body2 = {
  parameterPath: "body",
  mapper: BytecodeCallResultInput
};
const body3 = {
  parameterPath: "body",
  mapper: FunctionCallInput
};
const body4 = {
  parameterPath: "body",
  mapper: DecodeCalldataBytecode
};
const body5 = {
  parameterPath: "body",
  mapper: DecodeCalldataSource
};
const body6 = {
  parameterPath: "body",
  mapper: ByteCodeInput
};
const body7 = {
  parameterPath: "body",
  mapper: ValidateByteCodeInput
};
;// CONCATENATED MODULE: ./src/apis/compiler/compiler.ts



class Compiler extends core_client_.ServiceClient {
  /**
   * Initializes a new instance of the Compiler class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint;
    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-compiler/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      endpoint: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);
    // Parameter assignments
    this.$host = $host;
  }

  /**
   * Generate an Aeternity Contract Interface (ACI) for contract
   * @param body contract code
   * @param options The options parameters.
   */
  generateACI(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, generateACIOperationSpec);
  }

  /**
   * Compile a sophia contract from source and return byte code and ACI
   * @param body contract code
   * @param options The options parameters.
   */
  compileContract(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, compileContractOperationSpec);
  }

  /**
   * Decode the result of contract call
   * @param body Binary data in Sophia ABI format
   * @param options The options parameters.
   */
  decodeCallResult(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCallResultOperationSpec);
  }

  /**
   * Decode the result of contract call from Bytecode
   * @param body Call result + compiled contract
   * @param options The options parameters.
   */
  decodeCallResultBytecode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCallResultBytecodeOperationSpec);
  }

  /**
   * Encode Sophia function call according to sophia ABI.
   * @param body Sophia function call - contract code + function name + arguments
   * @param options The options parameters.
   */
  encodeCalldata(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, encodeCalldataOperationSpec);
  }

  /**
   * Identify function name and arguments in Calldata for a compiled contract
   * @param body Calldata + compiled contract
   * @param options The options parameters.
   */
  decodeCalldataBytecode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCalldataBytecodeOperationSpec);
  }

  /**
   * Identify function name and arguments in Calldata for a (partial) contract
   * @param body Calldata + contract (stub) code
   * @param options The options parameters.
   */
  decodeCalldataSource(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, decodeCalldataSourceOperationSpec);
  }

  /**
   * Get FATE assembler code from bytecode
   * @param body contract byte array
   * @param options The options parameters.
   */
  getFateAssemblerCode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, getFateAssemblerCodeOperationSpec);
  }

  /**
   * Verify that an encoded byte array is the result of compiling a given contract
   * @param body contract byte array and source code
   * @param options The options parameters.
   */
  validateByteCode(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, validateByteCodeOperationSpec);
  }

  /**
   * Extract compiler version from bytecode
   * @param body contract byte array
   * @param options The options parameters.
   */
  getCompilerVersion(body, options) {
    return this.sendOperationRequest({
      body,
      options
    }, getCompilerVersionOperationSpec);
  }

  /**
   * Get the version of the underlying Sophia compiler version
   * @param options The options parameters.
   */
  version(options) {
    return this.sendOperationRequest({
      options
    }, versionOperationSpec);
  }

  /**
   * Get the version of the API
   * @param options The options parameters.
   */
  apiVersion(options) {
    return this.sendOperationRequest({
      options
    }, apiVersionOperationSpec);
  }

  /**
   * Get the Api description
   * @param options The options parameters.
   */
  api(options) {
    return this.sendOperationRequest({
      options
    }, apiOperationSpec);
  }
}
// Operation Specifications
const compiler_serializer = core_client_.createSerializer(models_mappers_namespaceObject, /* isXml */false);
const generateACIOperationSpec = {
  path: "/aci",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Dictionary",
              value: {
                type: {
                  name: "any"
                }
              }
            }
          }
        }
      }
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: parameters_body,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const compileContractOperationSpec = {
  path: "/compile",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: CompileResult
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: parameters_body,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCallResultOperationSpec = {
  path: "/decode-call-result",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "any"
        }
      }
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: parameters_body1,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCallResultBytecodeOperationSpec = {
  path: "/decode-call-result/bytecode",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCallresult
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body2,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const encodeCalldataOperationSpec = {
  path: "/encode-calldata",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: Calldata
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body3,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCalldataBytecodeOperationSpec = {
  path: "/decode-calldata/bytecode",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCalldata
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: body4,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const decodeCalldataSourceOperationSpec = {
  path: "/decode-calldata/source",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: DecodedCalldata
    },
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body5,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const getFateAssemblerCodeOperationSpec = {
  path: "/fate-assembler",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: FateAssembler
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: body6,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const validateByteCodeOperationSpec = {
  path: "/validate-byte-code",
  httpMethod: "POST",
  responses: {
    200: {},
    400: {
      bodyMapper: {
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "CompilerError"
            }
          }
        }
      },
      isError: true
    }
  },
  requestBody: body7,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const getCompilerVersionOperationSpec = {
  path: "/compiler-version",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: CompilerVersion
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  requestBody: body6,
  urlParameters: [parameters_$host],
  headerParameters: [parameters_contentType, parameters_accept],
  mediaType: "json",
  serializer: compiler_serializer
};
const versionOperationSpec = {
  path: "/version",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: CompilerVersion
    },
    500: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
const apiVersionOperationSpec = {
  path: "/api-version",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: ApiVersion
    },
    500: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
const apiOperationSpec = {
  path: "/api",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    },
    400: {
      bodyMapper: mappers_ErrorModel,
      isError: true
    }
  },
  urlParameters: [parameters_$host],
  headerParameters: [parameters_accept],
  serializer: compiler_serializer
};
;// CONCATENATED MODULE: ./src/contract/compiler/Http.ts





/**
 * Contract Compiler over HTTP
 *
 * This class include api call's related to contract compiler functionality.
 * @category contract
 * @example CompilerHttp('COMPILER_URL')
 */
class CompilerHttp extends CompilerBase {
  /**
   * @param compilerUrl - Url for compiler API
   * @param options - Options
   * @param options.ignoreVersion - Don't check compiler version
   */
  constructor(compilerUrl, {
    ignoreVersion
  } = {}) {
    super();
    this.api = new Compiler(compilerUrl, {
      allowInsecureConnection: true,
      additionalPolicies: [genErrorFormatterPolicy(body => {
        let message = '';
        if ('reason' in body) {
          message += ` ${body.reason}${body.parameter != null ? ` in ${body.parameter}` : ''
          // TODO: revising after improving documentation https://github.com/aeternity/aesophia_http/issues/78
          }${body.info != null ? ` (${JSON.stringify(body.info)})` : ''}`;
        }
        if (Array.isArray(body)) {
          message += `\n${body.map(e => `${e.type}:${e.pos.line}:${e.pos.col}: ${e.message}${e.context != null ? ` (${e.context})` : ''}`).join('\n')}`;
        }
        return message;
      })]
    });
    if (ignoreVersion !== true) {
      const versionPromise = this.api.apiVersion().then(({
        apiVersion
      }) => apiVersion, error => error);
      this.api.pipeline.addPolicy(genVersionCheckPolicy('compiler', '/api-version', versionPromise, '7.3.0', '8.0.0'));
    }
  }
  async compileBySourceCode(sourceCode, fileSystem) {
    try {
      const res = await this.api.compileContract({
        code: sourceCode,
        options: {
          fileSystem
        }
      });
      // TODO: should be fixed when the compiledAci interface gets updated
      return res;
    } catch (error) {
      if (error instanceof core_rest_pipeline_.RestError && error.statusCode === 400) {
        throw new CompilerError(error.message);
      }
      throw error;
    }
  }

  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  async compile(path) {
    throw new NotImplementedError('File system access, use CompilerHttpNode instead');
  }
  async generateAciBySourceCode(sourceCode, fileSystem) {
    try {
      return await this.api.generateACI({
        code: sourceCode,
        options: {
          fileSystem
        }
      });
    } catch (error) {
      if (error instanceof core_rest_pipeline_.RestError && error.statusCode === 400) {
        throw new CompilerError(error.message);
      }
      throw error;
    }
  }

  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  async generateAci(path) {
    throw new NotImplementedError('File system access, use CompilerHttpNode instead');
  }
  async validateBySourceCode(bytecode, sourceCode, fileSystem) {
    try {
      await this.api.validateByteCode({
        bytecode,
        source: sourceCode,
        options: {
          fileSystem
        }
      });
      return true;
    } catch {
      return false;
    }
  }

  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  async validate(bytecode, path) {
    throw new NotImplementedError('File system access, use CompilerHttpNode instead');
  }
  async version() {
    return (await this.api.version()).version;
  }
}
;// CONCATENATED MODULE: ./src/utils/string.ts
/**
 * Convert string from snake_case to PascalCase
 * @param s - String to convert
 * @returns Converted string
 */
function snakeToPascal(s) {
  return s.replace(/_./g, match => match[1].toUpperCase());
}

/**
 * Convert string from PascalCase to snake_case
 * @param s - String to convert
 * @returns Converted string
 */
function pascalToSnake(s) {
  return s.replace(/[A-Z]/g, match => `_${match.toLowerCase()}`);
}
// EXTERNAL MODULE: external "websocket"
var external_websocket_ = __webpack_require__(8079);
;// CONCATENATED MODULE: ./src/channel/internal.ts








// TODO: SignTx shouldn't return number or null

// Send ping message every 10 seconds
const PING_TIMEOUT_MS = 10000;
// Close connection if pong message is not received within 15 seconds
const PONG_TIMEOUT_MS = 15000;
function emit(channel, ...args) {
  const [eventName, ...rest] = args;
  channel._eventEmitter.emit(eventName, ...rest);
}
function enterState(channel, nextState) {
  var _nextState$handler;
  if (nextState == null) {
    throw new UnknownChannelStateError();
  }
  channel._fsm = nextState;
  if ((nextState === null || nextState === void 0 || (_nextState$handler = nextState.handler) === null || _nextState$handler === void 0 ? void 0 : _nextState$handler.enter) != null) {
    nextState.handler.enter(channel);
  }
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  void dequeueAction(channel);
}

// TODO: rewrite to enum

function changeStatus(channel, newStatus) {
  if (newStatus === channel._status) return;
  channel._status = newStatus;
  emit(channel, 'statusChanged', newStatus);
}
function changeState(channel, newState) {
  channel._state = newState;
  emit(channel, 'stateChanged', newState);
}
function send(channel, message) {
  if (channel._options.debug) console.log('Send message: ', message);
  channel._websocket.send(json_big.stringify({
    jsonrpc: '2.0',
    ...message
  }));
}
function notify(channel, method, params = {}) {
  send(channel, {
    method,
    params
  });
}
async function dequeueAction(channel) {
  if (channel._isActionQueueLocked) return;
  const queue = channel._actionQueue;
  if (queue.length === 0) return;
  const index = queue.findIndex(action => action.guard(channel, channel._fsm));
  if (index === -1) return;
  channel._actionQueue = queue.filter((_, i) => index !== i);
  channel._isActionQueueLocked = true;
  const nextState = await queue[index].action(channel, channel._fsm);
  channel._isActionQueueLocked = false;
  enterState(channel, nextState);
}
async function enqueueAction(channel, guard, action) {
  const promise = new Promise((resolve, reject) => {
    channel._actionQueue.push({
      guard,
      action() {
        const res = action();
        return {
          ...res,
          state: {
            ...res.state,
            resolve,
            reject
          }
        };
      }
    });
  });
  void dequeueAction(channel);
  return promise;
}
async function handleMessage(channel, message) {
  var _message$params;
  const {
    handler,
    state: st
  } = channel._fsm;
  const nextState = await Promise.resolve(handler(channel, message, st));
  enterState(channel, nextState);
  // TODO: emit message and handler name (?) to move this code to Contract constructor
  if ((message === null || message === void 0 || (_message$params = message.params) === null || _message$params === void 0 || (_message$params = _message$params.data) === null || _message$params === void 0 || (_message$params = _message$params.updates) === null || _message$params === void 0 || (_message$params = _message$params[0]) === null || _message$params === void 0 ? void 0 : _message$params.op) === 'OffChainNewContract'
  // if name is channelOpen, the contract was created by other participant
  && (nextState === null || nextState === void 0 ? void 0 : nextState.handler.name) === 'channelOpen') {
    var _message$params2;
    const round = channel.round();
    if (round == null) throw new UnexpectedTsError('Round is null');
    const owner = message === null || message === void 0 || (_message$params2 = message.params) === null || _message$params2 === void 0 || (_message$params2 = _message$params2.data) === null || _message$params2 === void 0 || (_message$params2 = _message$params2.updates) === null || _message$params2 === void 0 || (_message$params2 = _message$params2[0]) === null || _message$params2 === void 0 ? void 0 : _message$params2.owner;
    emit(channel, 'newContract', encodeContractAddress(owner, round + 1));
  }
}
async function dequeueMessage(channel) {
  if (channel._isMessageQueueLocked) return;
  channel._isMessageQueueLocked = true;
  while (channel._messageQueue.length > 0) {
    const message = channel._messageQueue.shift();
    if (message == null) throw new UnexpectedTsError();
    try {
      await handleMessage(channel, message);
    } catch (error) {
      ensureError(error);
      emit(channel, 'error', new ChannelIncomingMessageError(error, message));
    }
  }
  channel._isMessageQueueLocked = false;
}
function disconnect(channel) {
  channel._websocket.close();
  clearTimeout(channel._pingTimeoutId);
}
function ping(channel) {
  clearTimeout(channel._pingTimeoutId);
  channel._pingTimeoutId = setTimeout(() => {
    notify(channel, 'channels.system', {
      action: 'ping'
    });
    channel._pingTimeoutId = setTimeout(() => {
      disconnect(channel);
      emit(channel, 'error', new ChannelPingTimedOutError());
    }, PONG_TIMEOUT_MS);
  }, PING_TIMEOUT_MS);
}
function onMessage(channel, data) {
  const message = json_big.parse(data);
  if (channel._options.debug) console.log('Receive message: ', message);
  if (message.id != null) {
    const callback = channel._rpcCallbacks.get(message.id);
    if (callback == null) {
      emit(channel, 'error', new ChannelError(`Can't find callback by id: ${message.id}`));
      return;
    }
    try {
      callback(message);
    } finally {
      channel._rpcCallbacks.delete(message.id);
    }
    return;
  }
  if (message.method === 'channels.message') {
    emit(channel, 'message', message.params.data.message);
    return;
  }
  if (message.method === 'channels.system.pong') {
    if (message.params.channel_id === channel._channelId || channel._channelId == null) {
      ping(channel);
    }
    return;
  }
  channel._messageQueue.push(message);
  void dequeueMessage(channel);
}
async function call(channel, method, params) {
  return new Promise((resolve, reject) => {
    const id = channel._nextRpcMessageId;
    channel._nextRpcMessageId += 1;
    channel._rpcCallbacks.set(id, message => {
      if (message.error != null) {
        var _message$error$data$;
        const details = (_message$error$data$ = message.error.data[0].message) !== null && _message$error$data$ !== void 0 ? _message$error$data$ : '';
        reject(new ChannelCallError(message.error.message + details));
      } else resolve(message.result);
    });
    send(channel, {
      method,
      id,
      params
    });
  });
}
async function initialize(channel, connectionHandler, openHandler, {
  url,
  ...channelOptions
}) {
  channel._options = {
    url,
    ...channelOptions
  };
  channel._fsm = {
    handler: connectionHandler
  };
  const wsUrl = new URL(url);
  Object.entries(channelOptions).filter(([key]) => !['sign', 'debug'].includes(key)).forEach(([key, value]) => wsUrl.searchParams.set(pascalToSnake(key), value.toString()));
  wsUrl.searchParams.set('protocol', 'json-rpc');
  changeStatus(channel, 'connecting');
  channel._websocket = new external_websocket_.w3cwebsocket(wsUrl.toString());
  await new Promise((resolve, reject) => {
    Object.assign(channel._websocket, {
      onerror: reject,
      onopen: async () => {
        resolve();
        changeStatus(channel, 'connected');
        if (channelOptions.reconnectTx != null) {
          enterState(channel, {
            handler: openHandler
          });
          const {
            signedTx
          } = await channel.state();
          if (signedTx == null) {
            throw new ChannelError('`signedTx` missed in state while reconnection');
          }
          changeState(channel, buildTx(signedTx));
        }
        ping(channel);
      },
      onclose: () => {
        changeStatus(channel, 'disconnected');
        clearTimeout(channel._pingTimeoutId);
      },
      onmessage: ({
        data
      }) => onMessage(channel, data)
    });
  });
}
;// CONCATENATED MODULE: ./src/channel/handlers.ts
/* eslint-disable consistent-return */
/* eslint-disable default-case */
/* eslint-disable @typescript-eslint/no-use-before-define */






async function appendSignature(tx, signFn) {
  const {
    signatures,
    encodedTx
  } = unpackTx(tx, Tag.SignedTx);
  const payloadTx = buildTx(encodedTx);
  const result = await signFn(payloadTx);
  if (typeof result === 'string') {
    const {
      signatures: signatures2
    } = unpackTx(result, Tag.SignedTx);
    return buildTx({
      tag: Tag.SignedTx,
      signatures: signatures.concat(signatures2),
      encodedTx: decode(payloadTx)
    });
  }
  return result;
}
async function signAndNotify(channel, method, data, signFn) {
  var _signedTx;
  let signedTx;
  if (data.tx != null) signedTx = await signFn(data.tx);else if (data.signed_tx != null) signedTx = await appendSignature(data.signed_tx, signFn);else throw new ChannelError('Can\'t find transaction in message');
  const isError = typeof signedTx !== 'string';
  const key = data.tx != null ? 'tx' : 'signed_tx';
  notify(channel, method, isError ? {
    error: (_signedTx = signedTx) !== null && _signedTx !== void 0 ? _signedTx : 1
  } : {
    [key]: signedTx
  });
  return isError;
}
function handleUnexpectedMessage(_channel, message, state) {
  var _state$reject;
  state === null || state === void 0 || (_state$reject = state.reject) === null || _state$reject === void 0 ? void 0 : _state$reject.call(state, Object.assign(new UnexpectedChannelMessageError(`Unexpected message received:\n\n${JSON.stringify(message)}`), {
    wsMessage: message
  }));
  return {
    handler: channelOpen
  };
}
function awaitingCompletion(channel, message, state, onSuccess) {
  if (onSuccess != null && message.method === 'channels.update') {
    return onSuccess(channel, message, state);
  }
  if (message.method === 'channels.conflict') {
    state.resolve({
      accepted: false,
      errorCode: message.params.data.error_code,
      errorMessage: message.params.data.error_msg
    });
    return {
      handler: channelOpen
    };
  }
  if (message.method === 'channels.info') {
    if (message.params.data.event === 'aborted_update') {
      state.resolve({
        accepted: false
      });
      return {
        handler: channelOpen
      };
    }
  }
  if (message.error != null) {
    const codes = message.error.data.map(d => d.code);
    if (codes.includes(1001)) {
      state.reject(new InsufficientBalanceError('Insufficient balance'));
    } else if (codes.includes(1002)) {
      state.reject(new IllegalArgumentError('Amount cannot be negative'));
    } else {
      state.reject(new ChannelConnectionError(message.error.message));
    }
    return {
      handler: channelOpen
    };
  }
  return handleUnexpectedMessage(channel, message, state);
}
function awaitingConnection(channel, message) {
  if (message.method === 'channels.info') {
    const channelInfoStatus = message.params.data.event;
    let nextStatus = null;
    if (channelInfoStatus === 'channel_accept') nextStatus = 'accepted';
    if (channelInfoStatus === 'funding_created') nextStatus = 'halfSigned';
    if (nextStatus != null) {
      changeStatus(channel, nextStatus);
      return {
        handler: awaitingChannelCreateTx
      };
    }
    if (message.params.data.event === 'channel_reestablished') {
      return {
        handler: awaitingOpenConfirmation
      };
    }
    if (message.params.data.event === 'fsm_up') {
      channel._fsmId = message.params.data.fsm_id;
      return {
        handler: awaitingConnection
      };
    }
    return {
      handler: awaitingConnection
    };
  }
  if (message.method === 'channels.error') {
    var _message$payload;
    emit(channel, 'error', new ChannelConnectionError(message === null || message === void 0 || (_message$payload = message.payload) === null || _message$payload === void 0 ? void 0 : _message$payload.message));
    return {
      handler: channelClosed
    };
  }
}
async function awaitingReconnection(channel, message, state) {
  if (message.method === 'channels.info') {
    if (message.params.data.event === 'fsm_up') {
      channel._fsmId = message.params.data.fsm_id;
      const {
        signedTx
      } = await channel.state();
      changeState(channel, signedTx == null ? '' : buildTx(signedTx));
      return {
        handler: channelOpen
      };
    }
  }
  return handleUnexpectedMessage(channel, message, state);
}
async function awaitingChannelCreateTx(channel, message) {
  const tag = channel._options.role === 'initiator' ? 'initiator_sign' : 'responder_sign';
  if (message.method === `channels.sign.${tag}`) {
    await signAndNotify(channel, `channels.${tag}`, message.params.data, async tx => channel._options.sign(tag, tx));
    return {
      handler: awaitingOnChainTx
    };
  }
}
function awaitingOnChainTx(channel, message) {
  function awaitingBlockInclusion(_, message2) {
    if (message2.method === 'channels.info') {
      switch (message2.params.data.event) {
        case 'funding_created':
        case 'own_funding_locked':
          return {
            handler: awaitingBlockInclusion
          };
        case 'funding_locked':
          return {
            handler: awaitingOpenConfirmation
          };
      }
    }
    if (message2.method === 'channels.on_chain_tx') {
      emit(channel, 'onChainTx', message2.params.data.tx, {
        info: message2.params.data.info,
        type: message2.params.data.type
      });
      return {
        handler: awaitingBlockInclusion
      };
    }
  }
  if (message.method === 'channels.on_chain_tx') {
    const {
      info
    } = message.params.data;
    const {
      role
    } = channel._options;
    if (info === 'funding_signed' && role === 'initiator' || info === 'funding_created' && role === 'responder') {
      return {
        handler: awaitingBlockInclusion
      };
    }
  }
  if (message.method === 'channels.info' && message.params.data.event === 'funding_signed' && channel._options.role === 'initiator') {
    channel._channelId = message.params.channel_id;
    changeStatus(channel, 'signed');
    return {
      handler: awaitingOnChainTx
    };
  }
}
function awaitingOpenConfirmation(channel, message) {
  if (message.method === 'channels.info' && message.params.data.event === 'open') {
    channel._channelId = message.params.channel_id;
    return {
      handler(_, message2) {
        if (message2.method === 'channels.update') {
          changeState(channel, message2.params.data.state);
          return {
            handler: channelOpen
          };
        }
      }
    };
  }
}
async function channelOpen(channel, message, state) {
  switch (message.method) {
    case 'channels.info':
      switch (message.params.data.event) {
        case 'update':
        case 'withdraw_created':
        case 'deposit_created':
          return {
            handler: awaitingTxSignRequest
          };
        case 'own_withdraw_locked':
        case 'withdraw_locked':
        case 'own_deposit_locked':
        case 'deposit_locked':
        case 'peer_disconnected':
        case 'channel_reestablished':
        case 'open':
          // TODO: Better handling of peer_disconnected event.
          //
          //       We should enter intermediate state where offchain transactions
          //       are blocked until channel is reestablished.
          emit(channel, snakeToPascal(message.params.data.event));
          return {
            handler: channelOpen
          };
        case 'fsm_up':
          channel._fsmId = message.params.data.fsm_id;
          return {
            handler: channelOpen
          };
        case 'timeout':
        case 'close_mutual':
          return {
            handler: channelOpen
          };
        case 'closing':
          changeStatus(channel, 'closing');
          return {
            handler: channelOpen
          };
        case 'closed_confirmed':
          changeStatus(channel, 'closed');
          return {
            handler: channelClosed
          };
        case 'died':
          changeStatus(channel, 'died');
          return {
            handler: channelClosed
          };
        case 'shutdown':
          return {
            handler: channelOpen
          };
      }
      break;
    case 'channels.on_chain_tx':
      emit(channel, 'onChainTx', message.params.data.tx, {
        info: message.params.data.info,
        type: message.params.data.type
      });
      return {
        handler: channelOpen
      };
    case 'channels.leave':
      // TODO: emit event
      return {
        handler: channelOpen
      };
    case 'channels.update':
      changeState(channel, message.params.data.state);
      return {
        handler: channelOpen
      };
    case 'channels.sign.shutdown_sign_ack':
      return awaitingTxSignRequest(channel, message, state);
  }
}
channelOpen.enter = channel => {
  changeStatus(channel, 'open');
};
async function awaitingTxSignRequest(channel, message, state) {
  var _message$method$match;
  const [, tag] = (_message$method$match = message.method.match(/^channels\.sign\.([^.]+)$/)) !== null && _message$method$match !== void 0 ? _message$method$match : [];
  if (tag == null) return handleUnexpectedMessage(channel, message, state);
  const isError = await signAndNotify(channel, `channels.${tag}`, message.params.data, async tx => channel._options.sign(tag, tx, {
    updates: message.params.data.updates
  }));
  function awaitingUpdateConflict(_, message2) {
    if (message2.error != null) {
      return {
        handler: awaitingUpdateConflict,
        state
      };
    }
    if (message2.method === 'channels.conflict') {
      return {
        handler: channelOpen
      };
    }
    return handleUnexpectedMessage(channel, message2, state);
  }
  return isError ? {
    handler: awaitingUpdateConflict,
    state
  } : {
    handler: channelOpen
  };
}
async function awaitingShutdownTx(channel, message, state) {
  if (message.method !== 'channels.sign.shutdown_sign') {
    return handleUnexpectedMessage(channel, message, state);
  }
  await signAndNotify(channel, 'channels.shutdown_sign', message.params.data, async tx => state.sign(tx));
  return {
    handler(_, message2) {
      if (message2.method !== 'channels.on_chain_tx') {
        return handleUnexpectedMessage(channel, message2, state);
      }
      // state.resolve(message.params.data.tx)
      return {
        handler: channelClosed,
        state
      };
    },
    state
  };
}
function awaitingLeave(channel, message, state) {
  if (message.method === 'channels.leave') {
    state.resolve({
      channelId: message.params.channel_id,
      signedTx: message.params.data.state
    });
    disconnect(channel);
    return {
      handler: channelClosed
    };
  }
  if (message.method === 'channels.error') {
    state.reject(new ChannelConnectionError(message.data.message));
    return {
      handler: channelOpen
    };
  }
  return handleUnexpectedMessage(channel, message, state);
}
function channelClosed(_channel, message, state) {
  if (state == null) return {
    handler: channelClosed
  };
  if (message.params.data.event === 'closing') return {
    handler: channelClosed,
    state
  };
  if (message.params.data.info === 'channel_closed') {
    state.closeTx = message.params.data.tx;
    return {
      handler: channelClosed,
      state
    };
  }
  if (message.params.data.event === 'closed_confirmed') {
    state.resolve(state.closeTx);
    return {
      handler: channelClosed
    };
  }
  return {
    handler: channelClosed,
    state
  };
}
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(3735);
var external_events_default = /*#__PURE__*/__webpack_require__.n(external_events_);
;// CONCATENATED MODULE: ./src/channel/Base.ts








function snakeToPascalObjKeys(obj) {
  return Object.entries(obj).reduce((result, [key, val]) => ({
    ...result,
    [snakeToPascal(key)]: val
  }), {});
}

/**
 * Channel
 * @example
 * ```js
 * await Channel.initialize({
 *   url: 'ws://localhost:3001',
 *   role: 'initiator'
 *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
 *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',
 *   initiatorAmount: 1e18,
 *   responderAmount: 1e18,
 *   pushAmount: 0,
 *   channelReserve: 0,
 *   ttl: 1000,
 *   host: 'localhost',
 *   port: 3002,
 *   lockPeriod: 10,
 *   async sign (tag, tx) => await account.signTransaction(tx)
 * })
 * ```
 */
class Base_Channel {
  constructor() {
    defineProperty_default()(this, "_eventEmitter", new (external_events_default())());
    defineProperty_default()(this, "_nextRpcMessageId", 0);
    defineProperty_default()(this, "_rpcCallbacks", new Map());
    defineProperty_default()(this, "_messageQueue", []);
    defineProperty_default()(this, "_isMessageQueueLocked", false);
    defineProperty_default()(this, "_actionQueue", []);
    defineProperty_default()(this, "_isActionQueueLocked", false);
    defineProperty_default()(this, "_status", 'disconnected');
    defineProperty_default()(this, "_state", '');
  }
  /**
   * @param options - Channel params
   * @param options.url - Channel url (for example: "ws://localhost:3001")
   * @param options.role - Participant role ("initiator" or "responder")
   * @param options.initiatorId - Initiator's public key
   * @param options.responderId - Responder's public key
   * @param options.pushAmount - Initial deposit in favour of the responder by the initiator
   * @param options.initiatorAmount - Amount of coins the initiator has committed to
   * the channel
   * @param options.responderAmount - Amount of coins the responder has committed to
   * the channel
   * @param options.channelReserve - The minimum amount both peers need to maintain
   * @param options.ttl - Minimum block height to include the channel_create_tx
   * @param options.host - Host of the responder's node
   * @param options.port - The port of the responders node
   * @param options.lockPeriod - Amount of blocks for disputing a solo close
   * @param options.minimumDepthStrategy - How to calculate minimum depth (default: txfee)
   * @param options.minimumDepth - The minimum amount of blocks to be mined
   * @param options.fee - The fee to be used for the channel open transaction
   * @param options.gasPrice - Used for the fee computation of the channel open transaction
   * @param options.existingChannelId - Existing channel id (required if reestablishing a
   * channel)
   * @param options.offchainTx - Offchain transaction (required if reestablishing
   * a channel)
   * @param options.timeoutIdle - The time waiting for a new event to be initiated
   * (default: 600000)
   * @param options.timeoutFundingCreate - The time waiting for the initiator to produce
   * the create channel transaction after the noise session had been established (default: 120000)
   * @param options.timeoutFundingSign - The time frame the other client has to sign an
   * off-chain update after our client had initiated and signed it. This applies only for double
   * signed on-chain intended updates: channel create transaction, deposit, withdrawal and etc.
   * (default: 120000)
   * @param options.timeoutFundingLock - The time frame the other client has to confirm an
   * on-chain transaction reaching maturity (passing minimum depth) after the local node has
   * detected this. This applies only for double signed on-chain intended updates: channel create
   * transaction, deposit, withdrawal and etc. (default: 360000)
   * @param options.timeoutSign - The time frame the client has to return a signed
   * off-chain update or to decline it. This applies for all off-chain updates (default: 500000)
   * @param options.timeoutAccept - The time frame the other client has to react to an
   * event. This applies for all off-chain updates that are not meant to land on-chain, as well as
   * some special cases: opening a noise connection, mutual closing acknowledgement and
   * reestablishing an existing channel (default: 120000)
   * @param options.timeoutInitialized - the time frame the responder has to accept an
   * incoming noise session. Applicable only for initiator (default: timeout_accept's value)
   * @param options.timeoutAwaitingOpen - The time frame the initiator has to start an
   * outgoing noise session to the responder's node. Applicable only for responder (default:
   * timeout_idle's value)
   * @param options.debug=false - Log websocket communication
   * @param options.sign - Function which verifies and signs transactions
   */
  static async initialize(options) {
    return Base_Channel._initialize(new Base_Channel(), options);
  }
  static async _initialize(channel, options) {
    await initialize(channel, options.existingFsmId != null ? awaitingReconnection : awaitingConnection, channelOpen, options);
    return channel;
  }

  /**
   * Register event listener function
   *
   * Possible events:
   *
   *   - "error"
   *   - "stateChanged"
   *   - "statusChanged"
   *   - "message"
   *   - "peerDisconnected"
   *   - "onChainTx"
   *   - "ownWithdrawLocked"
   *   - "withdrawLocked"
   *   - "ownDepositLocked"
   *   - "depositLocked"
   *   - "channelReestablished"
   *   - "newContract"
   *
   *
   * @param eventName - Event name
   * @param callback - Callback function
   */
  on(eventName, callback) {
    this._eventEmitter.on(eventName, callback);
  }

  /**
   * Remove event listener function
   * @param eventName - Event name
   * @param callback - Callback function
   */
  off(eventName, callback) {
    this._eventEmitter.removeListener(eventName, callback);
  }

  /**
   * Close the connection
   */
  disconnect() {
    return disconnect(this);
  }

  /**
   * Get current status
   */
  status() {
    return this._status;
  }

  /**
   * Get current state
   */
  async state() {
    const res = snakeToPascalObjKeys(await call(this, 'channels.get.offchain_state', {}));
    return {
      calls: unpackTx(res.calls, Tag.CallsMtree),
      ...(res.halfSignedTx !== '' && {
        halfSignedTx: unpackTx(res.halfSignedTx, Tag.SignedTx)
      }),
      ...(res.signedTx !== '' && {
        signedTx: unpackTx(res.signedTx, Tag.SignedTx)
      }),
      trees: unpackTx(res.trees, Tag.StateTrees)
    };
  }

  /**
   * Get current round
   *
   * If round cannot be determined (for example when channel has not been opened)
   * it will return `null`.
   */
  round() {
    if (this._state === '') {
      return null;
    }
    const params = unpackTx(this._state, Tag.SignedTx).encodedTx;
    switch (params.tag) {
      case Tag.ChannelCreateTx:
        return 1;
      case Tag.ChannelOffChainTx:
      case Tag.ChannelWithdrawTx:
      case Tag.ChannelDepositTx:
        return params.round;
      default:
        return null;
    }
  }

  /**
   * Get channel id
   *
   */
  id() {
    if (this._channelId == null) throw new ChannelError('Channel is not initialized');
    return this._channelId;
  }

  /**
   * Get channel's fsm id
   *
   */
  fsmId() {
    if (this._fsmId == null) throw new ChannelError('Channel is not initialized');
    return this._fsmId;
  }
  async enqueueAction(action) {
    return enqueueAction(this, (channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === channelOpen, action);
  }

  /**
   * Leave channel
   *
   * It is possible to leave a channel and then later reestablish the channel
   * off-chain state and continue operation. When a leave method is called,
   * the channel fsm passes it on to the peer fsm, reports the current mutually
   * signed state and then terminates.
   *
   * The channel can be reestablished by instantiating another Channel instance
   * with two extra params: existingChannelId and offchainTx (returned from leave
   * method as channelId and signedTx respectively).
   *
   * @example
   * ```js
   * channel.leave().then(({ channelId, signedTx }) => {
   *   console.log(channelId)
   *   console.log(signedTx)
   * })
   * ```
   */
  async leave() {
    return this.enqueueAction(() => {
      notify(this, 'channels.leave');
      return {
        handler: awaitingLeave
      };
    });
  }

  /**
   * Trigger mutual close
   *
   * At any moment after the channel is opened, a closing procedure can be triggered.
   * This can be done by either of the parties. The process is similar to the off-chain updates.
   *
   * @param sign - Function which verifies and signs mutual close transaction
   * @example
   * ```js
   * channel.shutdown(
   *   async (tx) => await account.signTransaction(tx)
   * ).then(tx => console.log('on_chain_tx', tx))
   * ```
   */
  async shutdown(sign) {
    return this.enqueueAction(() => {
      notify(this, 'channels.shutdown');
      return {
        handler: awaitingShutdownTx,
        state: {
          sign
        }
      };
    });
  }
  static async reconnect(options, txParams) {
    const {
      sign
    } = options;
    return Base_Channel.initialize({
      ...options,
      reconnectTx: await sign('reconnect', buildTx({
        ...txParams,
        tag: Tag.ChannelClientReconnectTx
      }))
    });
  }
}
;// CONCATENATED MODULE: ./src/channel/Spend.ts







class ChannelSpend extends Base_Channel {
  /**
   * Trigger a transfer update
   *
   * The transfer update is moving coins from one channel account to another.
   * The update is a change to be applied on top of the latest state.
   *
   * Sender and receiver are the channel parties. Both the initiator and responder
   * can take those roles. Any public key outside the channel is considered invalid.
   *
   * @param from - Sender's public address
   * @param to - Receiver's public address
   * @param amount - Transaction amount
   * @param sign - Function which verifies and signs offchain transaction
   * @param metadata - Metadata
    * @example
   * ```js
   * channel.update(
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',
   *   10,
   *   async (tx) => await account.signTransaction(tx)
   * ).then(({ accepted, signedTx }) =>
   *   if (accepted) {
   *     console.log('Update has been accepted')
   *   }
   * )
   * ```
   */
  async update(from, to, amount, sign, metadata = []) {
    return this.enqueueAction(() => {
      notify(this, 'channels.update.new', {
        from,
        to,
        amount,
        meta: metadata
      });
      const awaitingOffChainTx = async (_, message, state) => {
        if (message.method === 'channels.sign.update') {
          const isError = await signAndNotify(this, 'channels.update', message.params.data, async tx => sign(tx, {
            updates: message.params.data.updates
          }));
          if (isError) return {
            handler: awaitingOffChainTx,
            state
          };
          return {
            handler: (_2, message2) => awaitingCompletion(this, message2, state, () => {
              changeState(this, message2.params.data.state);
              state.resolve({
                accepted: true,
                signedTx: message2.params.data.state
              });
              return {
                handler: channelOpen
              };
            }),
            state
          };
        }
        if (message.method === 'channels.error') {
          state.reject(new ChannelConnectionError(message.data.message));
          return {
            handler: channelOpen
          };
        }
        return awaitingCompletion(this, message, state);
      };
      return {
        handler: awaitingOffChainTx
      };
    });
  }

  /**
   * Get proof of inclusion
   *
   * If a certain address of an account or a contract is not found
   * in the state tree - the response is an error.
   *
   * @param addresses - Addresses
   * @param addresses.accounts - List of account addresses to include in poi
   * @param addresses.contracts - List of contract addresses to include in poi
   * @example
   * ```js
   * channel.poi({
   *   accounts: [
   *     'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *     'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'
   *   ],
   *   contracts: ['ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA']
   * }).then(poi => console.log(poi))
   * ```
   */
  async poi({
    accounts,
    contracts
  }) {
    return unpackTx((await call(this, 'channels.get.poi', {
      accounts,
      contracts
    })).poi, Tag.TreesPoi);
  }

  /**
   * Get balances
   *
   * The accounts param contains a list of addresses to fetch balances of.
   * Those can be either account balances or a contract ones, encoded as an account addresses.
   *
   * If a certain account address had not being found in the state tree - it is simply
   * skipped in the response.
   *
   * @param accounts - List of addresses to fetch balances from
   * @example
   * ```js
   * channel.balances([
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'
   *   'ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA'
   * ]).then(balances =>
   *   console.log(balances['ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'])
   * )
   * ```
   */
  async balances(accounts) {
    return Object.fromEntries((await call(this, 'channels.get.balances', {
      accounts
    })).map(item => [item.account, item.balance]));
  }
  async awaitingActionTx(action, message, state) {
    if (message.method !== `channels.sign.${action}_tx`) {
      return handleUnexpectedMessage(this, message, state);
    }
    const awaitingActionCompletion = (_, message2) => {
      if (message2.method === 'channels.on_chain_tx') {
        var _state$onOnChainTx;
        (_state$onOnChainTx = state.onOnChainTx) === null || _state$onOnChainTx === void 0 ? void 0 : _state$onOnChainTx.call(state, message2.params.data.tx);
        return {
          handler: awaitingActionCompletion,
          state
        };
      }
      if (message2.method === 'channels.info' && [`own_${action}_locked`, `${action}_locked`].includes(message2.params.data.event)) {
        var _state;
        const Action = action === 'deposit' ? 'Deposit' : 'Withdraw';
        const isOwn = message2.params.data.event.startsWith('own_');
        (_state = state[`on${isOwn ? 'Own' : ''}${Action}Locked`]) === null || _state === void 0 ? void 0 : _state.call(state);
        return {
          handler: awaitingActionCompletion,
          state
        };
      }
      return awaitingCompletion(this, message2, state, () => {
        changeState(this, message2.params.data.state);
        state.resolve({
          accepted: true,
          signedTx: message2.params.data.state
        });
        return {
          handler: channelOpen
        };
      });
    };
    const {
      sign
    } = state;
    await signAndNotify(this, `channels.${action}_tx`, message.params.data, async tx => sign(tx, {
      updates: message.params.data.updates
    }));
    return {
      handler: awaitingActionCompletion,
      state
    };
  }

  /**
   * Withdraw coins from the channel
   *
   * After the channel had been opened any of the participants can initiate a withdrawal.
   * The process closely resembles the update. The most notable difference is that the
   * transaction has been co-signed: it is channel_withdraw_tx and after the procedure
   * is finished - it is being posted on-chain.
   *
   * Any of the participants can initiate a withdrawal. The only requirements are:
   *
   *   - Channel is already opened
   *   - No off-chain update/deposit/withdrawal is currently being performed
   *   - Channel is not being closed or in a solo closing state
   *   - The withdrawal amount must be equal to or greater than zero, and cannot exceed
   *     the available balance on the channel (minus the channel_reserve)
   *
   * After the other party had signed the withdraw transaction, the transaction is posted
   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.
   * After computing transaction hash it can be tracked on the chain: entering the mempool,
   * block inclusion and a number of confirmations.
   *
   * After the minimum_depth block confirmations onOwnWithdrawLocked callback is called
   * (without any arguments).
   *
   * When the other party had confirmed that the block height needed is reached
   * onWithdrawLocked callback is called (without any arguments).
   *
   * @param amount - Amount of coins to withdraw
   * @param sign - Function which verifies and signs withdraw transaction
   * @param callbacks - Callbacks
   * @param callbacks.onOnChainTx - Called when withdraw transaction has been posted
   * on chain
   * @param callbacks.onOwnWithdrawLocked
   * @param callbacks.onWithdrawLocked
   * @example
   * ```js
   * channel.withdraw(
   *   100,
   *   async (tx) => await account.signTransaction(tx),
   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }
   * ).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Withdrawal has been accepted')
   *   } else {
   *     console.log('Withdrawal has been rejected')
   *   }
   * })
   * ```
   */
  async withdraw(amount, sign, {
    onOnChainTx,
    onOwnWithdrawLocked,
    onWithdrawLocked
  } = {}) {
    return this.enqueueAction(() => {
      notify(this, 'channels.withdraw', {
        amount
      });
      return {
        handler: async (_, message, state) => this.awaitingActionTx('withdraw', message, state),
        state: {
          sign,
          onOnChainTx,
          onOwnWithdrawLocked,
          onWithdrawLocked
        }
      };
    });
  }

  /**
   * Deposit coins into the channel
   *
   * After the channel had been opened any of the participants can initiate a deposit.
   * The process closely resembles the update. The most notable difference is that the
   * transaction has been co-signed: it is channel_deposit_tx and after the procedure
   * is finished - it is being posted on-chain.
   *
   * Any of the participants can initiate a deposit. The only requirements are:
   *
   *   - Channel is already opened
   *   - No off-chain update/deposit/withdrawal is currently being performed
   *   - Channel is not being closed or in a solo closing state
   *   - The deposit amount must be equal to or greater than zero, and cannot exceed
   *     the available balance on the channel (minus the channel_reserve)
   *
   * After the other party had signed the deposit transaction, the transaction is posted
   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.
   * After computing transaction hash it can be tracked on the chain: entering the mempool,
   * block inclusion and a number of confirmations.
   *
   * After the minimum_depth block confirmations onOwnDepositLocked callback is called
   * (without any arguments).
   *
   * When the other party had confirmed that the block height needed is reached
   * onDepositLocked callback is called (without any arguments).
   *
   * @param amount - Amount of coins to deposit
   * @param sign - Function which verifies and signs deposit transaction
   * @param callbacks - Callbacks
   * @param callbacks.onOnChainTx - Called when deposit transaction has been posted
   * on chain
   * @param callbacks.onOwnDepositLocked
   * @param callbacks.onDepositLocked
   * @example
   * ```js
   * channel.deposit(
   *   100,
   *   async (tx) => await account.signTransaction(tx),
   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }
   * ).then(({ accepted, state }) => {
   *   if (accepted) {
   *     console.log('Deposit has been accepted')
   *     console.log('The new state is:', state)
   *   } else {
   *     console.log('Deposit has been rejected')
   *   }
   * })
   * ```
   */
  async deposit(amount, sign, {
    onOnChainTx,
    onOwnDepositLocked,
    onDepositLocked
  } = {}) {
    return this.enqueueAction(() => {
      notify(this, 'channels.deposit', {
        amount
      });
      return {
        handler: async (_, message, state) => this.awaitingActionTx('deposit', message, state),
        state: {
          sign,
          onOnChainTx,
          onOwnDepositLocked,
          onDepositLocked
        }
      };
    });
  }

  /**
   * Send generic message
   *
   * If message is an object it will be serialized into JSON string
   * before sending.
   *
   * If there is ongoing update that has not yet been finished the message
   * will be sent after that update is finalized.
   *
   * @param message - Message
   * @param recipient - Address of the recipient
   * @example
   * ```js
   * channel.sendMessage(
   *   'hello world',
   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'
   * )
   * ```
   */
  async sendMessage(message, recipient) {
    const info = typeof message === 'object' ? JSON.stringify(message) : message;
    if (this.status() === 'connecting') {
      await new Promise(resolve => {
        const onStatusChanged = status => {
          if (status === 'connecting') return;
          resolve();
          this.off('statusChanged', onStatusChanged);
        };
        this.on('statusChanged', onStatusChanged);
      });
      // For some reason we can't immediately send a message when connection is
      // established. Thus we wait 500ms which seems to work.
      await pause(500);
    }
    notify(this, 'channels.message', {
      info,
      to: recipient
    });
  }
}
;// CONCATENATED MODULE: ./src/channel/Contract.ts









function Contract_snakeToPascalObjKeys(obj) {
  return Object.entries(obj).reduce((result, [key, val]) => ({
    ...result,
    [snakeToPascal(key)]: val
  }), {});
}
class ChannelContract extends ChannelSpend {
  static async initialize(options) {
    return Base_Channel._initialize(new ChannelContract(), options);
  }

  /**
   * Trigger create contract update
   *
   * The create contract update is creating a contract inside the channel's internal state tree.
   * The update is a change to be applied on top of the latest state.
   *
   * That would create a contract with the poster being the owner of it. Poster commits initially
   * a deposit amount of coins to the new contract.
   *
   * @param options - Options
   * @param options.code - Api encoded compiled AEVM byte code
   * @param options.callData - Api encoded compiled AEVM call data for the code
   * @param options.deposit - Initial amount the owner of the contract commits to it
   * @param options.vmVersion - Version of the Virtual Machine
   * @param options.abiVersion - Version of the Application Binary Interface
   * @param sign - Function which verifies and signs create contract transaction
   * @example
   * ```js
   * channel.createContract({
   *   code: 'cb_HKtpipK4aCgYb17wZ...',
   *   callData: 'cb_1111111111111111...',
   *   deposit: 10,
   *   vmVersion: 3,
   *   abiVersion: 1
   * }).then(({ accepted, signedTx, address }) => {
   *   if (accepted) {
   *     console.log('New contract has been created')
   *     console.log('Contract address:', address)
   *   } else {
   *     console.log('New contract has been rejected')
   *   }
   * })
   * ```
   */
  async createContract({
    code,
    callData,
    deposit,
    vmVersion,
    abiVersion
  }, sign) {
    return this.enqueueAction(() => {
      notify(this, 'channels.update.new_contract', {
        code,
        call_data: callData,
        deposit,
        vm_version: vmVersion,
        abi_version: abiVersion
      });
      return {
        handler: async (_, message, state) => {
          if (message.method !== 'channels.sign.update') {
            return handleUnexpectedMessage(this, message, state);
          }
          await signAndNotify(this, 'channels.update', message.params.data, async tx => state.sign(tx));
          return {
            handler: (_2, message2, state2) => awaitingCompletion(this, message2, state2, () => {
              const params = unpackTx(message2.params.data.state, Tag.SignedTx).encodedTx;
              if (params.tag !== Tag.ChannelOffChainTx) {
                throw new ChannelError(`Tag should be ${Tag[Tag.ChannelOffChainTx]}, got ${Tag[params.tag]} instead`);
              }
              const addressKey = this._options.role === 'initiator' ? 'initiatorId' : 'responderId';
              const owner = this._options[addressKey];
              changeState(this, message2.params.data.state);
              const address = encodeContractAddress(owner, params.round);
              emit(this, 'newContract', address);
              state2.resolve({
                accepted: true,
                address,
                signedTx: message2.params.data.state
              });
              return {
                handler: channelOpen
              };
            }),
            state
          };
        },
        state: {
          sign
        }
      };
    });
  }

  /**
   * Trigger call a contract update
   *
   * The call contract update is calling a preexisting contract inside the channel's
   * internal state tree. The update is a change to be applied on top of the latest state.
   *
   * That would call a contract with the poster being the caller of it. Poster commits
   * an amount of coins to the contract.
   *
   * The call would also create a call object inside the channel state tree. It contains
   * the result of the contract call.
   *
   * It is worth mentioning that the gas is not consumed, because this is an off-chain
   * contract call. It would be consumed if it were an on-chain one. This could happen
   * if a call with a similar computation amount is to be forced on-chain.
   *
   * @param options - Options
   * @param options.amount - Amount the caller of the contract commits to it
   * @param options.callData - ABI encoded compiled AEVM call data for the code
   * @param options.contract - Address of the contract to call
   * @param options.abiVersion - Version of the ABI
   * @param sign - Function which verifies and signs contract call transaction
   * @example
   * ```js
   * channel.callContract({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1
   * }).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Contract called succesfully')
   *   } else {
   *     console.log('Contract call has been rejected')
   *   }
   * })
   * ```
   */
  async callContract({
    amount,
    callData,
    contract,
    abiVersion
  }, sign) {
    return this.enqueueAction(() => {
      notify(this, 'channels.update.call_contract', {
        amount,
        call_data: callData,
        contract_id: contract,
        abi_version: abiVersion
      });
      return {
        handler: async (_, message, state) => {
          if (message.method !== 'channels.sign.update') {
            return handleUnexpectedMessage(this, message, state);
          }
          await signAndNotify(this, 'channels.update', message.params.data, async tx => state.sign(tx, {
            updates: message.params.data.updates
          }));
          return {
            handler: (_2, message2, state2) => awaitingCompletion(this, message2, state2, () => {
              changeState(this, message2.params.data.state);
              state2.resolve({
                accepted: true,
                signedTx: message2.params.data.state
              });
              return {
                handler: channelOpen
              };
            }),
            state
          };
        },
        state: {
          sign
        }
      };
    });
  }

  /**
   * Trigger a force progress contract call
   * This call is going on-chain
   * @param options - Options
   * @param options.amount - Amount the caller of the contract commits to it
   * @param options.callData - ABI encoded compiled AEVM call data for the code
   * @param options.contract - Address of the contract to call
   * @param options.abiVersion - Version of the ABI
   * @param options.gasPrice=1000000000]
   * @param options.gasLimit=1000000]
   * @param sign - Function which verifies and signs contract force progress transaction
   * @param callbacks - Callbacks
   * @example
   * ```js
   * channel.forceProgress({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1,
   *   gasPrice: 1000005554
   * }).then(({ accepted, signedTx }) => {
   *   if (accepted) {
   *     console.log('Contract force progress call successful')
   *   } else {
   *     console.log('Contract force progress call has been rejected')
   *   }
   * })
   * ```
   */
  async forceProgress({
    amount,
    callData,
    contract,
    abiVersion,
    gasLimit = 1000000,
    gasPrice = MIN_GAS_PRICE
  }, sign, {
    onOnChainTx
  } = {}) {
    return this.enqueueAction(() => {
      notify(this, 'channels.force_progress', {
        amount,
        call_data: callData,
        contract_id: contract,
        abi_version: abiVersion,
        gas_price: gasPrice,
        gas: gasLimit
      });
      return {
        handler: async (_, message, state) => {
          if (message.method !== 'channels.sign.force_progress_tx') {
            return handleUnexpectedMessage(this, message, state);
          }
          await signAndNotify(this, 'channels.force_progress_sign', message.params.data, async tx => state.sign(tx, {
            updates: message.params.data.updates
          }));
          return {
            handler: (_2, message2, state2) => {
              if (message2.method === 'channels.on_chain_tx') {
                var _state2$onOnChainTx;
                (_state2$onOnChainTx = state2.onOnChainTx) === null || _state2$onOnChainTx === void 0 ? void 0 : _state2$onOnChainTx.call(state2, message2.params.data.tx);
                emit(this, 'onChainTx', message2.params.data.tx, {
                  info: message2.params.data.info,
                  type: message2.params.data.type
                });
                state2.resolve({
                  accepted: true,
                  tx: message2.params.data.tx
                });
                // TODO: shouldn't be unexpected message in this case
              }

              return handleUnexpectedMessage(this, message2, state2);
            },
            state
          };
        },
        state: {
          sign,
          onOnChainTx
        }
      };
    });
  }

  /**
   * Call contract using dry-run
   *
   * In order to get the result of a potential contract call, one might need to
   * dry-run a contract call. It takes the exact same arguments as a call would
   * and returns the call object.
   *
   * The call is executed in the channel's state, but it does not impact the state
   * whatsoever. It uses as an environment the latest channel's state and the current
   * top of the blockchain as seen by the node.
   *
   * @param options - Options
   * @param options.amount - Amount the caller of the contract commits to it
   * @param options.callData - ABI encoded compiled AEVM call data for the code
   * @param options.contract - Address of the contract to call
   * @param options.abiVersion - Version of the ABI
   * @example
   * ```js
   * channel.callContractStatic({
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   callData: 'cb_1111111111111111...',
   *   amount: 0,
   *   abiVersion: 1
   * }).then(({ returnValue, gasUsed }) => {
   *   console.log('Returned value:', returnValue)
   *   console.log('Gas used:', gasUsed)
   * })
   * ```
   */
  async callContractStatic({
    amount,
    callData,
    contract,
    abiVersion
  }) {
    return Contract_snakeToPascalObjKeys(await call(this, 'channels.dry_run.call_contract', {
      amount,
      call_data: callData,
      contract_id: contract,
      abi_version: abiVersion
    }));
  }

  /**
   * Get contract call result
   *
   * The combination of a caller, contract and a round of execution determines the
   * contract call. Providing an incorrect set of those results in an error response.
   *
   * @param options - Options
   * @param options.caller - Address of contract caller
   * @param options.contract - Address of the contract
   * @param options.round - Round when contract was called
   * @example
   * ```js
   * channel.getContractCall({
   *   caller: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',
   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',
   *   round: 3
   * }).then(({ returnType, returnValue }) => {
   *   if (returnType === 'ok') console.log(returnValue)
   * })
   * ```
   */
  async getContractCall({
    caller,
    contract,
    round
  }) {
    return Contract_snakeToPascalObjKeys(await call(this, 'channels.get.contract_call', {
      caller_id: caller,
      contract_id: contract,
      round
    }));
  }

  /**
   * Get the latest contract state
   *
   * @param contract - Address of the contract
   * @example
   * ```js
   * channel.getContractState(
   *   'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa'
   * ).then(({ contract }) => {
   *   console.log('deposit:', contract.deposit)
   * })
   * ```
   */
  async getContractState(contract) {
    const result = await call(this, 'channels.get.contract', {
      pubkey: contract
    });
    return Contract_snakeToPascalObjKeys({
      ...result,
      contract: Contract_snakeToPascalObjKeys(result.contract)
    });
  }

  /**
   * Clean up all locally stored contract calls
   *
   * Contract calls are kept locally in order for the participant to be able to look them up.
   * They consume memory and in order for the participant to free it - one can prune all messages.
   * This cleans up all locally stored contract calls and those will no longer be available for
   * fetching and inspection.
   */
  async cleanContractCalls() {
    return this.enqueueAction(() => {
      notify(this, 'channels.clean_contract_calls');
      return {
        handler(_, message, state) {
          if (message.method === 'channels.calls_pruned.reply') {
            state.resolve();
            return {
              handler: channelOpen
            };
          }
          state.reject(new UnexpectedChannelMessageError('Unexpected message received'));
          return {
            handler: channelClosed
          };
        }
      };
    });
  }
}
// EXTERNAL MODULE: external "isomorphic-ws"
var external_isomorphic_ws_ = __webpack_require__(3153);
var external_isomorphic_ws_default = /*#__PURE__*/__webpack_require__.n(external_isomorphic_ws_);
;// CONCATENATED MODULE: ./src/MiddlewareSubscriber.ts


function MiddlewareSubscriber_classPrivateMethodInitSpec(obj, privateSet) { MiddlewareSubscriber_checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function MiddlewareSubscriber_classPrivateFieldInitSpec(obj, privateMap, value) { MiddlewareSubscriber_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function MiddlewareSubscriber_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function MiddlewareSubscriber_classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
/* eslint-disable max-classes-per-file */


var Source = /*#__PURE__*/function (Source) {
  Source["Middleware"] = "mdw";
  Source["Node"] = "node";
  Source["All"] = "all";
  return Source;
}(Source || {});
class MiddlewareSubscriberError extends BaseError {
  constructor(message) {
    super(message);
    this.name = 'MiddlewareSubscriberError';
  }
}
class MiddlewareSubscriberDisconnected extends MiddlewareSubscriberError {
  constructor(closeEvent) {
    super('Connection closed');
    this.closeEvent = closeEvent;
    this.name = 'MiddlewareSubscriberDisconnected';
  }
}
var _subscriptions = /*#__PURE__*/new WeakMap();
var _requestQueue = /*#__PURE__*/new WeakMap();
var _webSocket = /*#__PURE__*/new WeakMap();
var _targets = /*#__PURE__*/new WeakMap();
var _sendMessage = /*#__PURE__*/new WeakSet();
var _sendSubscribe = /*#__PURE__*/new WeakSet();
var _emit = /*#__PURE__*/new WeakSet();
var _disconnect = /*#__PURE__*/new WeakSet();
var _messageHandler = /*#__PURE__*/new WeakSet();
var _subscribe = /*#__PURE__*/new WeakSet();
class MiddlewareSubscriber {
  get webSocket() {
    return classPrivateFieldGet_default()(this, _webSocket);
  }
  constructor(url) {
    MiddlewareSubscriber_classPrivateMethodInitSpec(this, _subscribe);
    MiddlewareSubscriber_classPrivateMethodInitSpec(this, _messageHandler);
    MiddlewareSubscriber_classPrivateMethodInitSpec(this, _disconnect);
    MiddlewareSubscriber_classPrivateMethodInitSpec(this, _emit);
    MiddlewareSubscriber_classPrivateMethodInitSpec(this, _sendSubscribe);
    MiddlewareSubscriber_classPrivateMethodInitSpec(this, _sendMessage);
    MiddlewareSubscriber_classPrivateFieldInitSpec(this, _targets, {
      get: _get_targets,
      set: void 0
    });
    MiddlewareSubscriber_classPrivateFieldInitSpec(this, _subscriptions, {
      writable: true,
      value: []
    });
    MiddlewareSubscriber_classPrivateFieldInitSpec(this, _requestQueue, {
      writable: true,
      value: []
    });
    MiddlewareSubscriber_classPrivateFieldInitSpec(this, _webSocket, {
      writable: true,
      value: void 0
    });
    this.url = url;
  }
  async reconnect() {
    MiddlewareSubscriber_classPrivateMethodGet(this, _disconnect, _disconnect2).call(this);
    classPrivateFieldSet_default()(this, _webSocket, await new Promise(resolve => {
      const webSocket = new (external_isomorphic_ws_default())(this.url);
      Object.assign(webSocket, {
        onopen: () => resolve(webSocket),
        onerror: errorEvent => {
          MiddlewareSubscriber_classPrivateMethodGet(this, _emit, _emit2).call(this, () => true, undefined, errorEvent.error);
        },
        onmessage: event => {
          if (typeof event.data !== 'string') {
            throw new InternalError(`Unknown incoming message type: ${typeof event.data}`);
          }
          MiddlewareSubscriber_classPrivateMethodGet(this, _messageHandler, _messageHandler2).call(this, JSON.parse(event.data));
        },
        onclose: event => {
          MiddlewareSubscriber_classPrivateMethodGet(this, _emit, _emit2).call(this, () => true, undefined, new MiddlewareSubscriberDisconnected(event));
          MiddlewareSubscriber_classPrivateMethodGet(this, _disconnect, _disconnect2).call(this, true);
        }
      });
    }));
    await Promise.all([...classPrivateFieldGet_default()(this, _targets)].map(target => MiddlewareSubscriber_classPrivateMethodGet(this, _sendSubscribe, _sendSubscribe2).call(this, true, target)));
  }
  // TODO: replace p?: any with a proper type definition

  subscribeKeyBlocks(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'KeyBlocks', Source.Middleware, cb);
  }
  subscribeKeyBlocksNode(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'KeyBlocks', Source.Node, cb);
  }
  subscribeKeyBlocksAll(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'KeyBlocks', Source.All, cb);
  }
  subscribeMicroBlocks(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'MicroBlocks', Source.Middleware, cb);
  }
  subscribeMicroBlocksNode(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'MicroBlocks', Source.Node, cb);
  }
  subscribeMicroBlocksAll(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'MicroBlocks', Source.All, cb);
  }
  subscribeTransactions(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'Transactions', Source.Middleware, cb);
  }
  subscribeTransactionsNode(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'Transactions', Source.Node, cb);
  }
  subscribeTransactionsAll(cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, 'Transactions', Source.All, cb);
  }
  subscribeObject(target, cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, target, Source.Middleware, cb);
  }
  subscribeObjectNode(target, cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, target, Source.Node, cb);
  }
  subscribeObjectAll(target, cb) {
    return MiddlewareSubscriber_classPrivateMethodGet(this, _subscribe, _subscribe2).call(this, target, Source.All, cb);
  }
}
function _get_targets() {
  return new Set(classPrivateFieldGet_default()(this, _subscriptions).map(([target]) => target));
}
function _sendMessage2(message) {
  if (classPrivateFieldGet_default()(this, _webSocket) == null) throw new UnexpectedTsError();
  classPrivateFieldGet_default()(this, _webSocket).send(JSON.stringify(message));
}
function _sendSubscribe2(isSubscribe, target) {
  if (classPrivateFieldGet_default()(this, _webSocket) == null) return;
  const payload = ['KeyBlocks', 'MicroBlocks', 'Transactions'].includes(target) ? target : 'Object';
  MiddlewareSubscriber_classPrivateMethodGet(this, _sendMessage, _sendMessage2).call(this, {
    op: isSubscribe ? 'Subscribe' : 'Unsubscribe',
    payload,
    ...(payload === 'Object' && {
      target
    })
  });
  classPrivateFieldGet_default()(this, _requestQueue).push([isSubscribe, target]);
}
function _emit2(condition, p, e) {
  classPrivateFieldGet_default()(this, _subscriptions).filter(([target, source]) => condition(target, source)).forEach(([,, cb]) => cb(p, e));
}
function _disconnect2(onlyReset = false) {
  if (classPrivateFieldGet_default()(this, _webSocket) == null) return;
  if (!onlyReset) classPrivateFieldGet_default()(this, _webSocket).close();
  Object.assign(classPrivateFieldGet_default()(this, _webSocket), {
    onopen: undefined,
    onerror: undefined,
    onmessage: undefined
  });
  classPrivateFieldSet_default()(this, _webSocket, undefined);
}
function _messageHandler2(message) {
  if (typeof message === 'string' || Array.isArray(message)) {
    const request = classPrivateFieldGet_default()(this, _requestQueue).shift();
    if (request == null) throw new InternalError('Request queue is empty');
    const [isSubscribe, target] = request;
    let error;
    if (typeof message === 'string') error = new MiddlewareSubscriberError(message);
    if (message.includes(target) !== isSubscribe) {
      error = new InternalError(`Expected ${target} to be${isSubscribe ? '' : ' not'} included into ${message}`);
    }
    if (error != null) MiddlewareSubscriber_classPrivateMethodGet(this, _emit, _emit2).call(this, t => target === t, undefined, error);
    return;
  }
  MiddlewareSubscriber_classPrivateMethodGet(this, _emit, _emit2).call(this, (target, source) => (target === message.subscription || target === message.target) && (source === message.source || source === Source.All), message.payload);
}
function _subscribe2(target, source, cb) {
  const subscription = [target, source, cb];
  if (classPrivateFieldGet_default()(this, _targets).size === 0) this.reconnect();
  if (!classPrivateFieldGet_default()(this, _targets).has(target)) MiddlewareSubscriber_classPrivateMethodGet(this, _sendSubscribe, _sendSubscribe2).call(this, true, target);
  classPrivateFieldGet_default()(this, _subscriptions).push(subscription);
  return () => {
    classPrivateFieldSet_default()(this, _subscriptions, classPrivateFieldGet_default()(this, _subscriptions).filter(item => item !== subscription));
    if (!classPrivateFieldGet_default()(this, _targets).has(target)) MiddlewareSubscriber_classPrivateMethodGet(this, _sendSubscribe, _sendSubscribe2).call(this, false, target);
    if (classPrivateFieldGet_default()(this, _targets).size === 0) MiddlewareSubscriber_classPrivateMethodGet(this, _disconnect, _disconnect2).call(this);
  };
}
;// CONCATENATED MODULE: ./src/apis/middleware/models/parameters.ts
const models_parameters_accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
const models_parameters_$host = {
  parameterPath: "$host",
  mapper: {
    serializedName: "$host",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
const id = {
  parameterPath: "id",
  mapper: {
    serializedName: "id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const ownedOnly = {
  parameterPath: ["options", "ownedOnly"],
  mapper: {
    serializedName: "owned_only",
    type: {
      name: "Boolean"
    }
  }
};
const parameters_type = {
  parameterPath: ["options", "type"],
  mapper: {
    serializedName: "type",
    type: {
      name: "String"
    }
  }
};
const parameters_limit = {
  parameterPath: "limit",
  mapper: {
    defaultValue: 10,
    constraints: {
      InclusiveMaximum: 100,
      InclusiveMinimum: 1
    },
    serializedName: "limit",
    type: {
      name: "Number"
    }
  }
};
const scope = {
  parameterPath: "scope",
  mapper: {
    constraints: {
      Pattern: new RegExp("(txi|gen):\\d+(-\\d+)?")
    },
    serializedName: "scope",
    type: {
      name: "String"
    }
  }
};
const direction = {
  parameterPath: "direction",
  mapper: {
    serializedName: "direction",
    type: {
      name: "String"
    }
  }
};
const by = {
  parameterPath: ["options", "by"],
  mapper: {
    serializedName: "by",
    type: {
      name: "String"
    }
  }
};
const prefix = {
  parameterPath: ["options", "prefix"],
  mapper: {
    serializedName: "prefix",
    type: {
      name: "String"
    }
  }
};
const accountId = {
  parameterPath: "accountId",
  mapper: {
    serializedName: "accountId",
    required: true,
    type: {
      name: "String"
    }
  }
};
const contractId = {
  parameterPath: "contractId",
  mapper: {
    serializedName: "contractId",
    required: true,
    type: {
      name: "String"
    }
  }
};
const tokenId = {
  parameterPath: "tokenId",
  mapper: {
    serializedName: "tokenId",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const templateId = {
  parameterPath: "templateId",
  mapper: {
    serializedName: "templateId",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const accountId1 = {
  parameterPath: "accountId",
  mapper: {
    serializedName: "account_id",
    required: true,
    type: {
      name: "String"
    }
  }
};
const sender = {
  parameterPath: "sender",
  mapper: {
    serializedName: "sender",
    required: true,
    type: {
      name: "String"
    }
  }
};
const recipient = {
  parameterPath: "recipient",
  mapper: {
    serializedName: "recipient",
    required: true,
    type: {
      name: "String"
    }
  }
};
const models_parameters_hash = {
  parameterPath: "hash",
  mapper: {
    serializedName: "hash",
    required: true,
    type: {
      name: "String"
    }
  }
};
const hashOrKbi = {
  parameterPath: "hashOrKbi",
  mapper: {
    serializedName: "hash_or_kbi",
    required: true,
    type: {
      name: "String"
    }
  }
};
const kbi = {
  parameterPath: "kbi",
  mapper: {
    serializedName: "kbi",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const mbi = {
  parameterPath: "mbi",
  mapper: {
    serializedName: "mbi",
    required: true,
    type: {
      name: "Number"
    }
  }
};
const state = {
  parameterPath: ["options", "state"],
  mapper: {
    serializedName: "state",
    type: {
      name: "String"
    }
  }
};
const contractId1 = {
  parameterPath: ["options", "contractId"],
  mapper: {
    serializedName: "contract_id",
    type: {
      name: "String"
    }
  }
};
const parameters_event = {
  parameterPath: ["options", "event"],
  mapper: {
    serializedName: "event",
    type: {
      name: "String"
    }
  }
};
const functionPrefix = {
  parameterPath: ["options", "functionPrefix"],
  mapper: {
    serializedName: "function_prefix",
    type: {
      name: "String"
    }
  }
};
const data = {
  parameterPath: ["options", "data"],
  mapper: {
    serializedName: "data",
    type: {
      name: "String"
    }
  }
};
const aexnArgs = {
  parameterPath: ["options", "aexnArgs"],
  mapper: {
    serializedName: "aexn-args",
    type: {
      name: "Boolean"
    }
  }
};
const hash1 = {
  parameterPath: "hash",
  mapper: {
    serializedName: "hash",
    required: true,
    type: {
      name: "String"
    }
  }
};
const ownedBy = {
  parameterPath: ["options", "ownedBy"],
  mapper: {
    serializedName: "owned_by",
    type: {
      name: "String"
    }
  }
};
const state1 = {
  parameterPath: ["options", "state"],
  mapper: {
    serializedName: "state",
    type: {
      name: "String"
    }
  }
};
const type1 = {
  parameterPath: ["options", "type"],
  mapper: {
    serializedName: "type",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "String"
        }
      }
    }
  },
  collectionFormat: "Multi"
};
const typeGroup = {
  parameterPath: ["options", "typeGroup"],
  mapper: {
    serializedName: "type_group",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "String"
        }
      }
    }
  },
  collectionFormat: "Multi"
};
const account = {
  parameterPath: ["options", "account"],
  mapper: {
    serializedName: "account",
    type: {
      name: "String"
    }
  }
};
const contract = {
  parameterPath: ["options", "contract"],
  mapper: {
    serializedName: "contract",
    type: {
      name: "String"
    }
  }
};
const channel = {
  parameterPath: ["options", "channel"],
  mapper: {
    serializedName: "channel",
    type: {
      name: "String"
    }
  }
};
const oracle = {
  parameterPath: ["options", "oracle"],
  mapper: {
    serializedName: "oracle",
    type: {
      name: "String"
    }
  }
};
const senderId = {
  parameterPath: ["options", "senderId"],
  mapper: {
    serializedName: "sender_id",
    type: {
      name: "String"
    }
  }
};
const recipientId = {
  parameterPath: ["options", "recipientId"],
  mapper: {
    serializedName: "recipient_id",
    type: {
      name: "String"
    }
  }
};
const entrypoint = {
  parameterPath: ["options", "entrypoint"],
  mapper: {
    serializedName: "entrypoint",
    type: {
      name: "String"
    }
  }
};
const txType = {
  parameterPath: ["options", "txType"],
  mapper: {
    serializedName: "tx_type",
    type: {
      name: "String"
    }
  }
};
const id1 = {
  parameterPath: ["options", "id"],
  mapper: {
    serializedName: "id",
    type: {
      name: "String"
    }
  }
};
const hashOrIndex = {
  parameterPath: "hashOrIndex",
  mapper: {
    serializedName: "hash_or_index",
    required: true,
    type: {
      name: "String"
    }
  }
};
;// CONCATENATED MODULE: ./src/apis/middleware/models/mappers.ts
const Paths1I5J7OcV2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1I5J7OcV2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Activity"
            }
          }
        }
      }
    }
  }
};
const Activity = {
  type: {
    name: "Composite",
    className: "Activity",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      payload: {
        serializedName: "payload",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      type: {
        serializedName: "type",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PaginatedResponse = {
  type: {
    name: "Composite",
    className: "PaginatedResponse",
    modelProperties: {
      next: {
        serializedName: "next",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      },
      prev: {
        serializedName: "prev",
        required: true,
        nullable: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const ErrorResponse = {
  type: {
    name: "Composite",
    className: "ErrorResponse",
    modelProperties: {
      error: {
        serializedName: "error",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths17FlgdkV2Aex141GetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths17FlgdkV2Aex141GetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141Response"
            }
          }
        }
      }
    }
  }
};
const Aex141Response = {
  type: {
    name: "Composite",
    className: "Aex141Response",
    modelProperties: {
      baseUrl: {
        serializedName: "base_url",
        required: true,
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      contractTxi: {
        serializedName: "contract_txi",
        required: true,
        type: {
          name: "String"
        }
      },
      extensions: {
        serializedName: "extensions",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      limits: {
        serializedName: "limits",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const PathsAxw0PwV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsAxw0PwV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141OwnedTokenResponse"
            }
          }
        }
      }
    }
  }
};
const Aex141OwnedTokenResponse = {
  type: {
    name: "Composite",
    className: "Aex141OwnedTokenResponse",
    modelProperties: {
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      tokenId: {
        serializedName: "token_id",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsN3Ru7DV2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsN3Ru7DV2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141OwnedTokenResponse"
            }
          }
        }
      }
    }
  }
};
const PathsRa6Pv6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsRa6Pv6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141TemplatesResponse"
            }
          }
        }
      }
    }
  }
};
const Aex141TemplatesResponse = {
  type: {
    name: "Composite",
    className: "Aex141TemplatesResponse",
    modelProperties: {
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      edition: {
        serializedName: "edition",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      templateId: {
        serializedName: "template_id",
        required: true,
        type: {
          name: "Number"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths19B9O7TV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths19B9O7TV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex141TemplateTokensResponse"
            }
          }
        }
      }
    }
  }
};
const Aex141TemplateTokensResponse = {
  type: {
    name: "Composite",
    className: "Aex141TemplateTokensResponse",
    modelProperties: {
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      ownerId: {
        serializedName: "owner_id",
        required: true,
        type: {
          name: "String"
        }
      },
      tokenId: {
        serializedName: "token_id",
        required: true,
        type: {
          name: "Number"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths1Fe570RV2Aex9GetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Fe570RV2Aex9GetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9Response"
            }
          }
        }
      }
    }
  }
};
const Aex9Response = {
  type: {
    name: "Composite",
    className: "Aex9Response",
    modelProperties: {
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      contractTxi: {
        serializedName: "contract_txi",
        required: true,
        type: {
          name: "Number"
        }
      },
      decimals: {
        serializedName: "decimals",
        required: true,
        type: {
          name: "Number"
        }
      },
      eventSupply: {
        serializedName: "event_supply",
        required: true,
        type: {
          name: "Number"
        }
      },
      extensions: {
        serializedName: "extensions",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      holders: {
        serializedName: "holders",
        required: true,
        type: {
          name: "Number"
        }
      },
      initialSupply: {
        serializedName: "initial_supply",
        required: true,
        type: {
          name: "Number"
        }
      },
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      symbol: {
        serializedName: "symbol",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsO9MbpkV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchemaAllof1 = {
  type: {
    name: "Composite",
    className: "PathsO9MbpkV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchemaAllof1",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9BalanceResponse"
            }
          }
        }
      }
    }
  }
};
const Aex9BalanceResponse = {
  type: {
    name: "Composite",
    className: "Aex9BalanceResponse",
    modelProperties: {
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      decimals: {
        serializedName: "decimals",
        required: true,
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      tokenName: {
        serializedName: "token_name",
        required: true,
        type: {
          name: "String"
        }
      },
      tokenSymbol: {
        serializedName: "token_symbol",
        required: true,
        type: {
          name: "String"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      txIndex: {
        serializedName: "tx_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      txType: {
        serializedName: "tx_type",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsY2JwfkV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsY2JwfkV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9TransferResponse"
            }
          }
        }
      }
    }
  }
};
const Aex9TransferResponse = {
  type: {
    name: "Composite",
    className: "Aex9TransferResponse",
    modelProperties: {
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      callTxi: {
        serializedName: "call_txi",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        required: true,
        type: {
          name: "Number"
        }
      },
      recipient: {
        serializedName: "recipient",
        required: true,
        type: {
          name: "String"
        }
      },
      sender: {
        serializedName: "sender",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths5U7W2V2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths5U7W2V2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9TransferResponse"
            }
          }
        }
      }
    }
  }
};
const Paths12TleqhV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths12TleqhV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9TransferResponse"
            }
          }
        }
      }
    }
  }
};
const Paths1C2B0UpV2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1C2B0UpV2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Aex9ContractBalanceResponse"
            }
          }
        }
      }
    }
  }
};
const Aex9ContractBalanceResponse = {
  type: {
    name: "Composite",
    className: "Aex9ContractBalanceResponse",
    modelProperties: {
      accountId: {
        serializedName: "account_id",
        required: true,
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "Number"
        }
      },
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      lastLogIdx: {
        serializedName: "last_log_idx",
        required: true,
        type: {
          name: "Number"
        }
      },
      lastTxHash: {
        serializedName: "last_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsBelvp6V2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsBelvp6V2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      account: {
        serializedName: "account",
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        type: {
          name: "Number"
        }
      },
      contract: {
        serializedName: "contract",
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths11X7LpcV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths11X7LpcV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      account: {
        serializedName: "account",
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        type: {
          name: "Number"
        }
      },
      contract: {
        serializedName: "contract",
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths5LeqfqV2BlocksGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths5LeqfqV2BlocksGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Block"
            }
          }
        }
      }
    }
  }
};
const Block = {
  type: {
    name: "Composite",
    className: "Block",
    modelProperties: {
      beneficiary: {
        serializedName: "beneficiary",
        type: {
          name: "String"
        }
      },
      hash: {
        serializedName: "hash",
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      info: {
        serializedName: "info",
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      pow: {
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Number"
            }
          }
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        type: {
          name: "Number"
        }
      },
      time: {
        serializedName: "time",
        type: {
          name: "Number"
        }
      },
      version: {
        serializedName: "version",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const NotFoundResponse = {
  type: {
    name: "Composite",
    className: "NotFoundResponse",
    modelProperties: {
      error: {
        serializedName: "error",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsC25EgV2ChannelsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsC25EgV2ChannelsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Channel"
            }
          }
        }
      }
    }
  }
};
const mappers_Channel = {
  type: {
    name: "Composite",
    className: "Channel",
    modelProperties: {
      amount: {
        serializedName: "amount",
        type: {
          name: "Number"
        }
      },
      channel: {
        serializedName: "channel",
        type: {
          name: "String"
        }
      },
      channelReserve: {
        serializedName: "channel_reserve",
        type: {
          name: "Number"
        }
      },
      delegateIds: {
        serializedName: "delegate_ids",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      initiator: {
        serializedName: "initiator",
        type: {
          name: "String"
        }
      },
      initiatorAmount: {
        serializedName: "initiator_amount",
        type: {
          name: "Number"
        }
      },
      lastUpdatedHeight: {
        serializedName: "last_updated_height",
        type: {
          name: "String"
        }
      },
      lastUpdatedTxType: {
        serializedName: "last_updated_tx_type",
        type: {
          name: "String"
        }
      },
      lockPeriod: {
        serializedName: "lock_period",
        type: {
          name: "Number"
        }
      },
      lockedUntil: {
        serializedName: "locked_until",
        type: {
          name: "Number"
        }
      },
      responder: {
        serializedName: "responder",
        type: {
          name: "String"
        }
      },
      responderAmount: {
        serializedName: "responder_amount",
        type: {
          name: "Number"
        }
      },
      round: {
        serializedName: "round",
        type: {
          name: "Number"
        }
      },
      soloRound: {
        serializedName: "solo_round",
        type: {
          name: "Number"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        type: {
          name: "String"
        }
      },
      updatesCount: {
        serializedName: "updates_count",
        type: {
          name: "String"
        }
      }
    }
  }
};
const Paths1Csrt0IV2ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1Csrt0IV2ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ContractCall"
            }
          }
        }
      }
    }
  }
};
const ContractCall = {
  type: {
    name: "Composite",
    className: "ContractCall",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      callTxHash: {
        serializedName: "call_tx_hash",
        type: {
          name: "String"
        }
      },
      callTxi: {
        serializedName: "call_txi",
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      contractTxi: {
        serializedName: "contract_txi",
        type: {
          name: "Number"
        }
      },
      function: {
        serializedName: "function",
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      internalTx: {
        serializedName: "internal_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      localIdx: {
        serializedName: "local_idx",
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths9Ya94MV2ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths9Ya94MV2ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "ContractLog"
            }
          }
        }
      }
    }
  }
};
const ContractLog = {
  type: {
    name: "Composite",
    className: "ContractLog",
    modelProperties: {
      args: {
        serializedName: "args",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Number"
            }
          }
        }
      },
      blockHash: {
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      callTxHash: {
        serializedName: "call_tx_hash",
        type: {
          name: "String"
        }
      },
      callTxi: {
        serializedName: "call_txi",
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      contractTxi: {
        serializedName: "contract_txi",
        type: {
          name: "Number"
        }
      },
      data: {
        serializedName: "data",
        type: {
          name: "String"
        }
      },
      eventHash: {
        serializedName: "event_hash",
        type: {
          name: "String"
        }
      },
      extCallerContractId: {
        serializedName: "ext_caller_contract_id",
        type: {
          name: "String"
        }
      },
      extCallerContractTxi: {
        serializedName: "ext_caller_contract_txi",
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        type: {
          name: "Number"
        }
      },
      parentContractId: {
        serializedName: "parent_contract_id",
        nullable: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsRzn6HzV2DeltastatsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsRzn6HzV2DeltastatsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DeltaStat"
            }
          }
        }
      }
    }
  }
};
const DeltaStat = {
  type: {
    name: "Composite",
    className: "DeltaStat",
    modelProperties: {
      auctionsStarted: {
        serializedName: "auctions_started",
        type: {
          name: "Number"
        }
      },
      blockReward: {
        serializedName: "block_reward",
        type: {
          name: "Number"
        }
      },
      contractsCreated: {
        serializedName: "contracts_created",
        type: {
          name: "Number"
        }
      },
      devReward: {
        serializedName: "dev_reward",
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      namesActivated: {
        serializedName: "names_activated",
        type: {
          name: "Number"
        }
      },
      namesExpired: {
        serializedName: "names_expired",
        type: {
          name: "Number"
        }
      },
      namesRevoked: {
        serializedName: "names_revoked",
        type: {
          name: "Number"
        }
      },
      oraclesExpired: {
        serializedName: "oracles_expired",
        type: {
          name: "Number"
        }
      },
      oraclesRegistered: {
        serializedName: "oracles_registered",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths10TrrshV2KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths10TrrshV2KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "KeyBlock"
            }
          }
        }
      }
    }
  }
};
const mappers_KeyBlock = {
  type: {
    name: "Composite",
    className: "KeyBlock",
    modelProperties: {
      beneficiary: {
        serializedName: "beneficiary",
        type: {
          name: "String"
        }
      },
      hash: {
        serializedName: "hash",
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      info: {
        serializedName: "info",
        type: {
          name: "String"
        }
      },
      miner: {
        serializedName: "miner",
        type: {
          name: "String"
        }
      },
      nonce: {
        serializedName: "nonce",
        type: {
          name: "String"
        }
      },
      pow: {
        serializedName: "pow",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Number"
            }
          }
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        type: {
          name: "Number"
        }
      },
      time: {
        serializedName: "time",
        type: {
          name: "Number"
        }
      },
      version: {
        serializedName: "version",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths7Hfka2V2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths7Hfka2V2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "MicroBlock"
            }
          }
        }
      }
    }
  }
};
const MicroBlock = {
  type: {
    name: "Composite",
    className: "MicroBlock",
    modelProperties: {
      hash: {
        serializedName: "hash",
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      microBlockIndex: {
        serializedName: "micro_block_index",
        type: {
          name: "Number"
        }
      },
      pofHash: {
        serializedName: "pof_hash",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Number"
            }
          }
        }
      },
      prevHash: {
        serializedName: "prev_hash",
        type: {
          name: "String"
        }
      },
      prevKeyHash: {
        serializedName: "prev_key_hash",
        type: {
          name: "String"
        }
      },
      stateHash: {
        serializedName: "state_hash",
        type: {
          name: "String"
        }
      },
      time: {
        serializedName: "time",
        type: {
          name: "Number"
        }
      },
      transactionsCount: {
        serializedName: "transactions_count",
        type: {
          name: "Number"
        }
      },
      version: {
        serializedName: "version",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1RxrrvbV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1RxrrvbV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Tx"
            }
          }
        }
      }
    }
  }
};
const mappers_Tx = {
  type: {
    name: "Composite",
    className: "Tx",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        type: {
          name: "Number"
        }
      },
      hash: {
        serializedName: "hash",
        type: {
          name: "String"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        type: {
          name: "Number"
        }
      },
      signatures: {
        serializedName: "signatures",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      txIndex: {
        serializedName: "tx_index",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths16Srg6EV2NamesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths16Srg6EV2NamesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Name"
            }
          }
        }
      }
    }
  }
};
const Name = {
  type: {
    name: "Composite",
    className: "Name",
    modelProperties: {
      active: {
        serializedName: "active",
        type: {
          name: "Boolean"
        }
      },
      hash: {
        serializedName: "hash",
        type: {
          name: "String"
        }
      },
      info: {
        serializedName: "info",
        type: {
          name: "Composite",
          className: "NameInfo"
        }
      },
      previous: {
        serializedName: "previous",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Name"
            }
          }
        }
      },
      status: {
        serializedName: "status",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameInfo = {
  type: {
    name: "Composite",
    className: "NameInfo",
    modelProperties: {
      activeFrom: {
        serializedName: "active_from",
        type: {
          name: "Number"
        }
      },
      claims: {
        serializedName: "claims",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Number"
            }
          }
        }
      },
      expireHeight: {
        serializedName: "expire_height",
        type: {
          name: "Number"
        }
      },
      ownership: {
        serializedName: "ownership",
        type: {
          name: "Composite",
          className: "NameInfoOwnership"
        }
      },
      pointers: {
        serializedName: "pointers",
        type: {
          name: "Composite",
          className: "NameInfoPointers"
        }
      },
      transfers: {
        serializedName: "transfers",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Number"
            }
          }
        }
      },
      updates: {
        serializedName: "updates",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameInfoOwnership = {
  type: {
    name: "Composite",
    className: "NameInfoOwnership",
    modelProperties: {
      current: {
        serializedName: "current",
        type: {
          name: "String"
        }
      },
      original: {
        serializedName: "original",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameInfoPointers = {
  type: {
    name: "Composite",
    className: "NameInfoPointers",
    modelProperties: {
      accountPubkey: {
        serializedName: "account_pubkey",
        type: {
          name: "String"
        }
      }
    }
  }
};
const Auction = {
  type: {
    name: "Composite",
    className: "Auction",
    modelProperties: {
      active: {
        serializedName: "active",
        type: {
          name: "Boolean"
        }
      },
      info: {
        serializedName: "info",
        type: {
          name: "Composite",
          className: "AuctionInfo"
        }
      }
    }
  }
};
const AuctionInfo = {
  type: {
    name: "Composite",
    className: "AuctionInfo",
    modelProperties: {
      auctionEnd: {
        serializedName: "auction_end",
        type: {
          name: "Number"
        }
      },
      bids: {
        serializedName: "bids",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Number"
            }
          }
        }
      },
      lastBid: {
        serializedName: "last_bid",
        type: {
          name: "Composite",
          className: "AuctionInfoLastBid"
        }
      },
      name: {
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      previous: {
        serializedName: "previous",
        type: {
          name: "Composite",
          className: "Auction"
        }
      },
      status: {
        serializedName: "status",
        type: {
          name: "String"
        }
      },
      txIndex: {
        serializedName: "tx_index",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const AuctionInfoLastBid = {
  type: {
    name: "Composite",
    className: "AuctionInfoLastBid",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        type: {
          name: "Number"
        }
      },
      hash: {
        serializedName: "hash",
        type: {
          name: "String"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        type: {
          name: "Number"
        }
      },
      signatures: {
        serializedName: "signatures",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const Paths1I6PwfdV2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1I6PwfdV2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Get200ApplicationJsonAllOfPropertiesItemsItem"
            }
          }
        }
      }
    }
  }
};
const Paths7P6Qc1V2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0PropertiesDataItemsAllof1 = {
  type: {
    name: "Composite",
    className: "Paths7P6Qc1V2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0PropertiesDataItemsAllof1",
    modelProperties: {
      status: {
        serializedName: "status",
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameClaim = {
  type: {
    name: "Composite",
    className: "NameClaim",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const PathsDjelzuV2NamesIdPointeesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsDjelzuV2NamesIdPointeesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      active: {
        serializedName: "active",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      inactive: {
        serializedName: "inactive",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const NameTransfer = {
  type: {
    name: "Composite",
    className: "NameTransfer",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const NameUpdate = {
  type: {
    name: "Composite",
    className: "NameUpdate",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      tx: {
        serializedName: "tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const Oracle = {
  type: {
    name: "Composite",
    className: "Oracle",
    modelProperties: {
      active: {
        serializedName: "active",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      activeFrom: {
        serializedName: "active_from",
        required: true,
        type: {
          name: "Number"
        }
      },
      expireHeight: {
        serializedName: "expire_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      extends: {
        serializedName: "extends",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "OracleExtendsItem"
            }
          }
        }
      },
      oracle: {
        serializedName: "oracle",
        required: true,
        type: {
          name: "String"
        }
      },
      queryFee: {
        serializedName: "query_fee",
        required: true,
        type: {
          name: "Number"
        }
      },
      register: {
        serializedName: "register",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const OracleExtendsItem = {
  type: {
    name: "Composite",
    className: "OracleExtendsItem",
    modelProperties: {
      query: {
        serializedName: "query",
        required: true,
        type: {
          name: "String"
        }
      },
      response: {
        serializedName: "response",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsMherz6V2OraclesGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsMherz6V2OraclesGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Oracle"
            }
          }
        }
      }
    }
  }
};
const mappers_Status = {
  type: {
    name: "Composite",
    className: "Status",
    modelProperties: {
      mdwAsyncTasks: {
        serializedName: "mdw_async_tasks",
        type: {
          name: "Composite",
          className: "StatusMdwAsyncTasks"
        }
      },
      mdwGensPerMinute: {
        serializedName: "mdw_gens_per_minute",
        required: true,
        type: {
          name: "Number"
        }
      },
      mdwHeight: {
        serializedName: "mdw_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      mdwLastMigration: {
        serializedName: "mdw_last_migration",
        required: true,
        type: {
          name: "Number"
        }
      },
      mdwRevision: {
        serializedName: "mdw_revision",
        required: true,
        type: {
          name: "String"
        }
      },
      mdwSynced: {
        serializedName: "mdw_synced",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      mdwSyncing: {
        serializedName: "mdw_syncing",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      mdwTxIndex: {
        serializedName: "mdw_tx_index",
        required: true,
        type: {
          name: "Number"
        }
      },
      mdwVersion: {
        serializedName: "mdw_version",
        required: true,
        type: {
          name: "String"
        }
      },
      nodeHeight: {
        serializedName: "node_height",
        required: true,
        type: {
          name: "Number"
        }
      },
      nodeProgress: {
        serializedName: "node_progress",
        required: true,
        type: {
          name: "Number"
        }
      },
      nodeRevision: {
        serializedName: "node_revision",
        required: true,
        type: {
          name: "String"
        }
      },
      nodeSyncing: {
        serializedName: "node_syncing",
        required: true,
        type: {
          name: "Boolean"
        }
      },
      nodeVersion: {
        serializedName: "node_version",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const StatusMdwAsyncTasks = {
  type: {
    name: "Composite",
    className: "StatusMdwAsyncTasks",
    modelProperties: {
      longTasks: {
        serializedName: "long_tasks",
        required: true,
        type: {
          name: "Number"
        }
      },
      producerBuffer: {
        serializedName: "producer_buffer",
        required: true,
        type: {
          name: "Number"
        }
      },
      totalPending: {
        serializedName: "total_pending",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const PathsDpxn99V2TotalstatsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "PathsDpxn99V2TotalstatsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TotalStat"
            }
          }
        }
      }
    }
  }
};
const TotalStat = {
  type: {
    name: "Composite",
    className: "TotalStat",
    modelProperties: {
      auctionsStarted: {
        serializedName: "auctions_started",
        type: {
          name: "Number"
        }
      },
      blockReward: {
        serializedName: "block_reward",
        type: {
          name: "Number"
        }
      },
      contractsCreated: {
        serializedName: "contracts_created",
        type: {
          name: "Number"
        }
      },
      devReward: {
        serializedName: "dev_reward",
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      namesActivated: {
        serializedName: "names_activated",
        type: {
          name: "Number"
        }
      },
      namesExpired: {
        serializedName: "names_expired",
        type: {
          name: "Number"
        }
      },
      namesRevoked: {
        serializedName: "names_revoked",
        type: {
          name: "Number"
        }
      },
      oraclesExpired: {
        serializedName: "oracles_expired",
        type: {
          name: "Number"
        }
      },
      oraclesRegistered: {
        serializedName: "oracles_registered",
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths17Cjtx5V2TransfersGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths17Cjtx5V2TransfersGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Transfer"
            }
          }
        }
      }
    }
  }
};
const Transfer = {
  type: {
    name: "Composite",
    className: "Transfer",
    modelProperties: {
      accountId: {
        serializedName: "account_id",
        type: {
          name: "String"
        }
      },
      amount: {
        serializedName: "amount",
        type: {
          name: "Number"
        }
      },
      height: {
        serializedName: "height",
        type: {
          name: "Number"
        }
      },
      kind: {
        serializedName: "kind",
        type: {
          name: "String"
        }
      },
      refTxi: {
        serializedName: "ref_txi",
        nullable: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const Paths1R74KpvV2TxsGetResponses200ContentApplicationJsonSchemaAllof0 = {
  type: {
    name: "Composite",
    className: "Paths1R74KpvV2TxsGetResponses200ContentApplicationJsonSchemaAllof0",
    modelProperties: {
      data: {
        serializedName: "data",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Tx"
            }
          }
        }
      }
    }
  }
};
const Paths16Tt677V2TxsCountIdGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths16Tt677V2TxsCountIdGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      channelCloseMutualTx: {
        serializedName: "channel_close_mutual_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      channelCloseSoloTx: {
        serializedName: "channel_close_solo_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      channelCreateTx: {
        serializedName: "channel_create_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      channelDepositTx: {
        serializedName: "channel_deposit_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      channelForceProgressTx: {
        serializedName: "channel_force_progress_tx",
        type: {
          name: "Number"
        }
      },
      channelOffchainTx: {
        serializedName: "channel_offchain_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      channelSettleTx: {
        serializedName: "channel_settle_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      channelSlashTx: {
        serializedName: "channel_slash_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      channelSnapshotSoloTx: {
        serializedName: "channel_snapshot_solo_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      channelWithdrawTx: {
        serializedName: "channel_withdraw_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      contractCallTx: {
        serializedName: "contract_call_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      contractCreateTx: {
        serializedName: "contract_create_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      gaAttachTx: {
        serializedName: "ga_attach_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      gaMetaTx: {
        serializedName: "ga_meta_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      nameClaimTx: {
        serializedName: "name_claim_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      namePreclaimTx: {
        serializedName: "name_preclaim_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      nameRevokeTx: {
        serializedName: "name_revoke_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      nameTransferTx: {
        serializedName: "name_transfer_tx",
        type: {
          name: "Number"
        }
      },
      nameUpdateTx: {
        serializedName: "name_update_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      oracleExtendTx: {
        serializedName: "oracle_extend_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      oracleQueryTx: {
        serializedName: "oracle_query_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      oracleRegisterTx: {
        serializedName: "oracle_register_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      oracleResponseTx: {
        serializedName: "oracle_response_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      payingForTx: {
        serializedName: "paying_for_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      spendTx: {
        serializedName: "spend_tx",
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    }
  }
};
const Aex141TransferEvent = {
  type: {
    name: "Composite",
    className: "Aex141TransferEvent",
    modelProperties: {
      blockHeight: {
        serializedName: "block_height",
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        type: {
          name: "Number"
        }
      },
      recipientId: {
        serializedName: "recipient_id",
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        type: {
          name: "String"
        }
      },
      tokenId: {
        serializedName: "token_id",
        type: {
          name: "Number"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        type: {
          name: "String"
        }
      }
    }
  }
};
const Aex9TransferEvent = {
  type: {
    name: "Composite",
    className: "Aex9TransferEvent",
    modelProperties: {
      amount: {
        serializedName: "amount",
        type: {
          name: "Number"
        }
      },
      blockHeight: {
        serializedName: "block_height",
        type: {
          name: "Number"
        }
      },
      contractId: {
        serializedName: "contract_id",
        type: {
          name: "String"
        }
      },
      logIdx: {
        serializedName: "log_idx",
        type: {
          name: "Number"
        }
      },
      microIndex: {
        serializedName: "micro_index",
        type: {
          name: "Number"
        }
      },
      microTime: {
        serializedName: "micro_time",
        type: {
          name: "Number"
        }
      },
      recipientId: {
        serializedName: "recipient_id",
        type: {
          name: "String"
        }
      },
      senderId: {
        serializedName: "sender_id",
        type: {
          name: "String"
        }
      },
      txHash: {
        serializedName: "tx_hash",
        type: {
          name: "String"
        }
      }
    }
  }
};
const InternalContractCallEvent = {
  type: {
    name: "Composite",
    className: "InternalContractCallEvent",
    modelProperties: {
      blockHash: {
        serializedName: "block_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      callTxHash: {
        serializedName: "call_tx_hash",
        type: {
          name: "String"
        }
      },
      contractId: {
        serializedName: "contract_id",
        required: true,
        type: {
          name: "String"
        }
      },
      contractTxHash: {
        serializedName: "contract_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      },
      function: {
        serializedName: "function",
        required: true,
        type: {
          name: "String"
        }
      },
      height: {
        serializedName: "height",
        required: true,
        type: {
          name: "Number"
        }
      },
      internalTx: {
        serializedName: "internal_tx",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      microIndex: {
        serializedName: "micro_index",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
const InternalTransferEvent = {
  type: {
    name: "Composite",
    className: "InternalTransferEvent",
    modelProperties: {
      amount: {
        serializedName: "amount",
        required: true,
        type: {
          name: "Number"
        }
      },
      kind: {
        serializedName: "kind",
        required: true,
        type: {
          name: "String"
        }
      },
      refTxHash: {
        serializedName: "ref_tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const NameClaimEvent = {
  type: {
    name: "Composite",
    className: "NameClaimEvent",
    modelProperties: {
      tx: {
        serializedName: "tx",
        required: true,
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      },
      txHash: {
        serializedName: "tx_hash",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
const PathsKlr2M2V2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsKlr2M2V2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1I5J7OcV2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsFlc7UjV2Aex141GetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsFlc7UjV2Aex141GetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths17FlgdkV2Aex141GetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsSs61ZgV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsSs61ZgV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsAxw0PwV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Ilysy5V2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Ilysy5V2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsN3Ru7DV2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths17O9Fn6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths17O9Fn6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsRa6Pv6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsNuoourV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsNuoourV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths19B9O7TV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Wbogg8V2Aex9GetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Wbogg8V2Aex9GetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Fe570RV2Aex9GetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1BsirxgV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1BsirxgV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PaginatedResponse.type.modelProperties,
      ...PathsO9MbpkV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchemaAllof1.type.modelProperties
    }
  }
};
const Paths1V0FiznV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1V0FiznV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsY2JwfkV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1X48QgjV2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1X48QgjV2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths5U7W2V2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1DkkopqV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1DkkopqV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths12TleqhV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsNi359V2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsNi359V2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1C2B0UpV2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths15Ih6XV2BlocksGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths15Ih6XV2BlocksGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths5LeqfqV2BlocksGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Txl2A9V2ChannelsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Txl2A9V2ChannelsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsC25EgV2ChannelsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths187U0XzV2ContractsCallsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths187U0XzV2ContractsCallsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1Csrt0IV2ContractsCallsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsB246H1V2ContractsLogsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsB246H1V2ContractsLogsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths9Ya94MV2ContractsLogsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths7Pbec0V2DeltastatsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths7Pbec0V2DeltastatsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsRzn6HzV2DeltastatsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1Ulxr59V2KeyBlocksGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1Ulxr59V2KeyBlocksGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths10TrrshV2KeyBlocksGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsO99PhzV2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsO99PhzV2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths7Hfka2V2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsGuqvhdV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsGuqvhdV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1RxrrvbV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsK9TkttV2NamesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsK9TkttV2NamesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths16Srg6EV2NamesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths3Msq0DV2NamesSearchGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths3Msq0DV2NamesSearchGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1I6PwfdV2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsB0YvynV2OraclesGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsB0YvynV2OraclesGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsMherz6V2OraclesGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths15PsutbV2TotalstatsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths15PsutbV2TotalstatsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsDpxn99V2TotalstatsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsIgs9Z1V2TransfersGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsIgs9Z1V2TransfersGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths17Cjtx5V2TransfersGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const PathsFclv4TV2TxsGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "PathsFclv4TV2TxsGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths1R74KpvV2TxsGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties,
      ...PaginatedResponse.type.modelProperties
    }
  }
};
const Paths1R02SlwV2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1R02SlwV2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...PathsBelvp6V2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties
    }
  }
};
const Paths1T9RwnyV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema = {
  type: {
    name: "Composite",
    className: "Paths1T9RwnyV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema",
    modelProperties: {
      ...Paths11X7LpcV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchemaAllof0.type.modelProperties
    }
  }
};
const Get200ApplicationJsonAllOfPropertiesItemsItem = {
  type: {
    name: "Composite",
    className: "Get200ApplicationJsonAllOfPropertiesItemsItem",
    modelProperties: {
      ...Name.type.modelProperties,
      ...Paths7P6Qc1V2NamesSearchGetResponses200ContentApplicationJsonSchemaAllof0PropertiesDataItemsAllof1.type.modelProperties
    }
  }
};
;// CONCATENATED MODULE: ./src/apis/middleware/middleware.ts



class Middleware extends core_client_.ServiceClient {
  /**
   * Initializes a new instance of the Middleware class.
   * @param $host server parameter
   * @param options The parameter options
   */
  constructor($host, options) {
    var _ref, _options$endpoint;
    if ($host === undefined) {
      throw new Error("'$host' cannot be null");
    }

    // Initializing default values for options
    if (!options) {
      options = {};
    }
    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-middleware/1.0.0-beta.1`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = {
      ...defaults,
      ...options,
      userAgentOptions: {
        userAgentPrefix
      },
      endpoint: (_ref = (_options$endpoint = options.endpoint) !== null && _options$endpoint !== void 0 ? _options$endpoint : options.baseUri) !== null && _ref !== void 0 ? _ref : "{$host}"
    };
    super(optionsWithDefaults);
    // Parameter assignments
    this.$host = $host;
  }

  /**
   * Get an account activities.
   * @param id The account address
   * @param options The options parameters.
   */
  getAccountActivities(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getAccountActivitiesOperationSpec);
  }

  /**
   * Get AEX141 contracts sorted by name or symbol.
   * @param options The options parameters.
   */
  getSortedAex141Contracts(options) {
    return this.sendOperationRequest({
      options
    }, getSortedAex141ContractsOperationSpec);
  }

  /**
   * Get tokens owned by an account.
   * @param accountId The account id
   * @param options The options parameters.
   */
  getAex141OwnedTokens(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAex141OwnedTokensOperationSpec);
  }

  /**
   * Get owner of a NFT (AEX-141 token).
   * @param contractId The contract id
   * @param tokenId The nft token id
   * @param options The options parameters.
   */
  getAex141TokenOwner(contractId, tokenId, options) {
    return this.sendOperationRequest({
      contractId,
      tokenId,
      options
    }, getAex141TokenOwnerOperationSpec);
  }

  /**
   * Get owners of tokens of a AEX-141 contract.
   * @param contractId The contract id
   * @param options The options parameters.
   */
  getAex141ContractOwners(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getAex141ContractOwnersOperationSpec);
  }

  /**
   * Get templates AEX-141 contract tokens.
   * @param contractId The contract id
   * @param options The options parameters.
   */
  getAex141ContractTemplates(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getAex141ContractTemplatesOperationSpec);
  }

  /**
   * Get AEX-141 template tokens.
   * @param contractId Contract id
   * @param templateId Template id
   * @param options The options parameters.
   */
  getAex141TemplateTokens(contractId, templateId, options) {
    return this.sendOperationRequest({
      contractId,
      templateId,
      options
    }, getAex141TemplateTokensOperationSpec);
  }

  /**
   * Get AEX141 contract meta-info, extensions, limits and stats.
   * @param id The contract id
   * @param options The options parameters.
   */
  getAex141ByContract(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getAex141ByContractOperationSpec);
  }

  /**
   * Get AEX9 tokens sorted by name or symbol.
   * @param options The options parameters.
   */
  getSortedAex9Tokens(options) {
    return this.sendOperationRequest({
      options
    }, getSortedAex9TokensOperationSpec);
  }

  /**
   * Get all AEX9 balances for an account on the last block.
   * @param accountId Account id
   * @param options The options parameters.
   */
  getAex9AccountBalances(accountId, options) {
    return this.sendOperationRequest({
      accountId,
      options
    }, getAex9AccountBalancesOperationSpec);
  }

  /**
   * Get AEX9 tokens count.
   * @param options The options parameters.
   */
  getAex9TokensCount(options) {
    return this.sendOperationRequest({
      options
    }, getAex9TokensCountOperationSpec);
  }

  /**
   * Get AEX9 transfers filtered by sender and recipient.
   * @param sender Sender account id
   * @param recipient Recipient account id
   * @param options The options parameters.
   */
  getAex9PairTransfers(sender, recipient, options) {
    return this.sendOperationRequest({
      sender,
      recipient,
      options
    }, getAex9PairTransfersOperationSpec);
  }

  /**
   * Get AEX9 transfers filtered by sender.
   * @param id Sender account id
   * @param options The options parameters.
   */
  getAex9SenderTransfers(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getAex9SenderTransfersOperationSpec);
  }

  /**
   * Get AEX9 transfers filtered by recipient.
   * @param id Recipient account id
   * @param options The options parameters.
   */
  getAex9RecipientTransfers(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getAex9RecipientTransfersOperationSpec);
  }

  /**
   * Get AEX9 balances on a contract.
   * @param contractId Contract id
   * @param options The options parameters.
   */
  getAex9ContractBalances(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getAex9ContractBalancesOperationSpec);
  }

  /**
   * Get AEX9 balance for an account on a contract.
   * @param contractId Contract id
   * @param accountId Account id
   * @param hash Block hash
   * @param options The options parameters.
   */
  getAex9ContractAccountBalance(contractId, accountId, hash, options) {
    return this.sendOperationRequest({
      contractId,
      accountId,
      hash,
      options
    }, getAex9ContractAccountBalanceOperationSpec);
  }

  /**
   * Get AEX9 account balance on a contract throughout all heights when changed.
   * @param contractId Contract id
   * @param accountId Account id
   * @param options The options parameters.
   */
  getAex9ContractAccountBalanceHistory(contractId, accountId, options) {
    return this.sendOperationRequest({
      contractId,
      accountId,
      options
    }, getAex9ContractAccountBalanceHistoryOperationSpec);
  }

  /**
   * Get AEX9 token events count.
   * @param contractId Contract id
   * @param options The options parameters.
   */
  getAex9LogsCount(contractId, options) {
    return this.sendOperationRequest({
      contractId,
      options
    }, getAex9LogsCountOperationSpec);
  }

  /**
   * Get AEX9 creation and meta_info information by contract id.
   * @param id The contract id
   * @param options The options parameters.
   */
  getAex9ByContract(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getAex9ByContractOperationSpec);
  }

  /**
   * Get multiple blocks.
   * @param options The options parameters.
   */
  getBlocks(options) {
    return this.sendOperationRequest({
      options
    }, getBlocksOperationSpec);
  }

  /**
   * Get a single block.
   * @param hashOrKbi The block encoded hash or key block index
   * @param options The options parameters.
   */
  getBlock(hashOrKbi, options) {
    return this.sendOperationRequest({
      hashOrKbi,
      options
    }, getBlockOperationSpec);
  }

  /**
   * Get a single block.
   * @param kbi The block key block index
   * @param mbi The block micro block index, starting from 0
   * @param options The options parameters.
   */
  getBlockByMbi(kbi, mbi, options) {
    return this.sendOperationRequest({
      kbi,
      mbi,
      options
    }, getBlockByMbiOperationSpec);
  }

  /**
   * Get multiple channels.
   * @param options The options parameters.
   */
  getChannels(options) {
    return this.sendOperationRequest({
      options
    }, getChannelsOperationSpec);
  }

  /**
   * Get a single channel.
   * @param id The channel
   * @param options The options parameters.
   */
  getChannel(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getChannelOperationSpec);
  }

  /**
   * Get contract calls.
   * @param options The options parameters.
   */
  getContractsCalls(options) {
    return this.sendOperationRequest({
      options
    }, getContractsCallsOperationSpec);
  }

  /**
   * Get contract logs.
   * @param options The options parameters.
   */
  getContractsLogs(options) {
    return this.sendOperationRequest({
      options
    }, getContractsLogsOperationSpec);
  }

  /**
   * Get delta stats.
   * @param options The options parameters.
   */
  getDeltastats(options) {
    return this.sendOperationRequest({
      options
    }, getDeltastatsOperationSpec);
  }

  /**
   * Get multiple key blocks.
   * @param options The options parameters.
   */
  getKeyBlocks(options) {
    return this.sendOperationRequest({
      options
    }, getKeyBlocksOperationSpec);
  }

  /**
   * Get a single key block.
   * @param hashOrKbi The key block encoded hash or key block index
   * @param options The options parameters.
   */
  getKeyBlock(hashOrKbi, options) {
    return this.sendOperationRequest({
      hashOrKbi,
      options
    }, getKeyBlockOperationSpec);
  }

  /**
   * Get the key block micro blocks.
   * @param hashOrKbi The key block encoded hash or key block index
   * @param options The options parameters.
   */
  getKeyBlockMicroBlocks(hashOrKbi, options) {
    return this.sendOperationRequest({
      hashOrKbi,
      options
    }, getKeyBlockMicroBlocksOperationSpec);
  }

  /**
   * Get a micro block
   * @param hash The micro block encoded hash
   * @param options The options parameters.
   */
  getMicroBlock(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockOperationSpec);
  }

  /**
   * Get a micro block transactions
   * @param hash The micro block encoded hash
   * @param options The options parameters.
   */
  getMicroBlockTransactions(hash, options) {
    return this.sendOperationRequest({
      hash,
      options
    }, getMicroBlockTransactionsOperationSpec);
  }

  /**
   * Get multiple names.
   * @param options The options parameters.
   */
  getNames(options) {
    return this.sendOperationRequest({
      options
    }, getNamesOperationSpec);
  }

  /**
   * Get multiple names.
   * @param options The options parameters.
   */
  getNamesAuctions(options) {
    return this.sendOperationRequest({
      options
    }, getNamesAuctionsOperationSpec);
  }

  /**
   * Get multiple names.
   * @param options The options parameters.
   */
  searchNames(options) {
    return this.sendOperationRequest({
      options
    }, searchNamesOperationSpec);
  }

  /**
   * Get a single name.
   * @param id The name
   * @param options The options parameters.
   */
  getName(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameOperationSpec);
  }

  /**
   * Get name auction
   * @param id The name
   * @param options The options parameters.
   */
  getNameAuction(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameAuctionOperationSpec);
  }

  /**
   * Get name claims
   * @param id The name or name hash
   * @param options The options parameters.
   */
  getNameClaims(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameClaimsOperationSpec);
  }

  /**
   * Get name pointees
   * @param id The name
   * @param options The options parameters.
   */
  getNamePointees(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNamePointeesOperationSpec);
  }

  /**
   * Get name pointers
   * @param id The name
   * @param options The options parameters.
   */
  getNamePointers(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNamePointersOperationSpec);
  }

  /**
   * Get name transfers
   * @param id The name or name hash
   * @param options The options parameters.
   */
  getNameTransfers(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameTransfersOperationSpec);
  }

  /**
   * Get name updates
   * @param id The name or name hash
   * @param options The options parameters.
   */
  getNameUpdates(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getNameUpdatesOperationSpec);
  }

  /**
   * Get a single oracle.
   * @param id The oracle
   * @param options The options parameters.
   */
  getOracle(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getOracleOperationSpec);
  }

  /**
   * Get multiple oracles.
   * @param options The options parameters.
   */
  getOracles(options) {
    return this.sendOperationRequest({
      options
    }, getOraclesOperationSpec);
  }

  /**
   * Gets the current syncing status of both middleware and the node
   * @param options The options parameters.
   */
  getStatus(options) {
    return this.sendOperationRequest({
      options
    }, middleware_getStatusOperationSpec);
  }

  /**
   * Get total accumulated stats.
   * @param options The options parameters.
   */
  getTotalstats(options) {
    return this.sendOperationRequest({
      options
    }, getTotalstatsOperationSpec);
  }

  /**
   * Get multiple transfers.
   * @param options The options parameters.
   */
  getTransfers(options) {
    return this.sendOperationRequest({
      options
    }, getTransfersOperationSpec);
  }

  /**
   * Get multiple transactions.
   * @param options The options parameters.
   */
  getTxs(options) {
    return this.sendOperationRequest({
      options
    }, getTxsOperationSpec);
  }

  /**
   * Get count of transactions at the latest height.
   * @param options The options parameters.
   */
  getTxCount(options) {
    return this.sendOperationRequest({
      options
    }, getTxCountOperationSpec);
  }

  /**
   * Get transactions count and its type for given aeternity ID.
   * @param id The ID of the address/name/oracle/etc
   * @param options The options parameters.
   */
  getTxCountById(id, options) {
    return this.sendOperationRequest({
      id,
      options
    }, getTxCountByIdOperationSpec);
  }

  /**
   * Get a single transaction.
   * @param hashOrIndex The transaction encoded hash or index (txi)
   * @param options The options parameters.
   */
  getTx(hashOrIndex, options) {
    return this.sendOperationRequest({
      hashOrIndex,
      options
    }, getTxOperationSpec);
  }
}
// Operation Specifications
const middleware_serializer = core_client_.createSerializer(middleware_models_mappers_namespaceObject, /* isXml */false);
const getAccountActivitiesOperationSpec = {
  path: "/v2/accounts/{id}/activities",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsKlr2M2V2AccountsIdActivitiesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [ownedOnly, parameters_type, parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getSortedAex141ContractsOperationSpec = {
  path: "/v2/aex141",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsFlc7UjV2Aex141GetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction, by, prefix],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141OwnedTokensOperationSpec = {
  path: "/v2/aex141/owned-nfts/{accountId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsSs61ZgV2Aex141OwnedNftsAccountidGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction],
  urlParameters: [models_parameters_$host, accountId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141TokenOwnerOperationSpec = {
  path: "/v2/aex141/{contractId}/owner/{tokenId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "String"
        }
      }
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, contractId, tokenId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141ContractOwnersOperationSpec = {
  path: "/v2/aex141/{contractId}/owners",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Ilysy5V2Aex141ContractidOwnersGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction],
  urlParameters: [models_parameters_$host, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141ContractTemplatesOperationSpec = {
  path: "/v2/aex141/{contractId}/templates",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths17O9Fn6V2Aex141ContractidTemplatesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction],
  urlParameters: [models_parameters_$host, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141TemplateTokensOperationSpec = {
  path: "/v2/aex141/{contractId}/templates/{templateId}/tokens",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsNuoourV2Aex141ContractidTemplatesTemplateidTokensGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction],
  urlParameters: [models_parameters_$host, contractId, templateId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex141ByContractOperationSpec = {
  path: "/v2/aex141/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Aex141Response
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getSortedAex9TokensOperationSpec = {
  path: "/v2/aex9",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Wbogg8V2Aex9GetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction, by, prefix],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9AccountBalancesOperationSpec = {
  path: "/v2/aex9/account-balances/{account_id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1BsirxgV2Aex9AccountBalancesAccountIdGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, accountId1],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9TokensCountOperationSpec = {
  path: "/v2/aex9/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Number"
        }
      }
    }
  },
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9PairTransfersOperationSpec = {
  path: "/v2/aex9/transfers/from-to/{sender}/{recipient}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1V0FiznV2Aex9TransfersFromToSenderRecipientGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction],
  urlParameters: [models_parameters_$host, sender, recipient],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9SenderTransfersOperationSpec = {
  path: "/v2/aex9/transfers/from/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1X48QgjV2Aex9TransfersFromIdGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction],
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9RecipientTransfersOperationSpec = {
  path: "/v2/aex9/transfers/to/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1DkkopqV2Aex9TransfersToIdGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction],
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9ContractBalancesOperationSpec = {
  path: "/v2/aex9/{contractId}/balances",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsNi359V2Aex9ContractidBalancesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction, by],
  urlParameters: [models_parameters_$host, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9ContractAccountBalanceOperationSpec = {
  path: "/v2/aex9/{contractId}/balances/{accountId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1R02SlwV2Aex9ContractidBalancesAccountidGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [models_parameters_hash],
  urlParameters: [models_parameters_$host, accountId, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9ContractAccountBalanceHistoryOperationSpec = {
  path: "/v2/aex9/{contractId}/balances/{accountId}/history",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1T9RwnyV2Aex9ContractidBalancesAccountidHistoryGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host, accountId, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9LogsCountOperationSpec = {
  path: "/v2/aex9/{contractId}/logs-count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Number"
        }
      }
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, contractId],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getAex9ByContractOperationSpec = {
  path: "/v2/aex9/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Aex9Response
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getBlocksOperationSpec = {
  path: "/v2/blocks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths15Ih6XV2BlocksGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getBlockOperationSpec = {
  path: "/v2/blocks/{hash_or_kbi}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Block
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hashOrKbi],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getBlockByMbiOperationSpec = {
  path: "/v2/blocks/{kbi}/{mbi}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Block
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, kbi, mbi],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getChannelsOperationSpec = {
  path: "/v2/channels",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Txl2A9V2ChannelsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction, state],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getChannelOperationSpec = {
  path: "/v2/channels/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: mappers_Channel
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getContractsCallsOperationSpec = {
  path: "/v2/contracts/calls",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths187U0XzV2ContractsCallsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getContractsLogsOperationSpec = {
  path: "/v2/contracts/logs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsB246H1V2ContractsLogsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction, contractId1, parameters_event, functionPrefix, data, aexnArgs],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getDeltastatsOperationSpec = {
  path: "/v2/deltastats",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths7Pbec0V2DeltastatsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getKeyBlocksOperationSpec = {
  path: "/v2/key-blocks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths1Ulxr59V2KeyBlocksGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getKeyBlockOperationSpec = {
  path: "/v2/key-blocks/{hash_or_kbi}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: mappers_KeyBlock
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hashOrKbi],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getKeyBlockMicroBlocksOperationSpec = {
  path: "/v2/key-blocks/{hash_or_kbi}/micro-blocks",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsO99PhzV2KeyBlocksHashOrKbiMicroBlocksGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host, hashOrKbi],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getMicroBlockOperationSpec = {
  path: "/v2/micro-blocks/{hash}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: MicroBlock
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hash1],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getMicroBlockTransactionsOperationSpec = {
  path: "/v2/micro-blocks/{hash}/txs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsGuqvhdV2MicroBlocksHashTxsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hash1],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNamesOperationSpec = {
  path: "/v2/names",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsK9TkttV2NamesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, direction, by, ownedBy, state1],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNamesAuctionsOperationSpec = {
  path: "/v2/names/auctions",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Auction
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const searchNamesOperationSpec = {
  path: "/v2/names/search",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths3Msq0DV2NamesSearchGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameOperationSpec = {
  path: "/v2/names/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Name
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameAuctionOperationSpec = {
  path: "/v2/names/{id}/auction",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Auction
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameClaimsOperationSpec = {
  path: "/v2/names/{id}/claims",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NameClaim
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNamePointeesOperationSpec = {
  path: "/v2/names/{id}/pointees",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsDjelzuV2NamesIdPointeesGetResponses200ContentApplicationJsonSchema
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNamePointersOperationSpec = {
  path: "/v2/names/{id}/pointers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Dictionary",
          value: {
            type: {
              name: "any"
            }
          }
        }
      }
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameTransfersOperationSpec = {
  path: "/v2/names/{id}/transfers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NameTransfer
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getNameUpdatesOperationSpec = {
  path: "/v2/names/{id}/updates",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: NameUpdate
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getOracleOperationSpec = {
  path: "/v2/oracle/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Oracle
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getOraclesOperationSpec = {
  path: "/v2/oracles",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsB0YvynV2OraclesGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const middleware_getStatusOperationSpec = {
  path: "/v2/status",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: mappers_Status
    }
  },
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTotalstatsOperationSpec = {
  path: "/v2/totalstats",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths15PsutbV2TotalstatsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTransfersOperationSpec = {
  path: "/v2/transfers",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsIgs9Z1V2TransfersGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTxsOperationSpec = {
  path: "/v2/txs",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: PathsFclv4TV2TxsGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  queryParameters: [parameters_limit, scope, direction, type1, typeGroup, account, contract, channel, oracle, senderId, recipientId, entrypoint],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTxCountOperationSpec = {
  path: "/v2/txs/count",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: {
        type: {
          name: "Number"
        }
      }
    }
  },
  queryParameters: [scope, txType, id1],
  urlParameters: [models_parameters_$host],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTxCountByIdOperationSpec = {
  path: "/v2/txs/count/{id}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: Paths16Tt677V2TxsCountIdGetResponses200ContentApplicationJsonSchema
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, id],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
const getTxOperationSpec = {
  path: "/v2/txs/{hash_or_index}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: mappers_Tx
    },
    400: {
      bodyMapper: ErrorResponse,
      isError: true
    },
    404: {
      bodyMapper: NotFoundResponse,
      isError: true
    }
  },
  urlParameters: [models_parameters_$host, hashOrIndex],
  headerParameters: [models_parameters_accept],
  serializer: middleware_serializer
};
;// CONCATENATED MODULE: ./src/Middleware.ts
function Middleware_classPrivateMethodInitSpec(obj, privateSet) { Middleware_checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function Middleware_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function Middleware_classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }
// eslint-disable-next-line max-classes-per-file




const Middleware_bigIntPropertyNames = [];
const Middleware_numberPropertyNames = [];
var Middleware_mapData = /*#__PURE__*/new WeakSet();
var Middleware_encodeArg = /*#__PURE__*/new WeakSet();
var Middleware_decodeRes = /*#__PURE__*/new WeakSet();
class MiddlewareTransformed extends Middleware {
  constructor(...args) {
    super(...args);
    Middleware_classPrivateMethodInitSpec(this, Middleware_decodeRes);
    Middleware_classPrivateMethodInitSpec(this, Middleware_encodeArg);
    Middleware_classPrivateMethodInitSpec(this, Middleware_mapData);
  }
  async sendOperationRequest(operationArguments, operationSpec) {
    const args = mapObject(operationArguments, ([key, value]) => [key, Middleware_classPrivateMethodGet(this, Middleware_encodeArg, Middleware_encodeArg2).call(this, value)]);
    return Middleware_classPrivateMethodGet(this, Middleware_decodeRes, Middleware_decodeRes2).call(this, await super.sendOperationRequest(args, operationSpec));
  }
}
function Middleware_mapData2(data, transform) {
  if (Array.isArray(data)) return data.map(d => Middleware_classPrivateMethodGet(this, Middleware_mapData, Middleware_mapData2).call(this, d, transform));
  if (data != null && typeof data === 'object') {
    return mapObject(data, ([key, value]) => {
      if (value == null) return [key, value];
      if (Middleware_bigIntPropertyNames.some(k => k === key)) return [key, transform.bigInt(value)];
      if (Middleware_numberPropertyNames.some(k => k === key)) return [key, transform.number(value)];
      return [key, Middleware_classPrivateMethodGet(this, Middleware_mapData, Middleware_mapData2).call(this, value, transform)];
    });
  }
  return data;
}
function Middleware_encodeArg2(data) {
  return Middleware_classPrivateMethodGet(this, Middleware_mapData, Middleware_mapData2).call(this, data, {
    bigInt: value => {
      if (value instanceof (external_bignumber_js_default())) return value.toFixed();
      return value.toString();
    },
    number: value => value.toString()
  });
}
function Middleware_decodeRes2(data) {
  return Middleware_classPrivateMethodGet(this, Middleware_mapData, Middleware_mapData2).call(this, data, {
    bigInt: value => BigInt(value),
    number: value => +value
  });
}
class Middleware_Middleware extends MiddlewareTransformed {
  /**
   * @param url - Url for middleware API
   * @param options - Options
   * @param options.ignoreVersion - Don't ensure that the middleware is supported
   * @param options.retryCount - Amount of extra requests to do in case of failure
   * @param options.retryOverallDelay - Time in ms to wait between all retries
   */
  constructor(url, {
    ignoreVersion = false,
    retryCount = 3,
    retryOverallDelay = 800,
    ...options
  } = {}) {
    // eslint-disable-next-line constructor-super
    super(url, {
      allowInsecureConnection: true,
      additionalPolicies: [genRequestQueuesPolicy(), genCombineGetRequestsPolicy(), genRetryOnFailurePolicy(retryCount, retryOverallDelay), genErrorFormatterPolicy(body => ` ${body.error}`)],
      ...options
    });
    if (!ignoreVersion) {
      const statusPromise = this.getStatus();
      const versionPromise = statusPromise.then(({
        mdwVersion
      }) => mdwVersion, error => error);
      this.pipeline.addPolicy(genVersionCheckPolicy('middleware', '/v2/status', versionPromise, '1.47.0', '2.0.0'));
    }
  }
}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/connection-proxy.ts
/**
 * Browser connection proxy
 * Provide functionality to easily forward messages from one connection to another and back
 * @category aepp wallet communication
 * @param con1 - first connection
 * @param con2 - second connection
 * @returns a function to stop proxying
 */
/* harmony default export */ const connection_proxy = ((con1, con2) => {
  con1.connect(msg => con2.sendMessage(msg), () => con2.disconnect());
  con2.connect(msg => con1.sendMessage(msg), () => con1.disconnect());
  return () => {
    con1.disconnect();
    con2.disconnect();
  };
});
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/connection/Browser.ts


/**
 * Browser connection base interface
 * @category aepp wallet communication
 */
class BrowserConnection {
  constructor({
    debug = false
  }) {
    this.debug = debug;
  }

  /**
   * Connect
   * @param onMessage - Message handler
   * @param onDisconnect - trigger when runtime connection in closed
   */
  connect(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMessage,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDisconnect) {
    if (this.isConnected()) throw new AlreadyConnectedError('You already connected');
  }

  /**
   * Disconnect
   */
  disconnect() {
    if (!this.isConnected()) throw new NoWalletConnectedError('You dont have connection. Please connect before');
  }

  /**
   * Receive message
   */
  receiveMessage(message) {
    if (this.debug) console.log('Receive message:', message);
  }

  /**
   * Send message
   */
  sendMessage(message) {
    if (this.debug) console.log('Send message:', message);
  }

  /**
   * Check if connected
   * @returns Is connected
   */
}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/connection/BrowserWindowMessage.ts


function BrowserWindowMessage_classPrivateFieldInitSpec(obj, privateMap, value) { BrowserWindowMessage_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function BrowserWindowMessage_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }



var _onDisconnect = /*#__PURE__*/new WeakMap();
var _target = /*#__PURE__*/new WeakMap();
var _self = /*#__PURE__*/new WeakMap();
/**
 * Browser window Post Message connector module
 * @category aepp wallet communication
 */
class BrowserWindowMessageConnection extends BrowserConnection {
  /**
   * @param options - Options
   * @param options.target Target window for message
   * @param options.self Host window for message
   * @param options.origin Origin of receiver
   * @param options.sendDirection Wrapping messages into additional struct
   * `({ type: 'to_aepp' || 'to_waellet', data })`
   * Used for handling messages between content script and page
   * @param options.receiveDirection Unwrapping messages from additional struct
   */
  constructor({
    target,
    self = window,
    origin,
    sendDirection,
    receiveDirection = MESSAGE_DIRECTION.to_aepp,
    ...options
  } = {}) {
    super(options);
    BrowserWindowMessage_classPrivateFieldInitSpec(this, _onDisconnect, {
      writable: true,
      value: void 0
    });
    BrowserWindowMessage_classPrivateFieldInitSpec(this, _target, {
      writable: true,
      value: void 0
    });
    BrowserWindowMessage_classPrivateFieldInitSpec(this, _self, {
      writable: true,
      value: void 0
    });
    classPrivateFieldSet_default()(this, _target, target);
    classPrivateFieldSet_default()(this, _self, self);
    this.origin = origin;
    this.sendDirection = sendDirection;
    this.receiveDirection = receiveDirection;
  }
  isConnected() {
    return this.listener != null;
  }
  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);
    this.listener = message => {
      var _message$data$jsonrpc, _message$data$data;
      // TODO: strict validate origin and source instead of checking message structure
      if (typeof message.data !== 'object' || ((_message$data$jsonrpc = message.data.jsonrpc) !== null && _message$data$jsonrpc !== void 0 ? _message$data$jsonrpc : (_message$data$data = message.data.data) === null || _message$data$data === void 0 ? void 0 : _message$data$data.jsonrpc) !== '2.0') return;
      if (this.origin != null && this.origin !== message.origin) return;
      if (classPrivateFieldGet_default()(this, _target) != null && classPrivateFieldGet_default()(this, _target) !== message.source) return;
      this.receiveMessage(message);
      let {
        data
      } = message;
      if (data.type != null) {
        if (message.data.type !== this.receiveDirection) return;
        data = data.data;
      }
      onMessage(data, message.origin, message.source);
    };
    classPrivateFieldGet_default()(this, _self).addEventListener('message', this.listener);
    classPrivateFieldSet_default()(this, _onDisconnect, onDisconnect);
  }
  disconnect() {
    super.disconnect();
    if (this.listener == null || classPrivateFieldGet_default()(this, _onDisconnect) == null) {
      throw new InternalError('Expected to not happen, required for TS');
    }
    classPrivateFieldGet_default()(this, _self).removeEventListener('message', this.listener);
    delete this.listener;
    classPrivateFieldGet_default()(this, _onDisconnect).call(this);
    classPrivateFieldSet_default()(this, _onDisconnect, undefined);
  }
  sendMessage(msg) {
    var _this$origin;
    if (classPrivateFieldGet_default()(this, _target) == null) throw new RpcConnectionError('Can\'t send messages without target');
    const message = this.sendDirection != null ? {
      type: this.sendDirection,
      data: msg
    } : msg;
    super.sendMessage(message);
    classPrivateFieldGet_default()(this, _target).postMessage(message, (_this$origin = this.origin) !== null && _this$origin !== void 0 ? _this$origin : '*');
  }
}
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/wallet-detector.ts



/**
 * A function to detect available wallets
 * @category aepp wallet communication
 * @param connection - connection to use to detect wallets
 * @param onDetected - call-back function which trigger on new wallet
 * @returns a function to stop scanning
 */
/* harmony default export */ const wallet_detector = ((connection, onDetected) => {
  if (window == null) throw new UnsupportedPlatformError('Window object not found, you can run wallet detector only in browser');
  const wallets = {};
  connection.connect(({
    method,
    params
  }, origin, source) => {
    if (method !== METHODS.readyToConnect || wallets[params.id] != null) return;
    const wallet = {
      info: params,
      getConnection() {
        return new BrowserWindowMessageConnection({
          target: source,
          ...(params.type === 'extension' ? {
            sendDirection: MESSAGE_DIRECTION.to_waellet,
            receiveDirection: MESSAGE_DIRECTION.to_aepp,
            ...(window.origin !== 'null' && {
              origin: window.origin
            })
          } : {
            origin: params.origin
          })
        });
      }
    };
    wallets[wallet.info.id] = wallet;
    onDetected({
      wallets,
      newWallet: wallet
    });
  }, () => {});
  return () => connection.disconnect();
});
;// CONCATENATED MODULE: ./src/aepp-wallet-communication/connection/BrowserRuntime.ts


function BrowserRuntime_classPrivateFieldInitSpec(obj, privateMap, value) { BrowserRuntime_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function BrowserRuntime_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }



/**
 * BrowserRuntimeConnection
 * Handle browser runtime communication
 * @category aepp wallet communication
 */
var _listeners = /*#__PURE__*/new WeakMap();
class BrowserRuntimeConnection extends BrowserConnection {
  constructor({
    port,
    ...options
  }) {
    super(options);
    BrowserRuntime_classPrivateFieldInitSpec(this, _listeners, {
      writable: true,
      value: void 0
    });
    this.port = port;
  }
  disconnect() {
    super.disconnect();
    this.port.disconnect();
    if (classPrivateFieldGet_default()(this, _listeners) == null) throw new UnexpectedTsError();
    this.port.onMessage.removeListener(classPrivateFieldGet_default()(this, _listeners)[0]);
    this.port.onDisconnect.removeListener(classPrivateFieldGet_default()(this, _listeners)[1]);
    classPrivateFieldSet_default()(this, _listeners, undefined);
  }
  connect(onMessage, onDisconnect) {
    super.connect(onMessage, onDisconnect);
    classPrivateFieldSet_default()(this, _listeners, [(message, port) => {
      var _port$sender$url, _port$sender;
      this.receiveMessage(message);
      // TODO: make `origin` optional because sender url is not available on aepp side
      onMessage(message, (_port$sender$url = (_port$sender = port.sender) === null || _port$sender === void 0 ? void 0 : _port$sender.url) !== null && _port$sender$url !== void 0 ? _port$sender$url : '', port);
    }, onDisconnect]);
    this.port.onMessage.addListener(classPrivateFieldGet_default()(this, _listeners)[0]);
    this.port.onDisconnect.addListener(classPrivateFieldGet_default()(this, _listeners)[1]);
  }
  sendMessage(message) {
    super.sendMessage(message);
    this.port.postMessage(message);
  }
  isConnected() {
    return classPrivateFieldGet_default()(this, _listeners) != null;
  }
}
;// CONCATENATED MODULE: ./src/deprecated.ts




/**
 * @category exception
 * @deprecated this exception is not thrown anymore
 */
class RpcBroadcastError extends RpcError {
  constructor(data) {
    super('Broadcast failed');
    defineProperty_default()(this, "code", 3);
    this.data = data;
    this.name = 'RpcBroadcastError';
  }
}

/**
 * @deprecated use isAuctionName instead
 */
defineProperty_default()(RpcBroadcastError, "code", 3);
const NAME_BID_MAX_LENGTH = 12; // # this is the max length for a domain to be part of a bid

/**
 * @deprecated use ContractByteArrayEncoder:encodeWithType from \@aeternity/aepp-calldata
 */
function encodeFateValue(value, aci) {
  const valueType = new aepp_calldata_.TypeResolver().resolveType(aci, {});
  return new aepp_calldata_.ContractByteArrayEncoder().encodeWithType(value, valueType);
}

/**
 * @deprecated use ContractByteArrayEncoder:decodeWithType from \@aeternity/aepp-calldata
 */
function decodeFateValue(value, aci) {
  const valueType = new aepp_calldata_.TypeResolver().resolveType(aci, {});
  return new aepp_calldata_.ContractByteArrayEncoder().decodeWithType(value, valueType);
}
;// CONCATENATED MODULE: ./src/index-browser.ts







// TODO: move to constants




































;// CONCATENATED MODULE: external "child_process"
const external_child_process_namespaceObject = require("child_process");
;// CONCATENATED MODULE: external "os"
const external_os_namespaceObject = require("os");
;// CONCATENATED MODULE: external "path"
const external_path_namespaceObject = require("path");
;// CONCATENATED MODULE: external "fs/promises"
const promises_namespaceObject = require("fs/promises");
// EXTERNAL MODULE: external "url"
var external_url_ = __webpack_require__(7310);
;// CONCATENATED MODULE: ./src/contract/compiler/Cli.ts


function Cli_classPrivateMethodInitSpec(obj, privateSet) { Cli_checkPrivateRedeclaration(obj, privateSet); privateSet.add(obj); }
function Cli_classPrivateFieldInitSpec(obj, privateMap, value) { Cli_checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function Cli_checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
function Cli_classStaticPrivateMethodGet(receiver, classConstructor, method) { Cli_classCheckPrivateStaticAccess(receiver, classConstructor); return method; }
function Cli_classCheckPrivateStaticAccess(receiver, classConstructor) { if (receiver !== classConstructor) { throw new TypeError("Private static access of wrong provenance"); } }
function Cli_classPrivateMethodGet(receiver, privateSet, fn) { if (!privateSet.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } return fn; }









const getPackagePath = () => {
  const path = (0,external_path_namespaceObject.dirname)((0,external_url_.fileURLToPath)((__webpack_require__(7310).pathToFileURL)(__filename).toString()));
  if ((0,external_path_namespaceObject.basename)(path) === 'dist') return (0,external_path_namespaceObject.resolve)(path, '..');
  if ((0,external_path_namespaceObject.basename)(path) === 'compiler') return (0,external_path_namespaceObject.resolve)(path, '../../..');
  throw new InternalError('Can\'t get package path');
};

/**
 * A wrapper around aesophia_cli, available only in Node.js.
 * Requires Erlang installed, assumes that `escript` is available in PATH.
 */
var _path = /*#__PURE__*/new WeakMap();
var _ensureCompatibleVersion = /*#__PURE__*/new WeakMap();
var _run = /*#__PURE__*/new WeakSet();
class CompilerCli extends CompilerBase {
  /**
   * @param compilerPath - A path to aesophia_cli binary, by default uses the integrated one
   * @param options - Options
   * @param options.ignoreVersion - Don't ensure that the compiler is supported
   */
  constructor(compilerPath = (0,external_path_namespaceObject.resolve)(getPackagePath(), './bin/aesophia_cli'), {
    ignoreVersion
  } = {}) {
    super();
    Cli_classPrivateMethodInitSpec(this, _run);
    Cli_classPrivateFieldInitSpec(this, _path, {
      writable: true,
      value: void 0
    });
    Cli_classPrivateFieldInitSpec(this, _ensureCompatibleVersion, {
      writable: true,
      value: Promise.resolve()
    });
    classPrivateFieldSet_default()(this, _path, compilerPath);
    if (ignoreVersion !== true) {
      classPrivateFieldSet_default()(this, _ensureCompatibleVersion, this.version().then(version => {
        const versions = [version, '7.2.1', '8.0.0'];
        if (!semverSatisfies(...versions)) throw new UnsupportedVersionError('compiler', ...versions);
      }));
    }
  }
  async compile(path) {
    await classPrivateFieldGet_default()(this, _ensureCompatibleVersion);
    try {
      const [bytecode, aci] = await Promise.all([Cli_classPrivateMethodGet(this, _run, _run2).call(this, path), Cli_classPrivateMethodGet(this, _run, _run2).call(this, '--create_json_aci', path).then(res => JSON.parse(res))]);
      return {
        bytecode: bytecode.trimEnd(),
        aci
      };
    } catch (error) {
      ensureError(error);
      throw new CompilerError(error.message);
    }
  }
  async compileBySourceCode(sourceCode, fileSystem) {
    const tmp = await Cli_classStaticPrivateMethodGet(CompilerCli, CompilerCli, _saveContractToTmpDir).call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.compile(tmp);
    } finally {
      await (0,promises_namespaceObject.rm)((0,external_path_namespaceObject.dirname)(tmp), {
        recursive: true
      });
    }
  }
  async generateAci(path) {
    await classPrivateFieldGet_default()(this, _ensureCompatibleVersion);
    try {
      return JSON.parse(await Cli_classPrivateMethodGet(this, _run, _run2).call(this, '--no_code', '--create_json_aci', path));
    } catch (error) {
      ensureError(error);
      throw new CompilerError(error.message);
    }
  }
  async generateAciBySourceCode(sourceCode, fileSystem) {
    const tmp = await Cli_classStaticPrivateMethodGet(CompilerCli, CompilerCli, _saveContractToTmpDir).call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.generateAci(tmp);
    } finally {
      await (0,promises_namespaceObject.rm)((0,external_path_namespaceObject.dirname)(tmp), {
        recursive: true
      });
    }
  }
  async validate(bytecode, path) {
    await classPrivateFieldGet_default()(this, _ensureCompatibleVersion);
    try {
      return (await Cli_classPrivateMethodGet(this, _run, _run2).call(this, path, '--validate', bytecode)).includes('Validation successful.');
    } catch (error) {
      return false;
    }
  }
  async validateBySourceCode(bytecode, sourceCode, fileSystem) {
    const tmp = await Cli_classStaticPrivateMethodGet(CompilerCli, CompilerCli, _saveContractToTmpDir).call(CompilerCli, sourceCode, fileSystem);
    try {
      return await this.validate(bytecode, tmp);
    } finally {
      await (0,promises_namespaceObject.rm)((0,external_path_namespaceObject.dirname)(tmp), {
        recursive: true
      });
    }
  }
  async version() {
    var _verMessage$match;
    const verMessage = await Cli_classPrivateMethodGet(this, _run, _run2).call(this, '--version');
    const ver = (_verMessage$match = verMessage.match(/Sophia compiler version ([\d.]+)\n/)) === null || _verMessage$match === void 0 ? void 0 : _verMessage$match[1];
    if (ver == null) throw new CompilerError('Can\'t get compiler version');
    return ver;
  }
}
async function _run2(...parameters) {
  return new Promise((pResolve, pReject) => {
    (0,external_child_process_namespaceObject.execFile)('escript', [classPrivateFieldGet_default()(this, _path), ...parameters], (error, stdout, stderr) => {
      if (error != null) pReject(error);else if (stderr !== '') pReject(new CompilerError(stderr));else pResolve(stdout);
    });
  });
}
async function _saveContractToTmpDir(sourceCode, fileSystem = {}) {
  const randomName = () => Math.random().toString(36).slice(2);
  const path = (0,external_path_namespaceObject.resolve)((0,external_os_namespaceObject.tmpdir)(), `aepp-sdk-js-${randomName()}`);
  await (0,promises_namespaceObject.mkdir)(path);
  const sourceCodePath = (0,external_path_namespaceObject.resolve)(path, `${randomName()}.aes`);
  await (0,promises_namespaceObject.writeFile)(sourceCodePath, sourceCode);
  await Promise.all(Object.entries(fileSystem).map(async ([name, src]) => {
    const p = (0,external_path_namespaceObject.resolve)(path, name);
    await (0,promises_namespaceObject.mkdir)((0,external_path_namespaceObject.dirname)(p), {
      recursive: true
    });
    return (0,promises_namespaceObject.writeFile)(p, src);
  }));
  return sourceCodePath;
}
// EXTERNAL MODULE: ./node_modules/@babel/runtime-corejs3/core-js-stable/instance/flags.js
var flags = __webpack_require__(3959);
var flags_default = /*#__PURE__*/__webpack_require__.n(flags);
;// CONCATENATED MODULE: ./src/contract/compiler/getFileSystem.ts




const defaultIncludes = ['List.aes', 'Option.aes', 'String.aes', 'Func.aes', 'Pair.aes', 'Triple.aes', 'BLS12_381.aes', 'Frac.aes', 'Set.aes', 'Bitwise.aes'];
const includeRegExp = /^include\s*"([\w/.-]+)"/mi;
const includesRegExp = new RegExp(includeRegExp.source, `${flags_default()(includeRegExp)}g`);
async function getFileSystemRec(root, relative) {
  var _sourceCode$match;
  const sourceCode = await (0,promises_namespaceObject.readFile)((0,external_path_namespaceObject.resolve)(root, relative), 'utf8');
  const filesystem = {};
  await Promise.all(((_sourceCode$match = sourceCode.match(includesRegExp)) !== null && _sourceCode$match !== void 0 ? _sourceCode$match : []).map(include => {
    const m = include.match(includeRegExp);
    if ((m === null || m === void 0 ? void 0 : m.length) !== 2) throw new InternalError('Unexpected match length');
    return m[1];
  }).filter(include => !defaultIncludes.includes(include)).map(async include => {
    const includePath = (0,external_path_namespaceObject.resolve)(root, include);
    filesystem[include] = await (0,promises_namespaceObject.readFile)(includePath, 'utf8');
    Object.assign(filesystem, await getFileSystemRec(root, include));
  }));
  return filesystem;
}

/**
 * Reads all files included in the provided contract
 * Available only in Node.js
 * @param path - a path to the main contract source code
 */
async function getFileSystem(path) {
  return getFileSystemRec((0,external_path_namespaceObject.dirname)(path), (0,external_path_namespaceObject.basename)(path));
}
;// CONCATENATED MODULE: ./src/contract/compiler/HttpNode.ts




/**
 * Contract Compiler over HTTP for Nodejs
 *
 * Inherits CompilerHttp and implements `compile`, `validate` methods
 * @category contract
 * @example CompilerHttpNode('COMPILER_URL')
 */
class CompilerHttpNode extends CompilerHttp {
  async compile(path) {
    const fileSystem = await getFileSystem(path);
    const sourceCode = await (0,promises_namespaceObject.readFile)(path, 'utf8');
    return this.compileBySourceCode(sourceCode, fileSystem);
  }
  async generateAci(path) {
    const fileSystem = await getFileSystem(path);
    const sourceCode = await (0,promises_namespaceObject.readFile)(path, 'utf8');
    return this.generateAciBySourceCode(sourceCode, fileSystem);
  }
  async validate(bytecode, path) {
    const fileSystem = await getFileSystem(path);
    const sourceCode = await (0,promises_namespaceObject.readFile)(path, 'utf8');
    return this.validateBySourceCode(bytecode, sourceCode, fileSystem);
  }
}
;// CONCATENATED MODULE: ./src/index.ts




})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=aepp-sdk.js.map