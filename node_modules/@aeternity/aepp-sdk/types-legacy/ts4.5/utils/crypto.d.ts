/// <reference types="node" />
import { SignKeyPair } from 'tweetnacl';
import { Encoded, Encoding } from './encoder';
/**
 * Generate address from secret key
 * @param secret - Private key as hex string
 * @returns Public key encoded as address
 */
export declare function getAddressFromPriv(secret: string | Uint8Array): Encoded.AccountAddress;
/**
 * Check if address is valid
 * @param address - Address
 * @param prefix - Transaction prefix. Default: 'ak'
 * @returns is valid
 */
export declare function isAddressValid(address: string, prefix?: Encoding): boolean;
/**
 * Generate a random salt (positive integer)
 * @returns random salt
 */
export declare function genSalt(): number;
/**
 * Converts a positive integer to the smallest possible
 * representation in a binary digit representation
 * @param value - Value to encode
 * @returns Encoded number
 */
export declare function encodeUnsigned(value: number): Buffer;
/**
 * Calculate 256bits Blake2b hash of `input`
 * @param input - Data to hash
 * @returns Hash
 */
export declare function hash(input: string | Uint8Array): Buffer;
/**
 * Compute contract address
 * @category contract
 * @param owner - Address of contract owner
 * @param nonce - Round when contract was created
 * @returns Contract address
 */
export declare function encodeContractAddress(owner: Encoded.AccountAddress, nonce: number): Encoded.ContractAddress;
/**
 * Generate keyPair from secret key
 * @param secret - secret key
 * @returns Object with Private(privateKey) and Public(publicKey) keys
 */
export declare function generateKeyPairFromSecret(secret: Uint8Array): SignKeyPair;
/**
 * Generate a random ED25519 keypair
 * @param raw - Whether to return raw (binary) keys
 * @returns Key pair
 */
export declare function generateKeyPair(raw: true): {
    publicKey: Buffer;
    secretKey: Buffer;
};
export declare function generateKeyPair(raw?: false): {
    publicKey: Encoded.AccountAddress;
    secretKey: string;
};
/**
 * Generate signature
 * @param data - Data to sign
 * @param privateKey - Key to sign with
 * @returns Signature
 */
export declare function sign(data: string | Uint8Array, privateKey: string | Uint8Array): Uint8Array;
/**
 * Verify that signature was signed by public key
 * @param data - Data that was signed
 * @param signature - Signature of data
 * @param address - Address to verify against
 * @returns is data was signed by address
 */
export declare function verify(data: Uint8Array, signature: Uint8Array, address: Encoded.AccountAddress): boolean;
export declare const messagePrefixLength: Buffer;
export declare function messageToHash(message: string): Buffer;
export declare function signMessage(message: string, privateKey: string | Buffer): Uint8Array;
/**
 * Verify that message was signed by address
 * @param message - Message that was signed
 * @param signature - Signature of message
 * @param address - Address to verify against
 * @returns is data was signed by address
 */
export declare function verifyMessage(message: string, signature: Uint8Array, address: Encoded.AccountAddress): boolean;
/**
 * Check key pair for validity
 *
 * Signs a message, and then verifies that signature
 * @param privateKey - Private key to verify
 * @param publicKey - Public key to verify as hex string
 * @returns Valid?
 */
export declare function isValidKeypair(privateKey: string | Uint8Array, publicKey: string | Uint8Array): boolean;
