import BigNumber from 'bignumber.js';
import type Channel from './Base';
import { Encoded } from '../utils/encoder';
import { BaseError } from '../utils/errors';
export interface ChannelEvents {
    statusChanged: (status: ChannelStatus) => void;
    stateChanged: (tx: Encoded.Transaction | '') => void;
    depositLocked: () => void;
    ownDepositLocked: () => void;
    withdrawLocked: () => void;
    ownWithdrawLocked: () => void;
    peerDisconnected: () => void;
    channelReestablished: () => void;
    error: (error: Error) => void;
    onChainTx: (tx: Encoded.Transaction, details: {
        info: string;
        type: string;
    }) => void;
    message: (message: string | Object) => void;
    newContract: (contractAddress: Encoded.ContractAddress) => void;
}
export interface ChannelAction {
    guard: (channel: Channel, state?: ChannelFsm) => boolean;
    action: (channel: Channel, state?: ChannelFsm) => ChannelFsm;
}
interface SignOptions {
    updates?: any[];
    [k: string]: any;
}
export type SignTxWithTag = (tag: string, tx: Encoded.Transaction, options?: SignOptions) => (Promise<Encoded.Transaction>);
export type SignTx = (tx: Encoded.Transaction, options?: SignOptions) => (Promise<Encoded.Transaction | number | null>);
export interface ChannelOptions {
    existingFsmId?: Encoded.Bytearray;
    url: string;
    /**
     * @see {@link https://github.com/aeternity/protocol/blob/6734de2e4c7cce7e5e626caa8305fb535785131d/node/api/channels_api_usage.md#channel-establishing-parameters}
     */
    initiatorId: Encoded.AccountAddress;
    responderId: Encoded.AccountAddress;
    lockPeriod: number;
    pushAmount: number;
    initiatorAmount: BigNumber;
    responderAmount: BigNumber;
    channelReserve?: BigNumber | number;
    ttl?: number;
    host: string;
    port: number;
    role: 'initiator' | 'responder';
    minimumDepthStrategy?: 'txfee' | 'plain';
    minimumDepth?: number;
    fee?: BigNumber | number;
    gasPrice?: BigNumber | number;
    signedTx?: string;
    existingChannelId?: string;
    offChainTx?: string;
    reconnectTx?: string;
    timeoutIdle?: number;
    timeoutFundingCreate?: number;
    timeoutFundingSign?: number;
    timeoutFundingLock?: number;
    timeoutSign?: number;
    timeoutAccept?: number;
    timeoutInitialized?: number;
    timeoutAwaitingOpen?: number;
    statePassword?: string;
    debug: boolean;
    sign: SignTxWithTag;
    offchainTx?: string;
}
export interface ChannelHandler extends Function {
    enter?: Function;
}
export interface ChannelState {
    signedTx: Encoded.Transaction;
    resolve: (r?: any) => void;
    reject: (e: BaseError) => void;
    sign: SignTx;
    handler?: ChannelHandler;
    onOnChainTx?: (tx: Encoded.Transaction) => void;
    onOwnWithdrawLocked?: () => void;
    onWithdrawLocked?: () => void;
    onOwnDepositLocked?: () => void;
    onDepositLocked?: () => void;
    closeTx?: string;
}
export interface ChannelFsm {
    handler: ChannelHandler;
    state?: ChannelState | {
        resolve: Function;
        reject: Function;
    };
}
export interface ChannelMessage {
    id?: number;
    method: string;
    params: any;
    payload?: any;
    data?: any;
    error?: ChannelMessageError;
}
interface ChannelMessageError {
    code: number;
    message: string;
    data: [
        {
            message: string;
            code: number;
        }
    ];
    request: ChannelMessage;
}
export declare function emit<E extends keyof ChannelEvents>(channel: Channel, ...args: [
    E,
    ...Parameters<ChannelEvents[E]>
]): void;
export type ChannelStatus = 'connecting' | 'connected' | 'accepted' | 'halfSigned' | 'signed' | 'open' | 'closing' | 'closed' | 'died' | 'disconnected';
export declare function changeStatus(channel: Channel, newStatus: ChannelStatus): void;
export declare function changeState(channel: Channel, newState: Encoded.Transaction | ''): void;
export declare function notify(channel: Channel, method: string, params?: object): void;
export declare function enqueueAction(channel: Channel, guard: ChannelAction['guard'], action: () => {
    handler: ChannelHandler;
    state?: Partial<ChannelState>;
}): Promise<any>;
export declare function disconnect(channel: Channel): void;
export declare function call(channel: Channel, method: string, params: any): Promise<any>;
export declare function initialize(channel: Channel, connectionHandler: Function, openHandler: Function, { url, ...channelOptions }: ChannelOptions): Promise<void>;
export {};
