import { Node as NodeApi, NodeOptionalParams } from './apis/node';
import { Encoded } from './utils/encoder';
import { ConsensusProtocolVersion } from './tx/builder/constants';
declare const bigIntPropertyNames: readonly [
    "balance",
    "queryFee",
    "fee",
    "amount",
    "nameFee",
    "channelAmount",
    "initiatorAmount",
    "responderAmount",
    "channelReserve",
    "initiatorAmountFinal",
    "responderAmountFinal",
    "gasPrice",
    "deposit"
];
declare const numberPropertyNames: readonly [
    "time",
    "gas",
    "gasUsed",
    "nameSalt",
    "nonce",
    "nextNonce",
    "height",
    "blockHeight",
    "topBlockHeight",
    "ttl",
    "nameTtl",
    "clientTtl",
    "inbound",
    "outbound",
    "peerCount",
    "pendingTransactionsCount",
    "effectiveAtHeight",
    "version",
    "solutions",
    "round"
];
type BigIntPropertyNames = typeof bigIntPropertyNames[number];
type NumberPropertyNames = typeof numberPropertyNames[number];
type PreserveOptional<NewType, OrigType> = OrigType extends undefined ? NewType | undefined : NewType;
export type TransformNodeType<Type> = Type extends (...args: infer Args) => infer Ret ? (...args: TransformNodeType<Args>) => TransformNodeType<Ret> : Type extends [
    infer Item,
    ...infer Rest
] ? [
    TransformNodeType<Item>,
    ...TransformNodeType<Rest>
] : Type extends Array<infer Item> ? Array<TransformNodeType<Item>> : Type extends Promise<infer T> ? Promise<TransformNodeType<T>> : Type extends {
    [P in any]: any;
} ? {
    [Property in keyof Type]: Property extends BigIntPropertyNames ? PreserveOptional<bigint, Type[Property]> : Property extends NumberPropertyNames ? PreserveOptional<number, Type[Property]> : Property extends 'txHash' ? PreserveOptional<Encoded.TxHash, Type[Property]> : Property extends 'bytecode' ? PreserveOptional<Encoded.ContractBytearray, Type[Property]> : TransformNodeType<Type[Property]>;
} : Type;
type NodeTransformedApi = new (...args: ConstructorParameters<typeof NodeApi>) => {
    [Name in keyof InstanceType<typeof NodeApi>]: Name extends 'pipeline' | 'sendRequest' | 'sendOperationRequest' ? NodeApi[Name] : TransformNodeType<NodeApi[Name]>;
};
interface NodeInfo {
    url: string;
    nodeNetworkId: string;
    version: string;
    consensusProtocolVersion: ConsensusProtocolVersion;
}
declare const Node_base: NodeTransformedApi;
export default class Node extends Node_base {
    #private;
    /**
     * @param url - Url for node API
     * @param options - Options
     * @param options.ignoreVersion - Don't ensure that the node is supported
     * @param options.retryCount - Amount of extra requests to do in case of failure
     * @param options.retryOverallDelay - Time in ms to wait between all retries
     */
    constructor(url: string, { ignoreVersion, retryCount, retryOverallDelay, ...options }?: NodeOptionalParams & {
        ignoreVersion?: boolean;
        retryCount?: number;
        retryOverallDelay?: number;
    });
    getNetworkId(): Promise<string>;
    getNodeInfo(): Promise<NodeInfo>;
}
export {};
