{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\n/**\n * Generalized Account module - routines to use generalized account\n */\nimport { ConsensusProtocolVersion, Tag } from \"../tx/builder/constants.mjs\";\nimport { buildContractIdByContractTx, buildTx, buildTxAsync, unpackTx } from \"../tx/builder/index.mjs\";\nimport { hash } from \"../utils/crypto.mjs\";\nimport { decode, encode, Encoding } from \"../utils/encoder.mjs\";\nimport { ArgumentError, IllegalArgumentError } from \"../utils/errors.mjs\";\nimport { concatBuffers } from \"../utils/other.mjs\";\nimport Contract from \"./Contract.mjs\";\nimport { sendTransaction, getAccount } from \"../chain.mjs\";\n/**\n * Convert current account to GA\n * @category contract\n * @param authFnName - Authorization function name\n * @param sourceCode - Auth contract source code\n * @param args - init arguments\n * @param options - Options\n * @returns General Account Object\n */\nexport async function createGeneralizedAccount(authFnName, args, _ref) {\n  var _options$gasLimit;\n  let {\n    onAccount,\n    onCompiler,\n    onNode,\n    bytecode,\n    aci,\n    sourceCodePath,\n    sourceCode,\n    fileSystem,\n    ...options\n  } = _ref;\n  const ownerId = onAccount.address;\n  if ((await getAccount(ownerId, {\n    onNode\n  })).kind === 'generalized') {\n    throw new IllegalArgumentError(`Account ${ownerId} is already GA`);\n  }\n  const contract = await Contract.initialize({\n    onAccount,\n    onCompiler,\n    onNode,\n    bytecode,\n    aci,\n    sourceCodePath,\n    sourceCode,\n    fileSystem\n  });\n  const tx = await buildTxAsync({\n    ...options,\n    tag: Tag.GaAttachTx,\n    onNode,\n    code: await contract.$compile(),\n    gasLimit: (_options$gasLimit = options.gasLimit) !== null && _options$gasLimit !== void 0 ? _options$gasLimit : await contract._estimateGas('init', args, options),\n    ownerId,\n    callData: contract._calldata.encode(contract._name, 'init', args),\n    authFun: hash(authFnName)\n  });\n  const contractId = buildContractIdByContractTx(tx);\n  const {\n    hash: transaction,\n    rawTx\n  } = await sendTransaction(tx, {\n    onNode,\n    onAccount,\n    onCompiler,\n    ...options\n  });\n  return Object.freeze({\n    owner: ownerId,\n    transaction,\n    rawTx,\n    gaContractId: contractId\n  });\n}\n/**\n * Build a transaction hash the same as `Auth.tx_hash` by GaMetaTx payload\n * @category contract\n * @param transaction - tx-encoded transaction\n * @param options - Options\n * @param options.fee - GaMetaTx fee, required in Ceres\n * @param options.gasPrice - GaMetaTx gasPrice, required in Ceres\n * @param options.onNode - Node to use\n * @returns Transaction hash\n */\nexport async function buildAuthTxHash(transaction, _ref2) {\n  let {\n    fee,\n    gasPrice,\n    onNode\n  } = _ref2;\n  const {\n    nodeNetworkId,\n    consensusProtocolVersion\n  } = await onNode.getNodeInfo();\n  let payload = hash(concatBuffers([_Buffer.from(nodeNetworkId), decode(transaction)]));\n  if (consensusProtocolVersion === ConsensusProtocolVersion.Ceres) {\n    if (fee == null) throw new ArgumentError('fee', 'provided (in Ceres)', fee);\n    if (gasPrice == null) throw new ArgumentError('gasPrice', 'provided (in Ceres)', gasPrice);\n    payload = hash(decode(buildTx({\n      tag: Tag.GaMetaTxAuthData,\n      fee,\n      gasPrice,\n      txHash: encode(payload, Encoding.TxHash)\n    })));\n  }\n  return payload;\n}\n\n/**\n * Build a transaction hash the same as `Auth.tx_hash` by GaMetaTx\n * @category contract\n * @param transaction - tx-encoded signed GaMeta transaction\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Transaction hash\n */\nexport async function buildAuthTxHashByGaMetaTx(transaction, _ref3) {\n  let {\n    onNode\n  } = _ref3;\n  const txParams = unpackTx(transaction, Tag.SignedTx);\n  if (txParams.encodedTx.tag !== Tag.GaMetaTx) {\n    throw new ArgumentError('transaction', 'to include GaMetaTx', Tag[txParams.encodedTx.tag]);\n  }\n  return buildAuthTxHash(buildTx(txParams.encodedTx.tx.encodedTx), {\n    fee: txParams.encodedTx.fee,\n    gasPrice: txParams.encodedTx.gasPrice,\n    onNode\n  });\n}","map":{"version":3,"names":["ConsensusProtocolVersion","Tag","buildContractIdByContractTx","buildTx","buildTxAsync","unpackTx","hash","decode","encode","Encoding","ArgumentError","IllegalArgumentError","concatBuffers","Contract","sendTransaction","getAccount","createGeneralizedAccount","authFnName","args","_ref","_options$gasLimit","onAccount","onCompiler","onNode","bytecode","aci","sourceCodePath","sourceCode","fileSystem","options","ownerId","address","kind","contract","initialize","tx","tag","GaAttachTx","code","$compile","gasLimit","_estimateGas","callData","_calldata","_name","authFun","contractId","transaction","rawTx","Object","freeze","owner","gaContractId","buildAuthTxHash","_ref2","fee","gasPrice","nodeNetworkId","consensusProtocolVersion","getNodeInfo","payload","_Buffer","from","Ceres","GaMetaTxAuthData","txHash","TxHash","buildAuthTxHashByGaMetaTx","_ref3","txParams","SignedTx","encodedTx","GaMetaTx"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\contract\\ga.ts"],"sourcesContent":["/**\n * Generalized Account module - routines to use generalized account\n */\n\nimport { ConsensusProtocolVersion, Int, Tag } from '../tx/builder/constants';\nimport {\n  buildContractIdByContractTx, buildTx, buildTxAsync, BuildTxOptions, unpackTx,\n} from '../tx/builder';\nimport { hash } from '../utils/crypto';\nimport {\n  decode, encode, Encoded, Encoding,\n} from '../utils/encoder';\nimport { ArgumentError, IllegalArgumentError } from '../utils/errors';\nimport { concatBuffers } from '../utils/other';\nimport AccountBase from '../account/Base';\nimport Contract from './Contract';\nimport Node from '../Node';\nimport { sendTransaction, SendTransactionOptions, getAccount } from '../chain';\nimport CompilerBase from './compiler/Base';\n\n/**\n * Convert current account to GA\n * @category contract\n * @param authFnName - Authorization function name\n * @param sourceCode - Auth contract source code\n * @param args - init arguments\n * @param options - Options\n * @returns General Account Object\n */\nexport async function createGeneralizedAccount(\n  authFnName: string,\n  args: any[],\n  {\n    onAccount, onCompiler, onNode, bytecode, aci, sourceCodePath, sourceCode, fileSystem, ...options\n  }: CreateGeneralizedAccountOptions,\n): Promise<Readonly<{\n    owner: Encoded.AccountAddress;\n    transaction: Encoded.TxHash;\n    rawTx: Encoded.Transaction;\n    gaContractId: Encoded.ContractAddress;\n  }>> {\n  const ownerId = onAccount.address;\n  if ((await getAccount(ownerId, { onNode })).kind === 'generalized') {\n    throw new IllegalArgumentError(`Account ${ownerId} is already GA`);\n  }\n\n  const contract = await Contract.initialize<{ init: (...a: any[]) => void }>({\n    onAccount, onCompiler, onNode, bytecode, aci, sourceCodePath, sourceCode, fileSystem,\n  });\n\n  const tx = await buildTxAsync({\n    ...options,\n    tag: Tag.GaAttachTx,\n    onNode,\n    code: await contract.$compile(),\n    gasLimit: options.gasLimit ?? await contract._estimateGas('init', args, options),\n    ownerId,\n    callData: contract._calldata.encode(contract._name, 'init', args),\n    authFun: hash(authFnName),\n  });\n  const contractId = buildContractIdByContractTx(tx);\n  const { hash: transaction, rawTx } = await sendTransaction(tx, {\n    onNode, onAccount, onCompiler, ...options,\n  });\n\n  return Object.freeze({\n    owner: ownerId,\n    transaction,\n    rawTx,\n    gaContractId: contractId,\n  });\n}\n\ninterface CreateGeneralizedAccountOptions extends\n  BuildTxOptions<Tag.GaAttachTx, 'authFun' | 'callData' | 'code' | 'ownerId' | 'gasLimit'>,\n  SendTransactionOptions,\n  Pick<\n  Parameters<typeof Contract.initialize>[0],\n  'bytecode' | 'aci' | 'sourceCodePath' | 'sourceCode' | 'fileSystem'\n  > {\n  onAccount: AccountBase;\n  onCompiler: CompilerBase;\n  onNode: Node;\n  gasLimit?: number;\n}\n\n/**\n * Build a transaction hash the same as `Auth.tx_hash` by GaMetaTx payload\n * @category contract\n * @param transaction - tx-encoded transaction\n * @param options - Options\n * @param options.fee - GaMetaTx fee, required in Ceres\n * @param options.gasPrice - GaMetaTx gasPrice, required in Ceres\n * @param options.onNode - Node to use\n * @returns Transaction hash\n */\nexport async function buildAuthTxHash(\n  transaction: Encoded.Transaction,\n  { fee, gasPrice, onNode }: { fee?: Int; gasPrice?: Int; onNode: Node },\n): Promise<Buffer> {\n  const { nodeNetworkId, consensusProtocolVersion } = await onNode.getNodeInfo();\n  let payload = hash(concatBuffers([Buffer.from(nodeNetworkId), decode(transaction)]));\n  if (consensusProtocolVersion === ConsensusProtocolVersion.Ceres) {\n    if (fee == null) throw new ArgumentError('fee', 'provided (in Ceres)', fee);\n    if (gasPrice == null) throw new ArgumentError('gasPrice', 'provided (in Ceres)', gasPrice);\n    payload = hash(decode(buildTx({\n      tag: Tag.GaMetaTxAuthData,\n      fee,\n      gasPrice,\n      txHash: encode(payload, Encoding.TxHash),\n    })));\n  }\n  return payload;\n}\n\n/**\n * Build a transaction hash the same as `Auth.tx_hash` by GaMetaTx\n * @category contract\n * @param transaction - tx-encoded signed GaMeta transaction\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Transaction hash\n */\nexport async function buildAuthTxHashByGaMetaTx(\n  transaction: Encoded.Transaction,\n  { onNode }: { onNode: Node },\n): Promise<Buffer> {\n  const txParams = unpackTx(transaction, Tag.SignedTx);\n  if (txParams.encodedTx.tag !== Tag.GaMetaTx) {\n    throw new ArgumentError('transaction', 'to include GaMetaTx', Tag[txParams.encodedTx.tag]);\n  }\n  return buildAuthTxHash(buildTx(txParams.encodedTx.tx.encodedTx), {\n    fee: txParams.encodedTx.fee,\n    gasPrice: txParams.encodedTx.gasPrice,\n    onNode,\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}