{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\nimport AccountBase from \"./Base.mjs\";\nimport { generateKeyPairFromSecret, sign, generateKeyPair, hash, messageToHash } from \"../utils/crypto.mjs\";\nimport { ArgumentError } from \"../utils/errors.mjs\";\nimport { decode, encode, Encoding } from \"../utils/encoder.mjs\";\nimport { concatBuffers } from \"../utils/other.mjs\";\nimport { hashTypedData } from \"../utils/typed-data.mjs\";\nimport { buildTx } from \"../tx/builder/index.mjs\";\nimport { Tag } from \"../tx/builder/constants.mjs\";\nimport { produceNameId } from \"../tx/builder/helpers.mjs\";\nconst secretKeys = new WeakMap();\nexport function getBufferToSign(transaction, networkId, innerTx) {\n  const prefixes = [networkId];\n  if (innerTx) prefixes.push('inner_tx');\n  const rlpBinaryTx = decode(transaction);\n  return concatBuffers([_Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)]);\n}\n\n/**\n * In-memory account class\n */\nexport default class AccountMemory extends AccountBase {\n  /**\n   * @param secretKey - Secret key\n   */\n  constructor(secretKey) {\n    super();\n    secretKey = typeof secretKey === 'string' ? _Buffer.from(secretKey, 'hex') : secretKey;\n    if (secretKey.length !== 64) {\n      throw new ArgumentError('secretKey', '64 bytes', secretKey.length);\n    }\n    secretKeys.set(this, secretKey);\n    this.address = encode(generateKeyPairFromSecret(secretKeys.get(this)).publicKey, Encoding.AccountAddress);\n  }\n\n  /**\n   * Generates a new AccountMemory using a random secret key\n   */\n  static generate() {\n    return new AccountMemory(generateKeyPair().secretKey);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async sign(data, options) {\n    return sign(data, secretKeys.get(this));\n  }\n  async signTransaction(transaction) {\n    let {\n      innerTx,\n      networkId,\n      ...options\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (networkId == null) {\n      throw new ArgumentError('networkId', 'provided', networkId);\n    }\n    const rlpBinaryTx = decode(transaction);\n    const txWithNetworkId = getBufferToSign(transaction, networkId, innerTx === true);\n    const signatures = [await this.sign(txWithNetworkId, options)];\n    return buildTx({\n      tag: Tag.SignedTx,\n      encodedTx: rlpBinaryTx,\n      signatures\n    });\n  }\n  async signMessage(message, options) {\n    return this.sign(messageToHash(message), options);\n  }\n  async signTypedData(data, aci) {\n    let {\n      name,\n      version,\n      networkId,\n      contractAddress,\n      ...options\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const dHash = hashTypedData(data, aci, {\n      name,\n      version,\n      networkId,\n      contractAddress\n    });\n    const signature = await this.sign(dHash, options);\n    return encode(signature, Encoding.Signature);\n  }\n  async signDelegationToContract(contractAddress) {\n    let {\n      networkId\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);\n    const payload = concatBuffers([_Buffer.from(networkId), decode(this.address), decode(contractAddress)]);\n    const signature = await this.sign(payload);\n    return encode(signature, Encoding.Signature);\n  }\n  async signNameDelegationToContract(contractAddress, name) {\n    let {\n      networkId\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);\n    const payload = concatBuffers([_Buffer.from(networkId), decode(this.address), decode(produceNameId(name)), decode(contractAddress)]);\n    const signature = await this.sign(payload);\n    return encode(signature, Encoding.Signature);\n  }\n  async signOracleQueryDelegationToContract(contractAddress, oracleQueryId) {\n    let {\n      networkId\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const oracleQueryIdDecoded = decode(oracleQueryId);\n    const addressDecoded = decode(this.address);\n    // TODO: remove after fixing https://github.com/aeternity/aesophia/issues/475\n    if (oracleQueryIdDecoded.compare(addressDecoded) === 0) {\n      throw new ArgumentError('oracleQueryId', 'not equal to account address', oracleQueryId);\n    }\n    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);\n    const payload = concatBuffers([_Buffer.from(networkId), oracleQueryIdDecoded, decode(contractAddress)]);\n    const signature = await this.sign(payload);\n    return encode(signature, Encoding.Signature);\n  }\n}","map":{"version":3,"names":["AccountBase","generateKeyPairFromSecret","sign","generateKeyPair","hash","messageToHash","ArgumentError","decode","encode","Encoding","concatBuffers","hashTypedData","buildTx","Tag","produceNameId","secretKeys","WeakMap","getBufferToSign","transaction","networkId","innerTx","prefixes","push","rlpBinaryTx","_Buffer","from","join","AccountMemory","constructor","secretKey","length","set","address","get","publicKey","AccountAddress","generate","data","options","signTransaction","arguments","undefined","txWithNetworkId","signatures","tag","SignedTx","encodedTx","signMessage","message","signTypedData","aci","name","version","contractAddress","dHash","signature","Signature","signDelegationToContract","payload","signNameDelegationToContract","signOracleQueryDelegationToContract","oracleQueryId","oracleQueryIdDecoded","addressDecoded","compare"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\account\\Memory.ts"],"sourcesContent":["import AccountBase from './Base';\nimport {\n  generateKeyPairFromSecret, sign, generateKeyPair, hash, messageToHash,\n} from '../utils/crypto';\nimport { ArgumentError } from '../utils/errors';\nimport {\n  decode, encode, Encoded, Encoding,\n} from '../utils/encoder';\nimport { concatBuffers } from '../utils/other';\nimport { hashTypedData, AciValue } from '../utils/typed-data';\nimport { buildTx } from '../tx/builder';\nimport { Tag, AensName } from '../tx/builder/constants';\nimport { produceNameId } from '../tx/builder/helpers';\n\nconst secretKeys = new WeakMap();\n\nexport function getBufferToSign(\n  transaction: Encoded.Transaction,\n  networkId: string,\n  innerTx: boolean,\n): Uint8Array {\n  const prefixes = [networkId];\n  if (innerTx) prefixes.push('inner_tx');\n  const rlpBinaryTx = decode(transaction);\n  return concatBuffers([Buffer.from(prefixes.join('-')), hash(rlpBinaryTx)]);\n}\n\n/**\n * In-memory account class\n */\nexport default class AccountMemory extends AccountBase {\n  override readonly address: Encoded.AccountAddress;\n\n  /**\n   * @param secretKey - Secret key\n   */\n  constructor(secretKey: string | Uint8Array) {\n    super();\n    secretKey = typeof secretKey === 'string' ? Buffer.from(secretKey, 'hex') : secretKey;\n    if (secretKey.length !== 64) {\n      throw new ArgumentError('secretKey', '64 bytes', secretKey.length);\n    }\n    secretKeys.set(this, secretKey);\n    this.address = encode(\n      generateKeyPairFromSecret(secretKeys.get(this)).publicKey,\n      Encoding.AccountAddress,\n    );\n  }\n\n  /**\n   * Generates a new AccountMemory using a random secret key\n   */\n  static generate(): AccountMemory {\n    return new AccountMemory(generateKeyPair().secretKey);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  override async sign(data: string | Uint8Array, options?: any): Promise<Uint8Array> {\n    return sign(data, secretKeys.get(this));\n  }\n\n  override async signTransaction(\n    transaction: Encoded.Transaction,\n    { innerTx, networkId, ...options }: { innerTx?: boolean; networkId?: string } = {},\n  ): Promise<Encoded.Transaction> {\n    if (networkId == null) {\n      throw new ArgumentError('networkId', 'provided', networkId);\n    }\n    const rlpBinaryTx = decode(transaction);\n    const txWithNetworkId = getBufferToSign(transaction, networkId, innerTx === true);\n\n    const signatures = [await this.sign(txWithNetworkId, options)];\n    return buildTx({ tag: Tag.SignedTx, encodedTx: rlpBinaryTx, signatures });\n  }\n\n  override async signMessage(message: string, options?: any): Promise<Uint8Array> {\n    return this.sign(messageToHash(message), options);\n  }\n\n  override async signTypedData(\n    data: Encoded.ContractBytearray,\n    aci: AciValue,\n    {\n      name, version, networkId, contractAddress, ...options\n    }: Parameters<AccountBase['signTypedData']>[2] = {},\n  ): Promise<Encoded.Signature> {\n    const dHash = hashTypedData(data, aci, {\n      name, version, networkId, contractAddress,\n    });\n    const signature = await this.sign(dHash, options);\n    return encode(signature, Encoding.Signature);\n  }\n\n  override async signDelegationToContract(\n    contractAddress: Encoded.ContractAddress,\n    { networkId }: { networkId?: string } = {},\n  ): Promise<Encoded.Signature> {\n    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);\n    const payload = concatBuffers([\n      Buffer.from(networkId),\n      decode(this.address),\n      decode(contractAddress),\n    ]);\n    const signature = await this.sign(payload);\n    return encode(signature, Encoding.Signature);\n  }\n\n  override async signNameDelegationToContract(\n    contractAddress: Encoded.ContractAddress,\n    name: AensName,\n    { networkId }: { networkId?: string } = {},\n  ): Promise<Encoded.Signature> {\n    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);\n    const payload = concatBuffers([\n      Buffer.from(networkId),\n      decode(this.address),\n      decode(produceNameId(name)),\n      decode(contractAddress),\n    ]);\n    const signature = await this.sign(payload);\n    return encode(signature, Encoding.Signature);\n  }\n\n  override async signOracleQueryDelegationToContract(\n    contractAddress: Encoded.ContractAddress,\n    oracleQueryId: Encoded.OracleQueryId,\n    { networkId }: { networkId?: string } = {},\n  ): Promise<Encoded.Signature> {\n    const oracleQueryIdDecoded = decode(oracleQueryId);\n    const addressDecoded = decode(this.address);\n    // TODO: remove after fixing https://github.com/aeternity/aesophia/issues/475\n    if (oracleQueryIdDecoded.compare(addressDecoded) === 0) {\n      throw new ArgumentError('oracleQueryId', 'not equal to account address', oracleQueryId);\n    }\n    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);\n    const payload = concatBuffers([\n      Buffer.from(networkId),\n      oracleQueryIdDecoded,\n      decode(contractAddress),\n    ]);\n    const signature = await this.sign(payload);\n    return encode(signature, Encoding.Signature);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}