{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\nimport { decode, encode, Encoding } from \"../../../utils/encoder.mjs\";\nimport { Tag } from \"../constants.mjs\";\nimport { ArgumentError } from \"../../../utils/errors.mjs\";\nexport default function genEntryField(tag) {\n  return {\n    serialize(txParams, _ref) {\n      let {\n        buildTx\n      } = _ref;\n      if (ArrayBuffer.isView(txParams)) return _Buffer.from(txParams);\n      if (typeof txParams === 'string' && txParams.startsWith('tx_')) {\n        return decode(txParams);\n      }\n      return decode(buildTx({\n        ...txParams,\n        ...(tag != null && {\n          tag\n        })\n      }));\n    },\n    deserialize(buf, _ref2) {\n      let {\n        unpackTx\n      } = _ref2;\n      const tx = unpackTx(encode(buf, Encoding.Transaction));\n      if (tag != null && tx.tag !== tag) throw new ArgumentError('Tag', Tag[tag], Tag[tx.tag]);\n      return tx;\n    }\n  };\n}","map":{"version":3,"names":["decode","encode","Encoding","Tag","ArgumentError","genEntryField","tag","serialize","txParams","_ref","buildTx","ArrayBuffer","isView","_Buffer","from","startsWith","deserialize","buf","_ref2","unpackTx","tx","Transaction"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\tx\\builder\\field-types\\entry.ts"],"sourcesContent":["import {\n  decode, encode, Encoded, Encoding,\n} from '../../../utils/encoder';\nimport { Tag } from '../constants';\nimport { ArgumentError } from '../../../utils/errors';\nimport type { unpackTx as unpackTxType, buildTx as buildTxType } from '../index';\n\nexport default function genEntryField<T extends Tag = Tag>(tag?: T): {\n  serialize: (\n    // TODO: replace with `TxParams & { tag: T }`,\n    //  but fix TS2502 value is referenced directly or indirectly in its own type annotation\n    value: any,\n    options: { buildTx: typeof buildTxType },\n  ) => Buffer;\n  deserialize: (\n    value: Buffer, options: { unpackTx: typeof unpackTxType },\n    // TODO: replace with `TxUnpacked & { tag: T }`,\n    //  TS2577 Return type annotation circularly references itself\n  ) => any;\n} {\n  return {\n    serialize(txParams, { buildTx }) {\n      if (ArrayBuffer.isView(txParams)) return Buffer.from(txParams as any);\n      if (typeof txParams === 'string' && txParams.startsWith('tx_')) {\n        return decode(txParams as Encoded.Transaction);\n      }\n      return decode(buildTx({ ...txParams, ...tag != null && { tag } }));\n    },\n\n    deserialize(buf, { unpackTx }) {\n      const tx = unpackTx(encode(buf, Encoding.Transaction));\n      if (tag != null && tx.tag !== tag) throw new ArgumentError('Tag', Tag[tag], Tag[tx.tag]);\n      return tx;\n    },\n  };\n}\n"],"mappings":";;;;SACEA,MAAM,EAAEC,MAAM,EAAWC,QAAQ;AAAA,SAE1BC,GAAG;AAAA,SACHC,aAAa;AAGtB,eAAe,SAASC,aAAaA,CAAsBC,GAAO,EAYhE;EACA,OAAO;IACLC,SAASA,CAACC,QAAQ,EAAAC,IAAA,EAAe;MAAA,IAAb;QAAEC;MAAQ,CAAC,GAAAD,IAAA;MAC7B,IAAIE,WAAW,CAACC,MAAM,CAACJ,QAAQ,CAAC,EAAE,OAAOK,OAAA,CAAOC,IAAI,CAACN,QAAe,CAAC;MACrE,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,CAACO,UAAU,CAAC,KAAK,CAAC,EAAE;QAC9D,OAAOf,MAAM,CAACQ,QAA+B,CAAC;MAChD;MACA,OAAOR,MAAM,CAACU,OAAO,CAAC;QAAE,GAAGF,QAAQ;QAAE,IAAGF,GAAG,IAAI,IAAI,IAAI;UAAEA;QAAI,CAAC;MAAC,CAAC,CAAC,CAAC;IACpE,CAAC;IAEDU,WAAWA,CAACC,GAAG,EAAAC,KAAA,EAAgB;MAAA,IAAd;QAAEC;MAAS,CAAC,GAAAD,KAAA;MAC3B,MAAME,EAAE,GAAGD,QAAQ,CAAClB,MAAM,CAACgB,GAAG,EAAEf,QAAQ,CAACmB,WAAW,CAAC,CAAC;MACtD,IAAIf,GAAG,IAAI,IAAI,IAAIc,EAAE,CAACd,GAAG,KAAKA,GAAG,EAAE,MAAM,IAAIF,aAAa,CAAC,KAAK,EAAED,GAAG,CAACG,GAAG,CAAC,EAAEH,GAAG,CAACiB,EAAE,CAACd,GAAG,CAAC,CAAC;MACxF,OAAOc,EAAE;IACX;EACF,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}