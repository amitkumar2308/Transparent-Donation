{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\nimport nacl from 'tweetnacl';\nimport _tweetnaclAuth from 'tweetnacl-auth';\nconst {\n  full: hmac\n} = _tweetnaclAuth;\nimport _bip32Path from 'bip32-path';\nconst {\n  fromString\n} = _bip32Path;\nimport aesjs from 'aes-js';\nimport { sha256hash, encode, Encoding } from \"./encoder.mjs\";\nimport { CryptographyError } from \"./errors.mjs\";\nimport { concatBuffers } from \"./other.mjs\";\nconst Ecb = aesjs.ModeOfOperation.ecb;\n\n// TODO: use mnemonic encryption instead of AES\n/**\n * Encrypt given data using `password`\n * @param password - Password to encrypt with\n * @param binaryData - Data to encrypt\n * @returns Encrypted data\n */\nfunction encryptKey(password, binaryData) {\n  const hashedPasswordBytes = sha256hash(password);\n  const aesEcb = new Ecb(hashedPasswordBytes);\n  return aesEcb.encrypt(binaryData);\n}\n\n/**\n * Decrypt given data using `password`\n * @param password - Password to decrypt with\n * @param encrypted - Data to decrypt\n * @returns Decrypted data\n */\nfunction decryptKey(password, encrypted) {\n  const encryptedBytes = _Buffer.from(encrypted);\n  const hashedPasswordBytes = sha256hash(password);\n  const aesEcb = new Ecb(hashedPasswordBytes);\n  return aesEcb.decrypt(encryptedBytes);\n}\n\n/**\n * @category exception\n */\nexport class DerivationError extends CryptographyError {\n  constructor(message) {\n    super(message);\n    this.name = 'DerivationError';\n  }\n}\nconst ED25519_CURVE = _Buffer.from('ed25519 seed');\nconst HARDENED_OFFSET = 0x80000000;\n/**\n * @category hd-wallet\n */\nexport function deriveChild(_ref, index) {\n  let {\n    secretKey,\n    chainCode\n  } = _ref;\n  if (index < HARDENED_OFFSET) {\n    throw new DerivationError(`Segment ${index} is not hardened`);\n  }\n  const indexBuffer = _Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n  const data = concatBuffers([_Buffer.alloc(1, 0), secretKey, indexBuffer]);\n  const I = hmac(data, chainCode);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    secretKey: IL,\n    chainCode: IR\n  };\n}\n\n/**\n * @category hd-wallet\n */\nexport function derivePathFromKey(path, key) {\n  const segments = path === '' ? [] : fromString(path).toPathArray();\n  segments.forEach((segment, i) => {\n    if (segment < HARDENED_OFFSET) {\n      throw new DerivationError(`Segment #${i + 1} is not hardened`);\n    }\n  });\n  return segments.reduce((parentKey, segment) => deriveChild(parentKey, segment), key);\n}\n\n/**\n * @category hd-wallet\n */\nexport function getMasterKeyFromSeed(seed) {\n  const I = hmac(seed, ED25519_CURVE);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    secretKey: IL,\n    chainCode: IR\n  };\n}\n\n/**\n * @category hd-wallet\n */\nexport function derivePathFromSeed(path, seed) {\n  if (!['m', 'm/'].includes(path.slice(0, 2))) {\n    throw new DerivationError('Root element is required');\n  }\n  const masterKey = getMasterKeyFromSeed(seed);\n  return derivePathFromKey(path.slice(2), masterKey);\n}\nfunction formatAccount(keys) {\n  const {\n    secretKey,\n    publicKey\n  } = keys;\n  return {\n    secretKey: _Buffer.from(secretKey).toString('hex'),\n    publicKey: encode(publicKey, Encoding.AccountAddress)\n  };\n}\n\n/**\n * @category hd-wallet\n */\nexport function getKeyPair(secretKey) {\n  return nacl.sign.keyPair.fromSeed(secretKey);\n}\n\n/**\n * @category hd-wallet\n */\nexport function generateSaveHDWalletFromSeed(seed, password) {\n  const walletKey = derivePathFromSeed('m/44h/457h', seed);\n  return {\n    secretKey: _Buffer.from(encryptKey(password, walletKey.secretKey)).toString('hex'),\n    chainCode: _Buffer.from(encryptKey(password, walletKey.chainCode)).toString('hex')\n  };\n}\n\n/**\n * @category hd-wallet\n */\nexport function getSaveHDWalletAccounts(saveHDWallet, password, accountCount) {\n  const walletKey = {\n    secretKey: decryptKey(password, _Buffer.from(saveHDWallet.secretKey, 'hex')),\n    chainCode: decryptKey(password, _Buffer.from(saveHDWallet.chainCode, 'hex'))\n  };\n  return new Array(accountCount).fill(undefined).map((_, idx) => formatAccount(getKeyPair(derivePathFromKey(`${idx}h/0h/0h`, walletKey).secretKey)));\n}\n\n/**\n * @category hd-wallet\n */\nexport const getHdWalletAccountFromSeed = (seed, accountIdx) => {\n  const walletKey = derivePathFromSeed('m/44h/457h', seed);\n  const derived = derivePathFromKey(`${accountIdx}h/0h/0h`, walletKey);\n  const keyPair = getKeyPair(derived.secretKey);\n  return {\n    ...formatAccount(keyPair),\n    idx: accountIdx\n  };\n};","map":{"version":3,"names":["nacl","_tweetnaclAuth","full","hmac","_bip32Path","fromString","aesjs","sha256hash","encode","Encoding","CryptographyError","concatBuffers","Ecb","ModeOfOperation","ecb","encryptKey","password","binaryData","hashedPasswordBytes","aesEcb","encrypt","decryptKey","encrypted","encryptedBytes","_Buffer","from","decrypt","DerivationError","constructor","message","name","ED25519_CURVE","HARDENED_OFFSET","deriveChild","_ref","index","secretKey","chainCode","indexBuffer","allocUnsafe","writeUInt32BE","data","alloc","I","IL","slice","IR","derivePathFromKey","path","key","segments","toPathArray","forEach","segment","i","reduce","parentKey","getMasterKeyFromSeed","seed","derivePathFromSeed","includes","masterKey","formatAccount","keys","publicKey","toString","AccountAddress","getKeyPair","sign","keyPair","fromSeed","generateSaveHDWalletFromSeed","walletKey","getSaveHDWalletAccounts","saveHDWallet","accountCount","Array","fill","undefined","map","_","idx","getHdWalletAccountFromSeed","accountIdx","derived"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\utils\\hd-wallet.ts"],"sourcesContent":["import nacl from 'tweetnacl';\nimport { full as hmac } from 'tweetnacl-auth';\nimport { fromString } from 'bip32-path';\nimport aesjs from 'aes-js';\nimport { sha256hash, encode, Encoding } from './encoder';\nimport { CryptographyError } from './errors';\nimport { concatBuffers } from './other';\n\nconst Ecb = aesjs.ModeOfOperation.ecb;\n\n// TODO: use mnemonic encryption instead of AES\n/**\n * Encrypt given data using `password`\n * @param password - Password to encrypt with\n * @param binaryData - Data to encrypt\n * @returns Encrypted data\n */\nfunction encryptKey(password: string, binaryData: Uint8Array): Uint8Array {\n  const hashedPasswordBytes = sha256hash(password);\n  const aesEcb = new Ecb(hashedPasswordBytes);\n  return aesEcb.encrypt(binaryData);\n}\n\n/**\n * Decrypt given data using `password`\n * @param password - Password to decrypt with\n * @param encrypted - Data to decrypt\n * @returns Decrypted data\n */\nfunction decryptKey(password: string, encrypted: Uint8Array): Uint8Array {\n  const encryptedBytes = Buffer.from(encrypted);\n  const hashedPasswordBytes = sha256hash(password);\n  const aesEcb = new Ecb(hashedPasswordBytes);\n  return aesEcb.decrypt(encryptedBytes);\n}\n\n/**\n * @category exception\n */\nexport class DerivationError extends CryptographyError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DerivationError';\n  }\n}\n\nconst ED25519_CURVE = Buffer.from('ed25519 seed');\nconst HARDENED_OFFSET = 0x80000000;\n\ninterface KeyTreeNode {\n  secretKey: Uint8Array;\n  chainCode: Uint8Array;\n}\n\ninterface HDWallet {\n  secretKey: string;\n  chainCode: string;\n}\n\ninterface Account {\n  secretKey: string;\n  publicKey: string;\n}\n\ntype Dec<N extends number> = [-1, 0, 1, 2, 3, 4][N];\ntype Bip32PathT<MaxLen extends number, H extends 'H' | 'h' | '\\''> = MaxLen extends -1\n  ? `${number}${H}`\n  : Bip32PathT<Dec<MaxLen>, H> | `${Bip32PathT<Dec<MaxLen>, H>}/${number}${H}`;\ntype Bip32Path<MaxLen extends number> =\n  '' | Bip32PathT<MaxLen, 'H'> | Bip32PathT<MaxLen, 'h'> | Bip32PathT<MaxLen, '\\''>;\n\n/**\n * @category hd-wallet\n */\nexport function deriveChild({ secretKey, chainCode }: KeyTreeNode, index: number): KeyTreeNode {\n  if (index < HARDENED_OFFSET) {\n    throw new DerivationError(`Segment ${index} is not hardened`);\n  }\n  const indexBuffer = Buffer.allocUnsafe(4);\n  indexBuffer.writeUInt32BE(index, 0);\n\n  const data = concatBuffers([Buffer.alloc(1, 0), secretKey, indexBuffer]);\n\n  const I = hmac(data, chainCode);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    secretKey: IL,\n    chainCode: IR,\n  };\n}\n\n/**\n * @category hd-wallet\n */\nexport function derivePathFromKey(path: Bip32Path<5>, key: KeyTreeNode): KeyTreeNode {\n  const segments = path === '' ? [] : fromString(path).toPathArray();\n  segments.forEach((segment, i) => {\n    if (segment < HARDENED_OFFSET) {\n      throw new DerivationError(`Segment #${i + 1} is not hardened`);\n    }\n  });\n\n  return segments.reduce((parentKey, segment) => deriveChild(parentKey, segment), key);\n}\n\n/**\n * @category hd-wallet\n */\nexport function getMasterKeyFromSeed(seed: Uint8Array): KeyTreeNode {\n  const I = hmac(seed, ED25519_CURVE);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    secretKey: IL,\n    chainCode: IR,\n  };\n}\n\n/**\n * @category hd-wallet\n */\nexport function derivePathFromSeed(path: 'm' | `m/${Bip32Path<5>}`, seed: Uint8Array): KeyTreeNode {\n  if (!['m', 'm/'].includes(path.slice(0, 2))) {\n    throw new DerivationError('Root element is required');\n  }\n  const masterKey = getMasterKeyFromSeed(seed);\n  return derivePathFromKey(path.slice(2) as Bip32Path<5>, masterKey);\n}\n\nfunction formatAccount(keys: nacl.SignKeyPair): Account {\n  const { secretKey, publicKey } = keys;\n  return {\n    secretKey: Buffer.from(secretKey).toString('hex'),\n    publicKey: encode(publicKey, Encoding.AccountAddress),\n  };\n}\n\n/**\n * @category hd-wallet\n */\nexport function getKeyPair(secretKey: Uint8Array): nacl.SignKeyPair {\n  return nacl.sign.keyPair.fromSeed(secretKey);\n}\n\n/**\n * @category hd-wallet\n */\nexport function generateSaveHDWalletFromSeed(seed: Uint8Array, password: string): HDWallet {\n  const walletKey = derivePathFromSeed('m/44h/457h', seed);\n  return {\n    secretKey: Buffer.from(encryptKey(password, walletKey.secretKey)).toString('hex'),\n    chainCode: Buffer.from(encryptKey(password, walletKey.chainCode)).toString('hex'),\n  };\n}\n\n/**\n * @category hd-wallet\n */\nexport function getSaveHDWalletAccounts(\n  saveHDWallet: HDWallet,\n  password: string,\n  accountCount: number,\n): Account[] {\n  const walletKey = {\n    secretKey: decryptKey(password, Buffer.from(saveHDWallet.secretKey, 'hex')),\n    chainCode: decryptKey(password, Buffer.from(saveHDWallet.chainCode, 'hex')),\n  };\n  return (new Array(accountCount)).fill(undefined)\n    .map((_, idx) => formatAccount(getKeyPair(derivePathFromKey(`${idx}h/0h/0h`, walletKey).secretKey)));\n}\n\n/**\n * @category hd-wallet\n */\nexport const getHdWalletAccountFromSeed = (\n  seed: Uint8Array,\n  accountIdx: number,\n): Account & { idx: number } => {\n  const walletKey = derivePathFromSeed('m/44h/457h', seed);\n  const derived = derivePathFromKey(`${accountIdx}h/0h/0h`, walletKey);\n  const keyPair = getKeyPair(derived.secretKey);\n  return {\n    ...formatAccount(keyPair),\n    idx: accountIdx,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}