{"ast":null,"code":"import { snakeToPascal } from \"../utils/string.mjs\";\nimport { MIN_GAS_PRICE, Tag } from \"../tx/builder/constants.mjs\";\nimport { signAndNotify, awaitingCompletion, channelClosed, channelOpen, handleUnexpectedMessage } from \"./handlers.mjs\";\nimport { notify, call, changeState, emit } from \"./internal.mjs\";\nimport Channel from \"./Base.mjs\";\nimport ChannelSpend from \"./Spend.mjs\";\nimport { ChannelError, UnexpectedChannelMessageError } from \"../utils/errors.mjs\";\nimport { unpackTx } from \"../tx/builder/index.mjs\";\nimport { encodeContractAddress } from \"../utils/crypto.mjs\";\nfunction snakeToPascalObjKeys(obj) {\n  return Object.entries(obj).reduce((result, _ref) => {\n    let [key, val] = _ref;\n    return {\n      ...result,\n      [snakeToPascal(key)]: val\n    };\n  }, {});\n}\nexport default class ChannelContract extends ChannelSpend {\n  static async initialize(options) {\n    return Channel._initialize(new ChannelContract(), options);\n  }\n\n  /**\n   * Trigger create contract update\n   *\n   * The create contract update is creating a contract inside the channel's internal state tree.\n   * The update is a change to be applied on top of the latest state.\n   *\n   * That would create a contract with the poster being the owner of it. Poster commits initially\n   * a deposit amount of coins to the new contract.\n   *\n   * @param options - Options\n   * @param options.code - Api encoded compiled AEVM byte code\n   * @param options.callData - Api encoded compiled AEVM call data for the code\n   * @param options.deposit - Initial amount the owner of the contract commits to it\n   * @param options.vmVersion - Version of the Virtual Machine\n   * @param options.abiVersion - Version of the Application Binary Interface\n   * @param sign - Function which verifies and signs create contract transaction\n   * @example\n   * ```js\n   * channel.createContract({\n   *   code: 'cb_HKtpipK4aCgYb17wZ...',\n   *   callData: 'cb_1111111111111111...',\n   *   deposit: 10,\n   *   vmVersion: 3,\n   *   abiVersion: 1\n   * }).then(({ accepted, signedTx, address }) => {\n   *   if (accepted) {\n   *     console.log('New contract has been created')\n   *     console.log('Contract address:', address)\n   *   } else {\n   *     console.log('New contract has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async createContract(_ref2, sign) {\n    let {\n      code,\n      callData,\n      deposit,\n      vmVersion,\n      abiVersion\n    } = _ref2;\n    return this.enqueueAction(() => {\n      notify(this, 'channels.update.new_contract', {\n        code,\n        call_data: callData,\n        deposit,\n        vm_version: vmVersion,\n        abi_version: abiVersion\n      });\n      return {\n        handler: async (_, message, state) => {\n          if (message.method !== 'channels.sign.update') {\n            return handleUnexpectedMessage(this, message, state);\n          }\n          await signAndNotify(this, 'channels.update', message.params.data, async tx => state.sign(tx));\n          return {\n            handler: (_2, message2, state2) => awaitingCompletion(this, message2, state2, () => {\n              const params = unpackTx(message2.params.data.state, Tag.SignedTx).encodedTx;\n              if (params.tag !== Tag.ChannelOffChainTx) {\n                throw new ChannelError(`Tag should be ${Tag[Tag.ChannelOffChainTx]}, got ${Tag[params.tag]} instead`);\n              }\n              const addressKey = this._options.role === 'initiator' ? 'initiatorId' : 'responderId';\n              const owner = this._options[addressKey];\n              changeState(this, message2.params.data.state);\n              const address = encodeContractAddress(owner, params.round);\n              emit(this, 'newContract', address);\n              state2.resolve({\n                accepted: true,\n                address,\n                signedTx: message2.params.data.state\n              });\n              return {\n                handler: channelOpen\n              };\n            }),\n            state\n          };\n        },\n        state: {\n          sign\n        }\n      };\n    });\n  }\n\n  /**\n   * Trigger call a contract update\n   *\n   * The call contract update is calling a preexisting contract inside the channel's\n   * internal state tree. The update is a change to be applied on top of the latest state.\n   *\n   * That would call a contract with the poster being the caller of it. Poster commits\n   * an amount of coins to the contract.\n   *\n   * The call would also create a call object inside the channel state tree. It contains\n   * the result of the contract call.\n   *\n   * It is worth mentioning that the gas is not consumed, because this is an off-chain\n   * contract call. It would be consumed if it were an on-chain one. This could happen\n   * if a call with a similar computation amount is to be forced on-chain.\n   *\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @param sign - Function which verifies and signs contract call transaction\n   * @example\n   * ```js\n   * channel.callContract({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1\n   * }).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Contract called succesfully')\n   *   } else {\n   *     console.log('Contract call has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async callContract(_ref3, sign) {\n    let {\n      amount,\n      callData,\n      contract,\n      abiVersion\n    } = _ref3;\n    return this.enqueueAction(() => {\n      notify(this, 'channels.update.call_contract', {\n        amount,\n        call_data: callData,\n        contract_id: contract,\n        abi_version: abiVersion\n      });\n      return {\n        handler: async (_, message, state) => {\n          if (message.method !== 'channels.sign.update') {\n            return handleUnexpectedMessage(this, message, state);\n          }\n          await signAndNotify(this, 'channels.update', message.params.data, async tx => state.sign(tx, {\n            updates: message.params.data.updates\n          }));\n          return {\n            handler: (_2, message2, state2) => awaitingCompletion(this, message2, state2, () => {\n              changeState(this, message2.params.data.state);\n              state2.resolve({\n                accepted: true,\n                signedTx: message2.params.data.state\n              });\n              return {\n                handler: channelOpen\n              };\n            }),\n            state\n          };\n        },\n        state: {\n          sign\n        }\n      };\n    });\n  }\n\n  /**\n   * Trigger a force progress contract call\n   * This call is going on-chain\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @param options.gasPrice=1000000000]\n   * @param options.gasLimit=1000000]\n   * @param sign - Function which verifies and signs contract force progress transaction\n   * @param callbacks - Callbacks\n   * @example\n   * ```js\n   * channel.forceProgress({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1,\n   *   gasPrice: 1000005554\n   * }).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Contract force progress call successful')\n   *   } else {\n   *     console.log('Contract force progress call has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async forceProgress(_ref4, sign) {\n    let {\n      amount,\n      callData,\n      contract,\n      abiVersion,\n      gasLimit = 1000000,\n      gasPrice = MIN_GAS_PRICE\n    } = _ref4;\n    let {\n      onOnChainTx\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.enqueueAction(() => {\n      notify(this, 'channels.force_progress', {\n        amount,\n        call_data: callData,\n        contract_id: contract,\n        abi_version: abiVersion,\n        gas_price: gasPrice,\n        gas: gasLimit\n      });\n      return {\n        handler: async (_, message, state) => {\n          if (message.method !== 'channels.sign.force_progress_tx') {\n            return handleUnexpectedMessage(this, message, state);\n          }\n          await signAndNotify(this, 'channels.force_progress_sign', message.params.data, async tx => state.sign(tx, {\n            updates: message.params.data.updates\n          }));\n          return {\n            handler: (_2, message2, state2) => {\n              if (message2.method === 'channels.on_chain_tx') {\n                var _state2$onOnChainTx;\n                (_state2$onOnChainTx = state2.onOnChainTx) === null || _state2$onOnChainTx === void 0 ? void 0 : _state2$onOnChainTx.call(state2, message2.params.data.tx);\n                emit(this, 'onChainTx', message2.params.data.tx, {\n                  info: message2.params.data.info,\n                  type: message2.params.data.type\n                });\n                state2.resolve({\n                  accepted: true,\n                  tx: message2.params.data.tx\n                });\n                // TODO: shouldn't be unexpected message in this case\n              }\n              return handleUnexpectedMessage(this, message2, state2);\n            },\n            state\n          };\n        },\n        state: {\n          sign,\n          onOnChainTx\n        }\n      };\n    });\n  }\n\n  /**\n   * Call contract using dry-run\n   *\n   * In order to get the result of a potential contract call, one might need to\n   * dry-run a contract call. It takes the exact same arguments as a call would\n   * and returns the call object.\n   *\n   * The call is executed in the channel's state, but it does not impact the state\n   * whatsoever. It uses as an environment the latest channel's state and the current\n   * top of the blockchain as seen by the node.\n   *\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @example\n   * ```js\n   * channel.callContractStatic({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1\n   * }).then(({ returnValue, gasUsed }) => {\n   *   console.log('Returned value:', returnValue)\n   *   console.log('Gas used:', gasUsed)\n   * })\n   * ```\n   */\n  async callContractStatic(_ref5) {\n    let {\n      amount,\n      callData,\n      contract,\n      abiVersion\n    } = _ref5;\n    return snakeToPascalObjKeys(await call(this, 'channels.dry_run.call_contract', {\n      amount,\n      call_data: callData,\n      contract_id: contract,\n      abi_version: abiVersion\n    }));\n  }\n\n  /**\n   * Get contract call result\n   *\n   * The combination of a caller, contract and a round of execution determines the\n   * contract call. Providing an incorrect set of those results in an error response.\n   *\n   * @param options - Options\n   * @param options.caller - Address of contract caller\n   * @param options.contract - Address of the contract\n   * @param options.round - Round when contract was called\n   * @example\n   * ```js\n   * channel.getContractCall({\n   *   caller: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   round: 3\n   * }).then(({ returnType, returnValue }) => {\n   *   if (returnType === 'ok') console.log(returnValue)\n   * })\n   * ```\n   */\n  async getContractCall(_ref6) {\n    let {\n      caller,\n      contract,\n      round\n    } = _ref6;\n    return snakeToPascalObjKeys(await call(this, 'channels.get.contract_call', {\n      caller_id: caller,\n      contract_id: contract,\n      round\n    }));\n  }\n\n  /**\n   * Get the latest contract state\n   *\n   * @param contract - Address of the contract\n   * @example\n   * ```js\n   * channel.getContractState(\n   *   'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa'\n   * ).then(({ contract }) => {\n   *   console.log('deposit:', contract.deposit)\n   * })\n   * ```\n   */\n  async getContractState(contract) {\n    const result = await call(this, 'channels.get.contract', {\n      pubkey: contract\n    });\n    return snakeToPascalObjKeys({\n      ...result,\n      contract: snakeToPascalObjKeys(result.contract)\n    });\n  }\n\n  /**\n   * Clean up all locally stored contract calls\n   *\n   * Contract calls are kept locally in order for the participant to be able to look them up.\n   * They consume memory and in order for the participant to free it - one can prune all messages.\n   * This cleans up all locally stored contract calls and those will no longer be available for\n   * fetching and inspection.\n   */\n  async cleanContractCalls() {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.clean_contract_calls');\n      return {\n        handler(_, message, state) {\n          if (message.method === 'channels.calls_pruned.reply') {\n            state.resolve();\n            return {\n              handler: channelOpen\n            };\n          }\n          state.reject(new UnexpectedChannelMessageError('Unexpected message received'));\n          return {\n            handler: channelClosed\n          };\n        }\n      };\n    });\n  }\n}","map":{"version":3,"names":["snakeToPascal","MIN_GAS_PRICE","Tag","signAndNotify","awaitingCompletion","channelClosed","channelOpen","handleUnexpectedMessage","notify","call","changeState","emit","Channel","ChannelSpend","ChannelError","UnexpectedChannelMessageError","unpackTx","encodeContractAddress","snakeToPascalObjKeys","obj","Object","entries","reduce","result","_ref","key","val","ChannelContract","initialize","options","_initialize","createContract","_ref2","sign","code","callData","deposit","vmVersion","abiVersion","enqueueAction","call_data","vm_version","abi_version","handler","_","message","state","method","params","data","tx","_2","message2","state2","SignedTx","encodedTx","tag","ChannelOffChainTx","addressKey","_options","role","owner","address","round","resolve","accepted","signedTx","callContract","_ref3","amount","contract","contract_id","updates","forceProgress","_ref4","gasLimit","gasPrice","onOnChainTx","arguments","length","undefined","gas_price","gas","_state2$onOnChainTx","info","type","callContractStatic","_ref5","getContractCall","_ref6","caller","caller_id","getContractState","pubkey","cleanContractCalls","reject"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\channel\\Contract.ts"],"sourcesContent":["import BigNumber from 'bignumber.js';\nimport { snakeToPascal } from '../utils/string';\nimport {\n  MIN_GAS_PRICE, Tag, AbiVersion, VmVersion,\n} from '../tx/builder/constants';\nimport {\n  signAndNotify,\n  awaitingCompletion,\n  channelClosed,\n  channelOpen,\n  handleUnexpectedMessage,\n} from './handlers';\nimport {\n  notify, call, SignTx, ChannelState, ChannelOptions, ChannelMessage, ChannelFsm, changeState, emit,\n} from './internal';\nimport { Encoded } from '../utils/encoder';\nimport { ContractCallReturnType } from '../apis/node';\nimport { ContractCallObject } from '../contract/Contract';\nimport Channel from './Base';\nimport ChannelSpend from './Spend';\nimport { ChannelError, UnexpectedChannelMessageError } from '../utils/errors';\nimport { unpackTx } from '../tx/builder';\nimport { encodeContractAddress } from '../utils/crypto';\n\nfunction snakeToPascalObjKeys<Type>(obj: object): Type {\n  return Object.entries(obj).reduce((result, [key, val]) => ({\n    ...result,\n    [snakeToPascal(key)]: val,\n  }), {}) as Type;\n}\n\ninterface CallContractOptions {\n  amount?: number | BigNumber;\n  callData?: Encoded.ContractBytearray;\n  abiVersion?: AbiVersion;\n  contract?: Encoded.ContractAddress;\n  returnValue?: any;\n  gasUsed?: number | BigNumber;\n  gasPrice?: number | BigNumber;\n  height?: number;\n  callerNonce?: number;\n  log?: any;\n  returnType?: ContractCallReturnType;\n}\n\ninterface Contract {\n  abiVersion: AbiVersion;\n  active: boolean;\n  deposit: number | BigNumber;\n  id: string;\n  ownerId: string;\n  referrerIds: string[];\n  vmVersion: VmVersion;\n}\n\nexport default class ChannelContract extends ChannelSpend {\n  static override async initialize(options: ChannelOptions): Promise<ChannelContract> {\n    return Channel._initialize(new ChannelContract(), options);\n  }\n\n  /**\n   * Trigger create contract update\n   *\n   * The create contract update is creating a contract inside the channel's internal state tree.\n   * The update is a change to be applied on top of the latest state.\n   *\n   * That would create a contract with the poster being the owner of it. Poster commits initially\n   * a deposit amount of coins to the new contract.\n   *\n   * @param options - Options\n   * @param options.code - Api encoded compiled AEVM byte code\n   * @param options.callData - Api encoded compiled AEVM call data for the code\n   * @param options.deposit - Initial amount the owner of the contract commits to it\n   * @param options.vmVersion - Version of the Virtual Machine\n   * @param options.abiVersion - Version of the Application Binary Interface\n   * @param sign - Function which verifies and signs create contract transaction\n   * @example\n   * ```js\n   * channel.createContract({\n   *   code: 'cb_HKtpipK4aCgYb17wZ...',\n   *   callData: 'cb_1111111111111111...',\n   *   deposit: 10,\n   *   vmVersion: 3,\n   *   abiVersion: 1\n   * }).then(({ accepted, signedTx, address }) => {\n   *   if (accepted) {\n   *     console.log('New contract has been created')\n   *     console.log('Contract address:', address)\n   *   } else {\n   *     console.log('New contract has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async createContract(\n    {\n      code, callData, deposit, vmVersion, abiVersion,\n    }: {\n      code: Encoded.ContractBytearray;\n      callData: Encoded.ContractBytearray;\n      deposit: number | BigNumber;\n      vmVersion: VmVersion;\n      abiVersion: AbiVersion;\n    },\n    sign: SignTx,\n  ): Promise<{\n      accepted: boolean; signedTx: Encoded.Transaction; address: Encoded.ContractAddress;\n    }> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.update.new_contract', {\n        code,\n        call_data: callData,\n        deposit,\n        vm_version: vmVersion,\n        abi_version: abiVersion,\n      });\n      return {\n        handler: async (\n          _: Channel,\n          message: ChannelMessage,\n          state: ChannelState,\n        ): Promise<ChannelFsm> => {\n          if (message.method !== 'channels.sign.update') {\n            return handleUnexpectedMessage(this, message, state);\n          }\n          await signAndNotify(\n            this,\n            'channels.update',\n            message.params.data,\n            async (tx) => state.sign(tx),\n          );\n          return {\n            handler: (\n              _2: Channel,\n              message2: ChannelMessage,\n              state2: ChannelState,\n            ): ChannelFsm => (\n              awaitingCompletion(this, message2, state2, () => {\n                const params = unpackTx(message2.params.data.state, Tag.SignedTx).encodedTx;\n                if (params.tag !== Tag.ChannelOffChainTx) {\n                  throw new ChannelError(`Tag should be ${Tag[Tag.ChannelOffChainTx]}, got ${Tag[params.tag]} instead`);\n                }\n                const addressKey = this._options.role === 'initiator'\n                  ? 'initiatorId' : 'responderId';\n                const owner = this._options[addressKey];\n                changeState(this, message2.params.data.state);\n                const address = encodeContractAddress(owner, params.round);\n                emit(this, 'newContract', address);\n                state2.resolve({ accepted: true, address, signedTx: message2.params.data.state });\n                return { handler: channelOpen };\n              })\n            ),\n            state,\n          };\n        },\n        state: { sign },\n      };\n    });\n  }\n\n  /**\n   * Trigger call a contract update\n   *\n   * The call contract update is calling a preexisting contract inside the channel's\n   * internal state tree. The update is a change to be applied on top of the latest state.\n   *\n   * That would call a contract with the poster being the caller of it. Poster commits\n   * an amount of coins to the contract.\n   *\n   * The call would also create a call object inside the channel state tree. It contains\n   * the result of the contract call.\n   *\n   * It is worth mentioning that the gas is not consumed, because this is an off-chain\n   * contract call. It would be consumed if it were an on-chain one. This could happen\n   * if a call with a similar computation amount is to be forced on-chain.\n   *\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @param sign - Function which verifies and signs contract call transaction\n   * @example\n   * ```js\n   * channel.callContract({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1\n   * }).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Contract called succesfully')\n   *   } else {\n   *     console.log('Contract call has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async callContract(\n    {\n      amount, callData, contract, abiVersion,\n    }: CallContractOptions,\n    sign: SignTx,\n  ): Promise<{ accepted: boolean; signedTx: Encoded.Transaction }> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.update.call_contract', {\n        amount,\n        call_data: callData,\n        contract_id: contract,\n        abi_version: abiVersion,\n      });\n      return {\n        handler: async (\n          _: Channel,\n          message: ChannelMessage,\n          state: ChannelState,\n        ): Promise<ChannelFsm> => {\n          if (message.method !== 'channels.sign.update') {\n            return handleUnexpectedMessage(this, message, state);\n          }\n          await signAndNotify(\n            this,\n            'channels.update',\n            message.params.data,\n            async (tx) => state.sign(tx, { updates: message.params.data.updates }),\n          );\n          return {\n            handler: (\n              _2: Channel,\n              message2: ChannelMessage,\n              state2: ChannelState,\n            ): ChannelFsm => (\n              awaitingCompletion(this, message2, state2, () => {\n                changeState(this, message2.params.data.state);\n                state2.resolve({ accepted: true, signedTx: message2.params.data.state });\n                return { handler: channelOpen };\n              })\n            ),\n            state,\n          };\n        },\n        state: { sign },\n      };\n    });\n  }\n\n  /**\n   * Trigger a force progress contract call\n   * This call is going on-chain\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @param options.gasPrice=1000000000]\n   * @param options.gasLimit=1000000]\n   * @param sign - Function which verifies and signs contract force progress transaction\n   * @param callbacks - Callbacks\n   * @example\n   * ```js\n   * channel.forceProgress({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1,\n   *   gasPrice: 1000005554\n   * }).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Contract force progress call successful')\n   *   } else {\n   *     console.log('Contract force progress call has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async forceProgress(\n    {\n      amount, callData, contract, abiVersion, gasLimit = 1000000, gasPrice = MIN_GAS_PRICE,\n    }: {\n      amount: number;\n      callData: Encoded.ContractBytearray;\n      contract: Encoded.ContractAddress;\n      abiVersion: AbiVersion;\n      gasLimit?: number;\n      gasPrice?: number;\n    },\n    sign: SignTx,\n    { onOnChainTx }: Pick<ChannelState, 'onOnChainTx'> = {},\n  ): Promise<{\n      accepted: boolean;\n      signedTx: Encoded.Transaction;\n      tx: Encoded.Transaction | Uint8Array;\n    }> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.force_progress', {\n        amount,\n        call_data: callData,\n        contract_id: contract,\n        abi_version: abiVersion,\n        gas_price: gasPrice,\n        gas: gasLimit,\n      });\n      return {\n        handler: async (\n          _: Channel,\n          message: ChannelMessage,\n          state: ChannelState,\n        ): Promise<ChannelFsm> => {\n          if (message.method !== 'channels.sign.force_progress_tx') {\n            return handleUnexpectedMessage(this, message, state);\n          }\n          await signAndNotify(\n            this,\n            'channels.force_progress_sign',\n            message.params.data,\n            async (tx) => state.sign(tx, { updates: message.params.data.updates }),\n          );\n          return {\n            handler: (\n              _2: Channel,\n              message2: ChannelMessage,\n              state2: ChannelState,\n            ): ChannelFsm => {\n              if (message2.method === 'channels.on_chain_tx') {\n                state2.onOnChainTx?.(message2.params.data.tx);\n                emit(this, 'onChainTx', message2.params.data.tx, {\n                  info: message2.params.data.info,\n                  type: message2.params.data.type,\n                });\n                state2.resolve({ accepted: true, tx: message2.params.data.tx });\n                // TODO: shouldn't be unexpected message in this case\n              }\n              return handleUnexpectedMessage(this, message2, state2);\n            },\n            state,\n          };\n        },\n        state: { sign, onOnChainTx },\n      };\n    });\n  }\n\n  /**\n   * Call contract using dry-run\n   *\n   * In order to get the result of a potential contract call, one might need to\n   * dry-run a contract call. It takes the exact same arguments as a call would\n   * and returns the call object.\n   *\n   * The call is executed in the channel's state, but it does not impact the state\n   * whatsoever. It uses as an environment the latest channel's state and the current\n   * top of the blockchain as seen by the node.\n   *\n   * @param options - Options\n   * @param options.amount - Amount the caller of the contract commits to it\n   * @param options.callData - ABI encoded compiled AEVM call data for the code\n   * @param options.contract - Address of the contract to call\n   * @param options.abiVersion - Version of the ABI\n   * @example\n   * ```js\n   * channel.callContractStatic({\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   callData: 'cb_1111111111111111...',\n   *   amount: 0,\n   *   abiVersion: 1\n   * }).then(({ returnValue, gasUsed }) => {\n   *   console.log('Returned value:', returnValue)\n   *   console.log('Gas used:', gasUsed)\n   * })\n   * ```\n   */\n  async callContractStatic(\n    {\n      amount, callData, contract, abiVersion,\n    }: {\n      amount: number;\n      callData: Encoded.ContractBytearray;\n      contract: Encoded.ContractAddress;\n      abiVersion: AbiVersion;\n    },\n  ): Promise<CallContractOptions> {\n    return snakeToPascalObjKeys(await call(this, 'channels.dry_run.call_contract', {\n      amount,\n      call_data: callData,\n      contract_id: contract,\n      abi_version: abiVersion,\n    }));\n  }\n\n  /**\n   * Get contract call result\n   *\n   * The combination of a caller, contract and a round of execution determines the\n   * contract call. Providing an incorrect set of those results in an error response.\n   *\n   * @param options - Options\n   * @param options.caller - Address of contract caller\n   * @param options.contract - Address of the contract\n   * @param options.round - Round when contract was called\n   * @example\n   * ```js\n   * channel.getContractCall({\n   *   caller: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   contract: 'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa',\n   *   round: 3\n   * }).then(({ returnType, returnValue }) => {\n   *   if (returnType === 'ok') console.log(returnValue)\n   * })\n   * ```\n   */\n  async getContractCall(\n    { caller, contract, round }: {\n      caller: Encoded.AccountAddress;\n      contract: Encoded.ContractAddress;\n      round: number;\n    },\n  ): Promise<ContractCallObject> {\n    return snakeToPascalObjKeys(\n      await call(this, 'channels.get.contract_call', {\n        caller_id: caller,\n        contract_id: contract,\n        round,\n      }),\n    );\n  }\n\n  /**\n   * Get the latest contract state\n   *\n   * @param contract - Address of the contract\n   * @example\n   * ```js\n   * channel.getContractState(\n   *   'ct_9sRA9AVE4BYTAkh5RNfJYmwQe1NZ4MErasQLXZkFWG43TPBqa'\n   * ).then(({ contract }) => {\n   *   console.log('deposit:', contract.deposit)\n   * })\n   * ```\n   */\n  async getContractState(\n    contract: Encoded.ContractAddress,\n  ): Promise<{ contract: Contract; contractState: object }> {\n    const result = await call(this, 'channels.get.contract', { pubkey: contract });\n    return snakeToPascalObjKeys({\n      ...result,\n      contract: snakeToPascalObjKeys(result.contract),\n    });\n  }\n\n  /**\n   * Clean up all locally stored contract calls\n   *\n   * Contract calls are kept locally in order for the participant to be able to look them up.\n   * They consume memory and in order for the participant to free it - one can prune all messages.\n   * This cleans up all locally stored contract calls and those will no longer be available for\n   * fetching and inspection.\n   */\n  async cleanContractCalls(): Promise<void> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.clean_contract_calls');\n      return {\n        handler(_: Channel, message: ChannelMessage, state: ChannelState): ChannelFsm {\n          if (message.method === 'channels.calls_pruned.reply') {\n            state.resolve();\n            return { handler: channelOpen };\n          }\n          state.reject(new UnexpectedChannelMessageError('Unexpected message received'));\n          return { handler: channelClosed };\n        },\n      };\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}