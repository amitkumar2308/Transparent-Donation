{"ast":null,"code":"import _classPrivateFieldGet from \"@babel/runtime-corejs3/helpers/classPrivateFieldGet\";\nimport _classPrivateFieldSet from \"@babel/runtime-corejs3/helpers/classPrivateFieldSet\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nimport BrowserConnection from \"./Browser.mjs\";\nimport { MESSAGE_DIRECTION } from \"../schema.mjs\";\nimport { InternalError, RpcConnectionError } from \"../../utils/errors.mjs\";\nvar _onDisconnect = /*#__PURE__*/new WeakMap();\nvar _target = /*#__PURE__*/new WeakMap();\nvar _self = /*#__PURE__*/new WeakMap();\n/**\n * Browser window Post Message connector module\n * @category aepp wallet communication\n */\nexport default class BrowserWindowMessageConnection extends BrowserConnection {\n  /**\n   * @param options - Options\n   * @param options.target Target window for message\n   * @param options.self Host window for message\n   * @param options.origin Origin of receiver\n   * @param options.sendDirection Wrapping messages into additional struct\n   * `({ type: 'to_aepp' || 'to_waellet', data })`\n   * Used for handling messages between content script and page\n   * @param options.receiveDirection Unwrapping messages from additional struct\n   */\n  constructor() {\n    let {\n      target,\n      self = window,\n      origin,\n      sendDirection,\n      receiveDirection = MESSAGE_DIRECTION.to_aepp,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(options);\n    _classPrivateFieldInitSpec(this, _onDisconnect, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _target, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldInitSpec(this, _self, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldSet(this, _target, target);\n    _classPrivateFieldSet(this, _self, self);\n    this.origin = origin;\n    this.sendDirection = sendDirection;\n    this.receiveDirection = receiveDirection;\n  }\n  isConnected() {\n    return this.listener != null;\n  }\n  connect(onMessage, onDisconnect) {\n    super.connect(onMessage, onDisconnect);\n    this.listener = message => {\n      var _message$data$jsonrpc, _message$data$data;\n      // TODO: strict validate origin and source instead of checking message structure\n      if (typeof message.data !== 'object' || ((_message$data$jsonrpc = message.data.jsonrpc) !== null && _message$data$jsonrpc !== void 0 ? _message$data$jsonrpc : (_message$data$data = message.data.data) === null || _message$data$data === void 0 ? void 0 : _message$data$data.jsonrpc) !== '2.0') return;\n      if (this.origin != null && this.origin !== message.origin) return;\n      if (_classPrivateFieldGet(this, _target) != null && _classPrivateFieldGet(this, _target) !== message.source) return;\n      this.receiveMessage(message);\n      let {\n        data\n      } = message;\n      if (data.type != null) {\n        if (message.data.type !== this.receiveDirection) return;\n        data = data.data;\n      }\n      onMessage(data, message.origin, message.source);\n    };\n    _classPrivateFieldGet(this, _self).addEventListener('message', this.listener);\n    _classPrivateFieldSet(this, _onDisconnect, onDisconnect);\n  }\n  disconnect() {\n    super.disconnect();\n    if (this.listener == null || _classPrivateFieldGet(this, _onDisconnect) == null) {\n      throw new InternalError('Expected to not happen, required for TS');\n    }\n    _classPrivateFieldGet(this, _self).removeEventListener('message', this.listener);\n    delete this.listener;\n    _classPrivateFieldGet(this, _onDisconnect).call(this);\n    _classPrivateFieldSet(this, _onDisconnect, undefined);\n  }\n  sendMessage(msg) {\n    var _this$origin;\n    if (_classPrivateFieldGet(this, _target) == null) throw new RpcConnectionError('Can\\'t send messages without target');\n    const message = this.sendDirection != null ? {\n      type: this.sendDirection,\n      data: msg\n    } : msg;\n    super.sendMessage(message);\n    _classPrivateFieldGet(this, _target).postMessage(message, (_this$origin = this.origin) !== null && _this$origin !== void 0 ? _this$origin : '*');\n  }\n}","map":{"version":3,"names":["BrowserConnection","MESSAGE_DIRECTION","InternalError","RpcConnectionError","_onDisconnect","WeakMap","_target","_self","BrowserWindowMessageConnection","constructor","target","self","window","origin","sendDirection","receiveDirection","to_aepp","options","arguments","length","undefined","_classPrivateFieldInitSpec","writable","value","_classPrivateFieldSet","isConnected","listener","connect","onMessage","onDisconnect","message","_message$data$jsonrpc","_message$data$data","data","jsonrpc","_classPrivateFieldGet","source","receiveMessage","type","addEventListener","disconnect","removeEventListener","call","sendMessage","msg","_this$origin","postMessage"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\aepp-wallet-communication\\connection\\BrowserWindowMessage.ts"],"sourcesContent":["import BrowserConnection from './Browser';\nimport { MESSAGE_DIRECTION } from '../schema';\nimport { InternalError, RpcConnectionError } from '../../utils/errors';\n\nexport type ImplPostMessage = Pick<Window, 'addEventListener' | 'removeEventListener' | 'postMessage'>;\n\n/**\n * Browser window Post Message connector module\n * @category aepp wallet communication\n */\nexport default class BrowserWindowMessageConnection extends BrowserConnection {\n  origin?: string;\n\n  sendDirection?: MESSAGE_DIRECTION;\n\n  receiveDirection: MESSAGE_DIRECTION;\n\n  listener?: (this: Window, ev: MessageEvent<any>) => void;\n\n  #onDisconnect?: () => void;\n\n  #target?: ImplPostMessage;\n\n  #self: ImplPostMessage;\n\n  /**\n   * @param options - Options\n   * @param options.target Target window for message\n   * @param options.self Host window for message\n   * @param options.origin Origin of receiver\n   * @param options.sendDirection Wrapping messages into additional struct\n   * `({ type: 'to_aepp' || 'to_waellet', data })`\n   * Used for handling messages between content script and page\n   * @param options.receiveDirection Unwrapping messages from additional struct\n   */\n  constructor({\n    target,\n    self = window,\n    origin,\n    sendDirection,\n    receiveDirection = MESSAGE_DIRECTION.to_aepp,\n    ...options\n  }: {\n    target?: ImplPostMessage;\n    self?: ImplPostMessage;\n    origin?: string;\n    sendDirection?: MESSAGE_DIRECTION;\n    receiveDirection?: MESSAGE_DIRECTION;\n    debug?: boolean;\n  } = {}) {\n    super(options);\n    this.#target = target;\n    this.#self = self;\n    this.origin = origin;\n    this.sendDirection = sendDirection;\n    this.receiveDirection = receiveDirection;\n  }\n\n  isConnected(): boolean {\n    return this.listener != null;\n  }\n\n  override connect(\n    onMessage: (message: any, origin: string, source: MessageEventSource | null) => void,\n    onDisconnect: () => void,\n  ): void {\n    super.connect(onMessage, onDisconnect);\n    this.listener = (message: MessageEvent<any>) => {\n      // TODO: strict validate origin and source instead of checking message structure\n      if (\n        typeof message.data !== 'object'\n        || (message.data.jsonrpc ?? message.data.data?.jsonrpc) !== '2.0'\n      ) return;\n      if (this.origin != null && this.origin !== message.origin) return;\n      if (this.#target != null && this.#target !== message.source) return;\n      this.receiveMessage(message);\n      let { data } = message;\n      if (data.type != null) {\n        if (message.data.type !== this.receiveDirection) return;\n        data = data.data;\n      }\n      onMessage(data, message.origin, message.source);\n    };\n    this.#self.addEventListener('message', this.listener);\n    this.#onDisconnect = onDisconnect;\n  }\n\n  override disconnect(): void {\n    super.disconnect();\n    if (this.listener == null || this.#onDisconnect == null) {\n      throw new InternalError('Expected to not happen, required for TS');\n    }\n    this.#self.removeEventListener('message', this.listener);\n    delete this.listener;\n    this.#onDisconnect();\n    this.#onDisconnect = undefined;\n  }\n\n  override sendMessage(msg: any): void {\n    if (this.#target == null) throw new RpcConnectionError('Can\\'t send messages without target');\n    const message = this.sendDirection != null ? { type: this.sendDirection, data: msg } : msg;\n    super.sendMessage(message);\n    this.#target.postMessage(message, this.origin ?? '*');\n  }\n}\n"],"mappings":";;;;;;;;;;;OAAOA,iBAAiB;AAAA,SACfC,iBAAiB;AAAA,SACjBC,aAAa,EAAEC,kBAAkB;AAAA,IAAAC,aAAA,oBAAAC,OAAA;AAAA,IAAAC,OAAA,oBAAAD,OAAA;AAAA,IAAAE,KAAA,oBAAAF,OAAA;AAI1C;AACA;AACA;AACA;AACA,eAAe,MAAMG,8BAA8B,SAASR,iBAAiB,CAAC;EAe5E;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,WAAWA,CAAA,EAcH;IAAA,IAdI;MACVC,MAAM;MACNC,IAAI,GAAGC,MAAM;MACbC,MAAM;MACNC,aAAa;MACbC,gBAAgB,GAAGd,iBAAiB,CAACe,OAAO;MAC5C,GAAGC;IAQL,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IACJ,KAAK,CAACD,OAAO,CAAC;IAACI,0BAAA,OAAAjB,aAAA;MAAAkB,QAAA;MAAAC,KAAA;IAAA;IAAAF,0BAAA,OAAAf,OAAA;MAAAgB,QAAA;MAAAC,KAAA;IAAA;IAAAF,0BAAA,OAAAd,KAAA;MAAAe,QAAA;MAAAC,KAAA;IAAA;IACfC,qBAAA,KAAI,EAAAlB,OAAA,EAAWI,MAAM;IACrBc,qBAAA,KAAI,EAAAjB,KAAA,EAASI,IAAI;IACjB,IAAI,CAACE,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,aAAa,GAAGA,aAAa;IAClC,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;EAC1C;EAEAU,WAAWA,CAAA,EAAY;IACrB,OAAO,IAAI,CAACC,QAAQ,IAAI,IAAI;EAC9B;EAESC,OAAOA,CACdC,SAAoF,EACpFC,YAAwB,EAClB;IACN,KAAK,CAACF,OAAO,CAACC,SAAS,EAAEC,YAAY,CAAC;IACtC,IAAI,CAACH,QAAQ,GAAII,OAA0B,IAAK;MAAA,IAAAC,qBAAA,EAAAC,kBAAA;MAC9C;MACA,IACE,OAAOF,OAAO,CAACG,IAAI,KAAK,QAAQ,IAC7B,EAAAF,qBAAA,GAACD,OAAO,CAACG,IAAI,CAACC,OAAO,cAAAH,qBAAA,cAAAA,qBAAA,IAAAC,kBAAA,GAAIF,OAAO,CAACG,IAAI,CAACA,IAAI,cAAAD,kBAAA,uBAAjBA,kBAAA,CAAmBE,OAAO,MAAM,KAAK,EACjE;MACF,IAAI,IAAI,CAACrB,MAAM,IAAI,IAAI,IAAI,IAAI,CAACA,MAAM,KAAKiB,OAAO,CAACjB,MAAM,EAAE;MAC3D,IAAIsB,qBAAA,KAAI,EAAA7B,OAAA,KAAY,IAAI,IAAI6B,qBAAA,KAAI,EAAA7B,OAAA,MAAawB,OAAO,CAACM,MAAM,EAAE;MAC7D,IAAI,CAACC,cAAc,CAACP,OAAO,CAAC;MAC5B,IAAI;QAAEG;MAAK,CAAC,GAAGH,OAAO;MACtB,IAAIG,IAAI,CAACK,IAAI,IAAI,IAAI,EAAE;QACrB,IAAIR,OAAO,CAACG,IAAI,CAACK,IAAI,KAAK,IAAI,CAACvB,gBAAgB,EAAE;QACjDkB,IAAI,GAAGA,IAAI,CAACA,IAAI;MAClB;MACAL,SAAS,CAACK,IAAI,EAAEH,OAAO,CAACjB,MAAM,EAAEiB,OAAO,CAACM,MAAM,CAAC;IACjD,CAAC;IACDD,qBAAA,KAAI,EAAA5B,KAAA,EAAOgC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAACb,QAAQ,CAAC;IACrDF,qBAAA,KAAI,EAAApB,aAAA,EAAiByB,YAAY;EACnC;EAESW,UAAUA,CAAA,EAAS;IAC1B,KAAK,CAACA,UAAU,CAAC,CAAC;IAClB,IAAI,IAAI,CAACd,QAAQ,IAAI,IAAI,IAAIS,qBAAA,KAAI,EAAA/B,aAAA,KAAkB,IAAI,EAAE;MACvD,MAAM,IAAIF,aAAa,CAAC,yCAAyC,CAAC;IACpE;IACAiC,qBAAA,KAAI,EAAA5B,KAAA,EAAOkC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAACf,QAAQ,CAAC;IACxD,OAAO,IAAI,CAACA,QAAQ;IACpBS,qBAAA,KAAI,EAAA/B,aAAA,EAAAsC,IAAA,CAAJ,IAAI;IACJlB,qBAAA,KAAI,EAAApB,aAAA,EAAiBgB,SAAS;EAChC;EAESuB,WAAWA,CAACC,GAAQ,EAAQ;IAAA,IAAAC,YAAA;IACnC,IAAIV,qBAAA,KAAI,EAAA7B,OAAA,KAAY,IAAI,EAAE,MAAM,IAAIH,kBAAkB,CAAC,qCAAqC,CAAC;IAC7F,MAAM2B,OAAO,GAAG,IAAI,CAAChB,aAAa,IAAI,IAAI,GAAG;MAAEwB,IAAI,EAAE,IAAI,CAACxB,aAAa;MAAEmB,IAAI,EAAEW;IAAI,CAAC,GAAGA,GAAG;IAC1F,KAAK,CAACD,WAAW,CAACb,OAAO,CAAC;IAC1BK,qBAAA,KAAI,EAAA7B,OAAA,EAASwC,WAAW,CAAChB,OAAO,GAAAe,YAAA,GAAE,IAAI,CAAChC,MAAM,cAAAgC,YAAA,cAAAA,YAAA,GAAI,GAAG,CAAC;EACvD;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}