{"ast":null,"code":"/**\n * Oracle methods - routines to interact with the æternity oracle system\n *\n * The high-level description of the oracle system is\n * https://github.com/aeternity/protocol/blob/master/ORACLE.md in the protocol\n * repository.\n */\nimport { mapObject, pause } from \"./utils/other.mjs\";\nimport { oracleQueryId } from \"./tx/builder/helpers.mjs\";\nimport { unpackTx, buildTxAsync } from \"./tx/builder/index.mjs\";\nimport { ORACLE_TTL, QUERY_TTL, RESPONSE_TTL } from \"./tx/builder/schema.mjs\";\nimport { Tag } from \"./tx/builder/constants.mjs\";\nimport { RequestTimedOutError } from \"./utils/errors.mjs\";\nimport { decode, encode, Encoding } from \"./utils/encoder.mjs\";\nimport { _getPollInterval, getHeight, sendTransaction } from \"./chain.mjs\";\n/**\n * Poll for oracle queries\n * @category oracle\n * @param oracleId - Oracle public key\n * @param onQuery - OnQuery callback\n * @param options - Options object\n * @param options.interval - Poll interval(default: 5000)\n * @param options.onNode - Node to use\n * @returns Callback to stop polling function\n */\nexport function pollForQueries(oracleId, onQuery, _ref) {\n  var _interval;\n  let {\n    interval,\n    onNode,\n    ...options\n  } = _ref;\n  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);\n  const knownQueryIds = new Set();\n  const checkNewQueries = async () => {\n    var _await$onNode$getOrac;\n    const queries = ((_await$onNode$getOrac = (await onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries) !== null && _await$onNode$getOrac !== void 0 ? _await$onNode$getOrac : []).filter(_ref2 => {\n      let {\n        id\n      } = _ref2;\n      return !knownQueryIds.has(id);\n    });\n    queries.forEach(query => {\n      knownQueryIds.add(query.id);\n      onQuery(query);\n    });\n  };\n  let stopped = false;\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  (async () => {\n    while (!stopped) {\n      // eslint-disable-line no-unmodified-loop-condition\n      // TODO: allow to handle this error somehow\n      await checkNewQueries().catch(console.error);\n      await pause(interval);\n    }\n  })();\n  return () => {\n    stopped = true;\n  };\n}\n\n/**\n * Poll for oracle query response\n * @category oracle\n * @param oracleId - Oracle public key\n * @param queryId - Oracle Query id\n * @param options - Options object\n * @param options.interval - Poll interval\n * @param options.onNode - Node to use\n * @returns OracleQuery object\n */\nexport async function pollForQueryResponse(oracleId, queryId, _ref3) {\n  var _interval2;\n  let {\n    interval,\n    onNode,\n    ...options\n  } = _ref3;\n  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('microblock', options);\n  let height;\n  let ttl;\n  let response;\n  do {\n    ({\n      response,\n      ttl\n    } = await onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId));\n    const responseBuffer = decode(response);\n    if (responseBuffer.length > 0) return responseBuffer.toString();\n    await pause(interval);\n    height = await getHeight({\n      onNode\n    });\n  } while (ttl >= height);\n  throw new RequestTimedOutError(height);\n}\n\n/**\n * Constructor for OracleQuery Object (helper object for using OracleQuery)\n * @category oracle\n * @param oracleId - Oracle public key\n * @param queryId - Oracle Query id\n * @param options - Options\n * @returns OracleQuery object\n */\nexport async function getQueryObject(oracleId, queryId, options) {\n  const record = await options.onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId);\n  return {\n    ...record,\n    decodedQuery: decode(record.query).toString(),\n    decodedResponse: decode(record.response).toString(),\n    respond: async (response, opt) =>\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    respondToQuery(queryId, response, {\n      ...options,\n      ...opt\n    }),\n    pollForResponse: async opt => pollForQueryResponse(oracleId, queryId, {\n      ...options,\n      ...opt\n    })\n  };\n}\n/**\n * Post query to oracle\n * @category oracle\n * @param oracleId - Oracle public key\n * @param query - Oracle query object\n * @param options - Options object\n * @param options.queryTtl - queryTtl Oracle query time to leave\n * @param options.responseTtl - queryFee Oracle query response time to leave\n * @param options.queryFee - queryFee Oracle query fee\n * @param options.fee - fee Transaction fee\n * @param options.ttl - Transaction time to leave\n * @returns Query object\n */\nexport async function postQueryToOracle(oracleId, query, options) {\n  var _options$queryFee;\n  (_options$queryFee = options.queryFee) !== null && _options$queryFee !== void 0 ? _options$queryFee : options.queryFee = (await options.onNode.getOracleByPubkey(oracleId)).queryFee.toString();\n  const senderId = options.onAccount.address;\n  const oracleQueryTx = await buildTxAsync({\n    queryTtlType: QUERY_TTL.type,\n    queryTtlValue: QUERY_TTL.value,\n    responseTtlType: RESPONSE_TTL.type,\n    responseTtlValue: RESPONSE_TTL.value,\n    ...options,\n    tag: Tag.OracleQueryTx,\n    oracleId,\n    senderId,\n    query\n  });\n  const {\n    nonce\n  } = unpackTx(oracleQueryTx, Tag.OracleQueryTx);\n  const queryId = oracleQueryId(senderId, nonce, oracleId);\n  return {\n    ...(await sendTransaction(oracleQueryTx, options)),\n    ...(await getQueryObject(oracleId, queryId, options))\n  };\n}\n/**\n * Extend oracle ttl\n * @category oracle\n * @param options - Options object\n * @param options.fee - fee Transaction fee\n * @param options.ttl - Transaction time to leave\n * @param options.oracleTtlType - Oracle time to leave for extend\n * @param options.oracleTtlValue - Oracle time to leave for extend\n * @returns Oracle object\n */\nexport async function extendOracleTtl(options) {\n  const oracleId = encode(decode(options.onAccount.address), Encoding.OracleAddress);\n  const oracleExtendTx = await buildTxAsync({\n    oracleTtlType: ORACLE_TTL.type,\n    oracleTtlValue: ORACLE_TTL.value,\n    ...options,\n    tag: Tag.OracleExtendTx,\n    oracleId\n  });\n  return {\n    ...(await sendTransaction(oracleExtendTx, options)),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    ...(await getOracleObject(oracleId, options))\n  };\n}\n/**\n * Extend oracle ttl\n * @category oracle\n * @param queryId - Oracle query id\n * @param response - Oracle query response\n * @param options - Options object\n * @param options.responseTtl - responseTtl Query response time to leave\n * @param options.fee - Transaction fee\n * @param options.ttl - Transaction time to leave\n * @returns Oracle object\n */\nexport async function respondToQuery(queryId, response, options) {\n  const oracleId = encode(decode(options.onAccount.address), Encoding.OracleAddress);\n  const oracleRespondTx = await buildTxAsync({\n    responseTtlType: RESPONSE_TTL.type,\n    responseTtlValue: RESPONSE_TTL.value,\n    ...options,\n    tag: Tag.OracleResponseTx,\n    oracleId,\n    queryId,\n    response\n  });\n  return {\n    ...(await sendTransaction(oracleRespondTx, options)),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    ...(await getOracleObject(oracleId, options))\n  };\n}\n/**\n * Constructor for Oracle Object (helper object for using Oracle)\n * @category oracle\n * @param oracleId - Oracle public key\n * @param options - Options\n * @returns Oracle object\n */\nexport async function getOracleObject(oracleId, options) {\n  return {\n    ...(await options.onNode.getOracleByPubkey(oracleId)),\n    queries: (await options.onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries,\n    ...mapObject({\n      pollQueries: pollForQueries,\n      postQuery: postQueryToOracle,\n      respondToQuery,\n      extendOracle: extendOracleTtl,\n      getQuery: getQueryObject\n    }, _ref4 => {\n      let [name, handler] = _ref4;\n      return [name, function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const lastArg = args[args.length - 1];\n        if (lastArg != null && typeof lastArg === 'object' && lastArg.constructor === Object) {\n          Object.assign(lastArg, {\n            ...options,\n            ...lastArg\n          });\n        } else args.push(options);\n        return handler(...(['extendOracle', 'respondToQuery'].includes(name) ? [] : [oracleId]), ...args);\n      }];\n    })\n  };\n}\n/**\n * Register oracle\n * @category oracle\n * @param queryFormat - Format of query\n * @param responseFormat - Format of query response\n * @param options - Options\n * @param options.queryFee - Oracle query Fee\n * @param options - Options object\n * @param options.abiVersion - Always 0 (do not use virtual machine)\n * @param options.fee - Transaction fee\n * @param options.ttl - Transaction time to leave\n * @returns Oracle object\n */\nexport async function registerOracle(queryFormat, responseFormat, options) {\n  const accountId = options.onAccount.address;\n  const oracleRegisterTx = await buildTxAsync({\n    oracleTtlValue: ORACLE_TTL.value,\n    oracleTtlType: ORACLE_TTL.type,\n    ...options,\n    tag: Tag.OracleRegisterTx,\n    accountId,\n    queryFormat,\n    responseFormat\n  });\n  return {\n    ...(await sendTransaction(oracleRegisterTx, options)),\n    ...(await getOracleObject(encode(decode(accountId), Encoding.OracleAddress), options))\n  };\n}","map":{"version":3,"names":["mapObject","pause","oracleQueryId","unpackTx","buildTxAsync","ORACLE_TTL","QUERY_TTL","RESPONSE_TTL","Tag","RequestTimedOutError","decode","encode","Encoding","_getPollInterval","getHeight","sendTransaction","pollForQueries","oracleId","onQuery","_ref","_interval","interval","onNode","options","knownQueryIds","Set","checkNewQueries","_await$onNode$getOrac","queries","getOracleQueriesByPubkey","oracleQueries","filter","_ref2","id","has","forEach","query","add","stopped","catch","console","error","pollForQueryResponse","queryId","_ref3","_interval2","height","ttl","response","getOracleQueryByPubkeyAndQueryId","responseBuffer","length","toString","getQueryObject","record","decodedQuery","decodedResponse","respond","opt","respondToQuery","pollForResponse","postQueryToOracle","_options$queryFee","queryFee","getOracleByPubkey","senderId","onAccount","address","oracleQueryTx","queryTtlType","type","queryTtlValue","value","responseTtlType","responseTtlValue","tag","OracleQueryTx","nonce","extendOracleTtl","OracleAddress","oracleExtendTx","oracleTtlType","oracleTtlValue","OracleExtendTx","getOracleObject","oracleRespondTx","OracleResponseTx","pollQueries","postQuery","extendOracle","getQuery","_ref4","name","handler","_len","arguments","args","Array","_key","lastArg","constructor","Object","assign","push","includes","registerOracle","queryFormat","responseFormat","accountId","oracleRegisterTx","OracleRegisterTx"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\oracle.ts"],"sourcesContent":["/**\n * Oracle methods - routines to interact with the æternity oracle system\n *\n * The high-level description of the oracle system is\n * https://github.com/aeternity/protocol/blob/master/ORACLE.md in the protocol\n * repository.\n */\n\nimport { mapObject, pause } from './utils/other';\nimport { oracleQueryId } from './tx/builder/helpers';\nimport { unpackTx, buildTxAsync, BuildTxOptions } from './tx/builder';\nimport {\n  ORACLE_TTL,\n  ORACLE_TTL_TYPES,\n  QUERY_TTL,\n  RESPONSE_TTL,\n} from './tx/builder/schema';\nimport { Tag } from './tx/builder/constants';\nimport { RequestTimedOutError } from './utils/errors';\nimport {\n  decode, encode, Encoded, Encoding,\n} from './utils/encoder';\nimport {\n  _getPollInterval, getHeight, sendTransaction, SendTransactionOptions,\n} from './chain';\nimport Node from './Node';\nimport AccountBase from './account/Base';\n\ntype OracleQueries = Awaited<ReturnType<Node['getOracleQueriesByPubkey']>>['oracleQueries'];\n\n/**\n * Poll for oracle queries\n * @category oracle\n * @param oracleId - Oracle public key\n * @param onQuery - OnQuery callback\n * @param options - Options object\n * @param options.interval - Poll interval(default: 5000)\n * @param options.onNode - Node to use\n * @returns Callback to stop polling function\n */\nexport function pollForQueries(\n  oracleId: Encoded.OracleAddress,\n  onQuery: (query: OracleQueries[number]) => void,\n  { interval, onNode, ...options }: { interval?: number; onNode: Node }\n  & Parameters<typeof _getPollInterval>[1],\n): () => void {\n  interval ??= _getPollInterval('microblock', options);\n  const knownQueryIds = new Set();\n  const checkNewQueries = async (): Promise<void> => {\n    const queries = ((await onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries ?? [])\n      .filter(({ id }) => !knownQueryIds.has(id));\n    queries.forEach((query) => {\n      knownQueryIds.add(query.id);\n      onQuery(query);\n    });\n  };\n\n  let stopped = false;\n\n  // eslint-disable-next-line @typescript-eslint/no-floating-promises\n  (async () => {\n    while (!stopped) { // eslint-disable-line no-unmodified-loop-condition\n      // TODO: allow to handle this error somehow\n      await checkNewQueries().catch(console.error);\n      await pause(interval);\n    }\n  })();\n  return () => { stopped = true; };\n}\n\n/**\n * Poll for oracle query response\n * @category oracle\n * @param oracleId - Oracle public key\n * @param queryId - Oracle Query id\n * @param options - Options object\n * @param options.interval - Poll interval\n * @param options.onNode - Node to use\n * @returns OracleQuery object\n */\nexport async function pollForQueryResponse(\n  oracleId: Encoded.OracleAddress,\n  queryId: Encoded.OracleQueryId,\n  { interval, onNode, ...options }:\n  { interval?: number; onNode: Node } & Parameters<typeof _getPollInterval>[1],\n): Promise<string> {\n  interval ??= _getPollInterval('microblock', options);\n  let height;\n  let ttl;\n  let response;\n  do {\n    ({ response, ttl } = await onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId));\n    const responseBuffer = decode(response as Encoded.OracleResponse);\n    if (responseBuffer.length > 0) return responseBuffer.toString();\n    await pause(interval);\n    height = await getHeight({ onNode });\n  } while (ttl >= height);\n  throw new RequestTimedOutError(height);\n}\n\n/**\n * Constructor for OracleQuery Object (helper object for using OracleQuery)\n * @category oracle\n * @param oracleId - Oracle public key\n * @param queryId - Oracle Query id\n * @param options - Options\n * @returns OracleQuery object\n */\nexport async function getQueryObject(\n  oracleId: Encoded.OracleAddress,\n  queryId: Encoded.OracleQueryId,\n  options: RespondToQueryOptions & Parameters<typeof pollForQueryResponse>[2],\n): Promise<GetQueryObjectReturnType> {\n  const record = await options.onNode.getOracleQueryByPubkeyAndQueryId(oracleId, queryId);\n  return {\n    ...record,\n    decodedQuery: decode(record.query as Encoded.OracleQueryId).toString(),\n    decodedResponse: decode(record.response as Encoded.OracleResponse).toString(),\n    respond: async (response, opt) => (\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      respondToQuery(queryId, response, { ...options, ...opt })\n    ),\n    pollForResponse: async (opt) => pollForQueryResponse(oracleId, queryId, { ...options, ...opt }),\n  };\n}\n\ninterface GetQueryObjectReturnType extends Awaited<ReturnType<Node['getOracleQueryByPubkeyAndQueryId']>> {\n  decodedQuery: string;\n  decodedResponse: string;\n  respond: (response: string, options?: Parameters<typeof respondToQuery>[2]) =>\n  ReturnType<typeof respondToQuery>;\n  pollForResponse: (options?: Parameters<typeof pollForQueryResponse>[2]) =>\n  ReturnType<typeof pollForQueryResponse>;\n}\n\n/**\n * Post query to oracle\n * @category oracle\n * @param oracleId - Oracle public key\n * @param query - Oracle query object\n * @param options - Options object\n * @param options.queryTtl - queryTtl Oracle query time to leave\n * @param options.responseTtl - queryFee Oracle query response time to leave\n * @param options.queryFee - queryFee Oracle query fee\n * @param options.fee - fee Transaction fee\n * @param options.ttl - Transaction time to leave\n * @returns Query object\n */\nexport async function postQueryToOracle(\n  oracleId: Encoded.OracleAddress,\n  query: string,\n  options: PostQueryToOracleOptions,\n): Promise<\n  Awaited<ReturnType<typeof sendTransaction>> & Awaited<ReturnType<typeof getQueryObject>>\n  > {\n  options.queryFee ??= (await options.onNode.getOracleByPubkey(oracleId)).queryFee.toString();\n  const senderId = options.onAccount.address;\n\n  const oracleQueryTx = await buildTxAsync({\n    queryTtlType: QUERY_TTL.type,\n    queryTtlValue: QUERY_TTL.value,\n    responseTtlType: RESPONSE_TTL.type,\n    responseTtlValue: RESPONSE_TTL.value,\n    ...options,\n    tag: Tag.OracleQueryTx,\n    oracleId,\n    senderId,\n    query,\n  });\n  const { nonce } = unpackTx(oracleQueryTx, Tag.OracleQueryTx);\n  const queryId = oracleQueryId(senderId, nonce, oracleId);\n  return {\n    ...await sendTransaction(oracleQueryTx, options),\n    ...await getQueryObject(oracleId, queryId, options),\n  };\n}\n\ntype PostQueryToOracleOptionsType = Parameters<typeof sendTransaction>[1]\n& Parameters<typeof getQueryObject>[2]\n& BuildTxOptions<Tag.OracleQueryTx, 'oracleId' | 'senderId' | 'query' | 'queryTtlType' | 'queryTtlValue' | 'responseTtlType' | 'responseTtlValue'>\n& {\n  queryTtlType?: ORACLE_TTL_TYPES;\n  queryTtlValue?: number;\n  responseTtlType?: ORACLE_TTL_TYPES;\n  responseTtlValue?: number;\n};\ninterface PostQueryToOracleOptions extends PostQueryToOracleOptionsType {}\n\n/**\n * Extend oracle ttl\n * @category oracle\n * @param options - Options object\n * @param options.fee - fee Transaction fee\n * @param options.ttl - Transaction time to leave\n * @param options.oracleTtlType - Oracle time to leave for extend\n * @param options.oracleTtlValue - Oracle time to leave for extend\n * @returns Oracle object\n */\nexport async function extendOracleTtl(options: ExtendOracleTtlOptions): Promise<\nAwaited<ReturnType<typeof sendTransaction>> & Awaited<ReturnType<typeof getOracleObject>>\n> {\n  const oracleId = encode(decode(options.onAccount.address), Encoding.OracleAddress);\n  const oracleExtendTx = await buildTxAsync({\n    oracleTtlType: ORACLE_TTL.type,\n    oracleTtlValue: ORACLE_TTL.value,\n    ...options,\n    tag: Tag.OracleExtendTx,\n    oracleId,\n  });\n  return {\n    ...await sendTransaction(oracleExtendTx, options),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    ...await getOracleObject(oracleId, options),\n  };\n}\n\ntype ExtendOracleTtlOptionsType = SendTransactionOptions & Parameters<typeof getOracleObject>[1]\n& BuildTxOptions<Tag.OracleExtendTx, 'oracleTtlType' | 'oracleTtlValue' | 'callerId' | 'oracleId'>\n& { oracleTtlType?: ORACLE_TTL_TYPES; oracleTtlValue?: number };\ninterface ExtendOracleTtlOptions extends ExtendOracleTtlOptionsType {}\n\n/**\n * Extend oracle ttl\n * @category oracle\n * @param queryId - Oracle query id\n * @param response - Oracle query response\n * @param options - Options object\n * @param options.responseTtl - responseTtl Query response time to leave\n * @param options.fee - Transaction fee\n * @param options.ttl - Transaction time to leave\n * @returns Oracle object\n */\nexport async function respondToQuery(\n  queryId: Encoded.OracleQueryId,\n  response: string,\n  options: RespondToQueryOptions,\n): Promise<\n  Awaited<ReturnType<typeof sendTransaction>> & Awaited<ReturnType<typeof getOracleObject>>\n  > {\n  const oracleId = encode(decode(options.onAccount.address), Encoding.OracleAddress);\n  const oracleRespondTx = await buildTxAsync({\n    responseTtlType: RESPONSE_TTL.type,\n    responseTtlValue: RESPONSE_TTL.value,\n    ...options,\n    tag: Tag.OracleResponseTx,\n    oracleId,\n    queryId,\n    response,\n  });\n  return {\n    ...await sendTransaction(oracleRespondTx, options),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    ...await getOracleObject(oracleId, options),\n  };\n}\n\ntype RespondToQueryOptionsType = SendTransactionOptions & Parameters<typeof getOracleObject>[1]\n& BuildTxOptions<Tag.OracleResponseTx, 'callerId' | 'oracleId' | 'queryId' | 'response' | 'responseTtlType' | 'responseTtlValue'>\n& { responseTtlType?: ORACLE_TTL_TYPES; responseTtlValue?: number };\ninterface RespondToQueryOptions extends RespondToQueryOptionsType {}\n\n/**\n * Constructor for Oracle Object (helper object for using Oracle)\n * @category oracle\n * @param oracleId - Oracle public key\n * @param options - Options\n * @returns Oracle object\n */\nexport async function getOracleObject(\n  oracleId: Encoded.OracleAddress,\n  options: { onNode: Node; onAccount: AccountBase },\n): Promise<GetOracleObjectReturnType> {\n  return {\n    ...await options.onNode.getOracleByPubkey(oracleId),\n    queries: (await options.onNode.getOracleQueriesByPubkey(oracleId)).oracleQueries,\n    ...mapObject<Function, Function>(\n      {\n        pollQueries: pollForQueries,\n        postQuery: postQueryToOracle,\n        respondToQuery,\n        extendOracle: extendOracleTtl,\n        getQuery: getQueryObject,\n      },\n      ([name, handler]) => [\n        name,\n        (...args: any) => {\n          const lastArg = args[args.length - 1];\n          if (lastArg != null && typeof lastArg === 'object' && lastArg.constructor === Object) {\n            Object.assign(lastArg, { ...options, ...lastArg });\n          } else args.push(options);\n          return handler(\n            ...['extendOracle', 'respondToQuery'].includes(name) ? [] : [oracleId],\n            ...args,\n          );\n        },\n      ],\n    ),\n  } as any;\n}\n\ninterface GetOracleObjectReturnType extends Awaited<ReturnType<Node['getOracleByPubkey']>> {\n  id: Encoded.OracleAddress;\n  queries: OracleQueries;\n  // TODO: replace getOracleObject with a class\n  pollQueries: (cb: Parameters<typeof pollForQueries>[1]) => ReturnType<typeof pollForQueries>;\n  postQuery: Function;\n  respondToQuery: Function;\n  extendOracle: Function;\n  getQuery: Function;\n}\n\n/**\n * Register oracle\n * @category oracle\n * @param queryFormat - Format of query\n * @param responseFormat - Format of query response\n * @param options - Options\n * @param options.queryFee - Oracle query Fee\n * @param options - Options object\n * @param options.abiVersion - Always 0 (do not use virtual machine)\n * @param options.fee - Transaction fee\n * @param options.ttl - Transaction time to leave\n * @returns Oracle object\n */\nexport async function registerOracle(\n  queryFormat: string,\n  responseFormat: string,\n  options: RegisterOracleOptions,\n): Promise<\n  Awaited<ReturnType<typeof sendTransaction>> & Awaited<ReturnType<typeof getOracleObject>>\n  > {\n  const accountId = options.onAccount.address;\n  const oracleRegisterTx = await buildTxAsync({\n    oracleTtlValue: ORACLE_TTL.value,\n    oracleTtlType: ORACLE_TTL.type,\n    ...options,\n    tag: Tag.OracleRegisterTx,\n    accountId,\n    queryFormat,\n    responseFormat,\n  });\n  return {\n    ...await sendTransaction(oracleRegisterTx, options),\n    ...await getOracleObject(encode(decode(accountId), Encoding.OracleAddress), options),\n  };\n}\n\ntype RegisterOracleOptionsType = SendTransactionOptions & Parameters<typeof getOracleObject>[1]\n& BuildTxOptions<Tag.OracleRegisterTx, 'accountId' | 'queryFormat' | 'responseFormat' | 'oracleTtlType' | 'oracleTtlValue'>\n& {\n  oracleTtlType?: ORACLE_TTL_TYPES;\n  oracleTtlValue?: number;\n};\ninterface RegisterOracleOptions extends RegisterOracleOptionsType {}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}