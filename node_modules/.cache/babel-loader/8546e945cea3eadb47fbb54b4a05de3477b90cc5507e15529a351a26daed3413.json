{"ast":null,"code":"import _rlp from 'rlp';\nconst {\n  decode: rlpDecode,\n  encode: rlpEncode\n} = _rlp;\nimport { decode, encode, Encoding } from \"../../utils/encoder.mjs\";\nimport { hash } from \"../../utils/crypto.mjs\";\nimport { txSchema } from \"./schema.mjs\";\nimport { Tag } from \"./constants.mjs\";\nimport { buildContractId, readInt } from \"./helpers.mjs\";\nimport { ArgumentError, DecodeError, SchemaNotFoundError } from \"../../utils/errors.mjs\";\n/**\n * JavaScript-based Transaction builder\n */\nexport function getSchema(tag, version) {\n  var _version;\n  const schemas = txSchema.filter(s => s.tag.constValue === tag);\n  if (schemas.length === 0) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, 0);\n  (_version = version) !== null && _version !== void 0 ? _version : version = Math.max(...schemas.map(schema => schema.version.constValue));\n  const schema = schemas.find(s => s.version.constValue === version);\n  if (schema == null) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, version);\n  return Object.entries(schema);\n}\n/**\n * Build transaction hash\n * @category transaction builder\n * @param params - Object with tx params\n * @param options - options\n * @param options.prefix - Prefix of transaction\n * @returns object Base64Check transaction hash with 'tx_' prefix\n */\nexport function buildTx(params) {\n  let {\n    prefix\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const schema = getSchema(params.tag, params.version);\n  const binary = schema.map(_ref => {\n    let [key, field] = _ref;\n    return field.serialize(\n    // @ts-expect-error the type of `params[key]` can't be determined accurately\n    params[key], {\n      ...params,\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      unpackTx,\n      buildTx,\n      rebuildTx: overrideParams => buildTx({\n        ...params,\n        ...overrideParams\n      })\n    }, params);\n  });\n\n  // @ts-expect-error looks like a TypeScript edge case\n  return encode(rlpEncode(binary), prefix !== null && prefix !== void 0 ? prefix : Encoding.Transaction);\n}\n/**\n * @category transaction builder\n */\nexport async function buildTxAsync(params) {\n  await Promise.all(getSchema(params.tag, params.version).map(async _ref2 => {\n    let [key, field] = _ref2;\n    if (field.prepare == null) return;\n    // @ts-expect-error the type of `params[key]` can't be determined accurately\n    params[key] = await field.prepare(params[key], params, params);\n  }));\n\n  // @ts-expect-error after preparation properties should be compatible with sync tx builder\n  return buildTx(params);\n}\n\n/**\n * Unpack transaction encoded as string\n * @category transaction builder\n * @param encodedTx - Transaction to unpack\n * @param txType - Expected transaction type\n * @returns Object with transaction param's\n */\nexport function unpackTx(encodedTx, txType) {\n  const binary = rlpDecode(decode(encodedTx));\n  const tag = +readInt(binary[0]);\n  const version = +readInt(binary[1]);\n  const schema = getSchema(tag, version);\n  if (txType != null && txType !== tag) throw new DecodeError(`Expected transaction to have ${Tag[txType]} tag, got ${Tag[tag]} instead`);\n  if (binary.length !== schema.length) {\n    throw new ArgumentError('Transaction RLP length', schema.length, binary.length);\n  }\n  return schema.reduce((acc, _ref3, index) => {\n    let [name, field] = _ref3;\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const deserialized = field.deserialize(binary[index], {\n      unpackTx\n    });\n    return {\n      ...acc,\n      [name]: deserialized\n    };\n  }, {});\n}\n\n/**\n * Build a transaction hash\n * @category transaction builder\n * @param rawTx - base64 or rlp encoded transaction\n * @returns Transaction hash\n */\nexport function buildTxHash(rawTx) {\n  const data = typeof rawTx === 'string' && rawTx.startsWith('tx_') ? decode(rawTx) : rawTx;\n  return encode(hash(data), Encoding.TxHash);\n}\n\n/**\n * Build a contract public key by contractCreateTx or gaAttach\n * @category contract\n * @param contractTx - Transaction\n * @returns Contract public key\n */\nexport function buildContractIdByContractTx(contractTx) {\n  const params = unpackTx(contractTx);\n  if (Tag.ContractCreateTx !== params.tag && Tag.GaAttachTx !== params.tag) {\n    throw new ArgumentError('contractTx', 'a contractCreateTx or gaAttach', params.tag);\n  }\n  return buildContractId(params.ownerId, params.nonce);\n}","map":{"version":3,"names":["_rlp","decode","rlpDecode","encode","rlpEncode","Encoding","hash","txSchema","Tag","buildContractId","readInt","ArgumentError","DecodeError","SchemaNotFoundError","getSchema","tag","version","_version","schemas","filter","s","constValue","length","Math","max","map","schema","find","Object","entries","buildTx","params","prefix","arguments","undefined","binary","_ref","key","field","serialize","unpackTx","rebuildTx","overrideParams","Transaction","buildTxAsync","Promise","all","_ref2","prepare","encodedTx","txType","reduce","acc","_ref3","index","name","deserialized","deserialize","buildTxHash","rawTx","data","startsWith","TxHash","buildContractIdByContractTx","contractTx","ContractCreateTx","GaAttachTx","ownerId","nonce"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\tx\\builder\\index.ts"],"sourcesContent":["import { decode as rlpDecode, encode as rlpEncode } from 'rlp';\nimport {\n  decode, encode, Encoded, Encoding,\n} from '../../utils/encoder';\nimport { hash } from '../../utils/crypto';\nimport { BinaryData, Field } from './field-types';\nimport { txSchema } from './schema';\nimport { TxUnpacked, TxParams, TxParamsAsync } from './schema.generated';\nimport { Tag } from './constants';\nimport { buildContractId, readInt } from './helpers';\nimport { ArgumentError, DecodeError, SchemaNotFoundError } from '../../utils/errors';\n\n/**\n * JavaScript-based Transaction builder\n */\n\nexport function getSchema(tag: Tag, version?: number): Array<[string, Field]> {\n  const schemas = txSchema.filter((s) => s.tag.constValue === tag);\n  if (schemas.length === 0) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, 0);\n  version ??= Math.max(...schemas.map((schema) => schema.version.constValue));\n  const schema = schemas.find((s) => s.version.constValue === version);\n  if (schema == null) throw new SchemaNotFoundError(`${Tag[tag]} (${tag})`, version);\n  return Object.entries(schema);\n}\n\ntype TxEncoding = Encoding.Transaction | Encoding.Poi | Encoding.StateTrees\n| Encoding.CallStateTree;\n\n/**\n * Build transaction hash\n * @category transaction builder\n * @param params - Object with tx params\n * @param options - options\n * @param options.prefix - Prefix of transaction\n * @returns object Base64Check transaction hash with 'tx_' prefix\n */\nexport function buildTx<E extends TxEncoding = Encoding.Transaction>(\n  params: TxParams,\n  { prefix }: { prefix?: E } = {},\n): Encoded.Generic<E> {\n  const schema = getSchema(params.tag, params.version);\n\n  const binary = schema.map(([key, field]) => (\n    field.serialize(\n      // @ts-expect-error the type of `params[key]` can't be determined accurately\n      params[key],\n      {\n        ...params,\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        unpackTx,\n        buildTx,\n        rebuildTx: (overrideParams: any) => buildTx(\n          { ...params, ...overrideParams },\n        ),\n      },\n      params,\n    )\n  ));\n\n  // @ts-expect-error looks like a TypeScript edge case\n  return encode(rlpEncode(binary), prefix ?? Encoding.Transaction);\n}\n\nexport type BuildTxOptions <TxType extends Tag, OmitFields extends string> =\n  Omit<TxParamsAsync & { tag: TxType }, 'tag' | OmitFields>;\n\n/**\n * @category transaction builder\n */\nexport async function buildTxAsync(params: TxParamsAsync): Promise<Encoded.Transaction> {\n  await Promise.all(\n    getSchema(params.tag, params.version)\n      .map(async ([key, field]) => {\n        if (field.prepare == null) return;\n        // @ts-expect-error the type of `params[key]` can't be determined accurately\n        params[key] = await field.prepare(params[key], params, params);\n      }),\n  );\n\n  // @ts-expect-error after preparation properties should be compatible with sync tx builder\n  return buildTx(params);\n}\n\n/**\n * Unpack transaction encoded as string\n * @category transaction builder\n * @param encodedTx - Transaction to unpack\n * @param txType - Expected transaction type\n * @returns Object with transaction param's\n */\nexport function unpackTx<TxType extends Tag>(\n  encodedTx: Encoded.Generic<TxEncoding>,\n  txType?: TxType,\n): TxUnpacked & { tag: TxType } {\n  const binary = rlpDecode(decode(encodedTx));\n  const tag = +readInt(binary[0] as Buffer);\n  const version = +readInt(binary[1] as Buffer);\n  const schema = getSchema(tag, version);\n  if (txType != null && txType !== tag) throw new DecodeError(`Expected transaction to have ${Tag[txType]} tag, got ${Tag[tag]} instead`);\n  if (binary.length !== schema.length) {\n    throw new ArgumentError('Transaction RLP length', schema.length, binary.length);\n  }\n  return schema.reduce<any>(\n    (acc, [name, field], index) => {\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      const deserialized = field.deserialize(binary[index] as BinaryData, { unpackTx });\n      return { ...acc, [name]: deserialized };\n    },\n    {},\n  ) as any;\n}\n\n/**\n * Build a transaction hash\n * @category transaction builder\n * @param rawTx - base64 or rlp encoded transaction\n * @returns Transaction hash\n */\nexport function buildTxHash(rawTx: Encoded.Transaction | Uint8Array): Encoded.TxHash {\n  const data = typeof rawTx === 'string' && rawTx.startsWith('tx_')\n    ? decode(rawTx)\n    : rawTx;\n  return encode(hash(data), Encoding.TxHash);\n}\n\n/**\n * Build a contract public key by contractCreateTx or gaAttach\n * @category contract\n * @param contractTx - Transaction\n * @returns Contract public key\n */\nexport function buildContractIdByContractTx(\n  contractTx: Encoded.Transaction,\n): Encoded.ContractAddress {\n  const params = unpackTx(contractTx);\n  if (Tag.ContractCreateTx !== params.tag && Tag.GaAttachTx !== params.tag) {\n    throw new ArgumentError('contractTx', 'a contractCreateTx or gaAttach', params.tag);\n  }\n  return buildContractId(params.ownerId, params.nonce);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}