{"ast":null,"code":"const ContractByteArrayEncoder = require('./ContractByteArrayEncoder');\nconst BytecodeTypeResolver = require('./BytecodeTypeResolver');\nconst ApiEncoder = require('./ApiEncoder');\nconst EventEncoder = require('./EventEncoder');\nconst {\n  FateTypeCalldata,\n  FateTypeString\n} = require('./FateTypes');\nconst EncoderError = require('./Errors/EncoderError');\nclass BytecodeContractCallEncoder {\n  /**\n   * Creates contract encoder using bytecode as type info provider\n   *\n   * @example\n   * const bytecode = require('./Test.aeb')\n   * const encoder = new BytecodeContractCallEncoder(bytecode)\n   *\n   * @param {string} bytecode - Contract bytecode using cannonical format.\n  */\n  constructor(bytecode) {\n    /** @type {ContractByteArrayEncoder} */\n    this._byteArrayEncoder = new ContractByteArrayEncoder();\n\n    /** @type {BytecodeTypeResolver} */\n    this._typeResolver = new BytecodeTypeResolver(bytecode);\n\n    /** @type {ApiEncoder} */\n    this._apiEncoder = new ApiEncoder();\n\n    /** @type {EventEncoder} */\n    this._eventEncoder = new EventEncoder();\n  }\n\n  /**\n   * Creates contract call data\n   *\n   * @example\n   * const encoded = encoder.encodeCall('test_string', [\"whoolymoly\"])\n   * console.log(`Encoded data: ${encoded}`)\n   * // Outputs:\n   * // Encoded data: cb_KxHwzCuVGyl3aG9vbHltb2x5zwMSnw==\n   *\n   * @param {string} funName - The function name as defined in the bytecode.\n   * @param {Array} args - An array of call arguments as Javascript data structures. See README.md\n   * @returns {string} Encoded calldata\n  */\n  encodeCall(funName, args) {\n    const {\n      types,\n      required\n    } = this._typeResolver.getCallTypes(funName);\n    if (args.length > types.length || args.length < required) {\n      throw new EncoderError('Non matching number of arguments. ' + `${funName} expects between ${required} and ${types.length} number of arguments but got ${args.length}`);\n    }\n    return this._byteArrayEncoder.encode(FateTypeCalldata(funName, types), args);\n  }\n\n  /**\n   * Decodes contract calldata\n   *\n   * @example\n   * const data = encoder.decodeCall('cb_KxHwzCuVGyl3aG9vbHltb2x5zwMSnw==')\n   * console.log('Decoded data:', data)\n   * // Outputs:\n   * // Decoded data: {\n   * //   functionId: 'aee52c3c',\n   * //   functionName: 'test_template_maze',\n   * //   args: [ 'whoolymoly' ]\n   * // }\n   *\n   * @param {string} data - Encoded calldata in canonical format.\n   * @returns {object} Decoded calldata\n  */\n  decodeCall(data) {\n    const {\n      functionId,\n      args\n    } = this._byteArrayEncoder.decodeWithType(data, FateTypeCalldata());\n    const functionName = this._typeResolver.getFunctionName(functionId);\n    return {\n      functionId,\n      functionName,\n      args\n    };\n  }\n\n  /**\n   * Decodes successful (resultType = ok) contract call return data\n   *\n   * @example\n   * const decoded = encoder.decode('test_string', 'cb_KXdob29seW1vbHlGazSE')\n   * console.log(`Decoded data: ${decoded}`)\n   * // Outputs:\n   * // Decoded data: whoolymoly\n   *\n   * @param {string} funName - The function name as defined in the bytecode.\n   * @param {string} data - The call return value in a canonical format.\n   * @param {'ok'|'revert'|'error'} resultType - The call result type.\n   * @returns {boolean|string|BigInt|Array|Map|Object}\n   *  Decoded value as Javascript data structures. See README.md\n  */\n  decodeResult(funName, data, resultType = 'ok') {\n    if (resultType === 'ok') {\n      const type = this._typeResolver.getReturnType(funName);\n      return this._byteArrayEncoder.decodeWithType(data, type);\n    }\n    if (resultType === 'error') {\n      const decoder = new TextDecoder();\n      const bytes = this._apiEncoder.decodeWithType(data, 'contract_bytearray');\n      return decoder.decode(bytes);\n    }\n    if (resultType === 'revert') {\n      return this._byteArrayEncoder.decodeWithType(data, FateTypeString());\n    }\n    throw new EncoderError(`Unknown call resutls type: \"${resultType}\"`);\n  }\n}\nmodule.exports = BytecodeContractCallEncoder;","map":{"version":3,"names":["ContractByteArrayEncoder","require","BytecodeTypeResolver","ApiEncoder","EventEncoder","FateTypeCalldata","FateTypeString","EncoderError","BytecodeContractCallEncoder","constructor","bytecode","_byteArrayEncoder","_typeResolver","_apiEncoder","_eventEncoder","encodeCall","funName","args","types","required","getCallTypes","length","encode","decodeCall","data","functionId","decodeWithType","functionName","getFunctionName","decodeResult","resultType","type","getReturnType","decoder","TextDecoder","bytes","decode","module","exports"],"sources":["C:/Users/amitk/Desktop/Donation Project/donation-aeternity-blockchain-contract/node_modules/@aeternity/aepp-calldata/src/BytecodeContractCallEncoder.js"],"sourcesContent":["const ContractByteArrayEncoder = require('./ContractByteArrayEncoder')\nconst BytecodeTypeResolver = require('./BytecodeTypeResolver')\nconst ApiEncoder = require('./ApiEncoder')\nconst EventEncoder = require('./EventEncoder')\nconst {FateTypeCalldata, FateTypeString} = require('./FateTypes')\nconst EncoderError = require('./Errors/EncoderError')\n\nclass BytecodeContractCallEncoder {\n    /**\n     * Creates contract encoder using bytecode as type info provider\n     *\n     * @example\n     * const bytecode = require('./Test.aeb')\n     * const encoder = new BytecodeContractCallEncoder(bytecode)\n     *\n     * @param {string} bytecode - Contract bytecode using cannonical format.\n    */\n    constructor(bytecode) {\n        /** @type {ContractByteArrayEncoder} */\n        this._byteArrayEncoder = new ContractByteArrayEncoder()\n\n        /** @type {BytecodeTypeResolver} */\n        this._typeResolver = new BytecodeTypeResolver(bytecode)\n\n        /** @type {ApiEncoder} */\n        this._apiEncoder = new ApiEncoder()\n\n        /** @type {EventEncoder} */\n        this._eventEncoder = new EventEncoder()\n    }\n\n    /**\n     * Creates contract call data\n     *\n     * @example\n     * const encoded = encoder.encodeCall('test_string', [\"whoolymoly\"])\n     * console.log(`Encoded data: ${encoded}`)\n     * // Outputs:\n     * // Encoded data: cb_KxHwzCuVGyl3aG9vbHltb2x5zwMSnw==\n     *\n     * @param {string} funName - The function name as defined in the bytecode.\n     * @param {Array} args - An array of call arguments as Javascript data structures. See README.md\n     * @returns {string} Encoded calldata\n    */\n    encodeCall(funName, args) {\n        const {types, required} = this._typeResolver.getCallTypes(funName)\n\n        if (args.length > types.length || args.length < required) {\n            throw new EncoderError(\n                'Non matching number of arguments. '\n                + `${funName} expects between ${required} and ${types.length} number of arguments but got ${args.length}`\n            )\n        }\n\n        return this._byteArrayEncoder.encode(FateTypeCalldata(funName, types), args)\n    }\n\n    /**\n     * Decodes contract calldata\n     *\n     * @example\n     * const data = encoder.decodeCall('cb_KxHwzCuVGyl3aG9vbHltb2x5zwMSnw==')\n     * console.log('Decoded data:', data)\n     * // Outputs:\n     * // Decoded data: {\n     * //   functionId: 'aee52c3c',\n     * //   functionName: 'test_template_maze',\n     * //   args: [ 'whoolymoly' ]\n     * // }\n     *\n     * @param {string} data - Encoded calldata in canonical format.\n     * @returns {object} Decoded calldata\n    */\n    decodeCall(data) {\n        const {functionId, args} = this._byteArrayEncoder.decodeWithType(data, FateTypeCalldata())\n        const functionName = this._typeResolver.getFunctionName(functionId)\n\n        return {\n            functionId,\n            functionName,\n            args\n        }\n    }\n\n    /**\n     * Decodes successful (resultType = ok) contract call return data\n     *\n     * @example\n     * const decoded = encoder.decode('test_string', 'cb_KXdob29seW1vbHlGazSE')\n     * console.log(`Decoded data: ${decoded}`)\n     * // Outputs:\n     * // Decoded data: whoolymoly\n     *\n     * @param {string} funName - The function name as defined in the bytecode.\n     * @param {string} data - The call return value in a canonical format.\n     * @param {'ok'|'revert'|'error'} resultType - The call result type.\n     * @returns {boolean|string|BigInt|Array|Map|Object}\n     *  Decoded value as Javascript data structures. See README.md\n    */\n    decodeResult(funName, data, resultType = 'ok') {\n        if (resultType === 'ok') {\n            const type = this._typeResolver.getReturnType(funName)\n\n            return this._byteArrayEncoder.decodeWithType(data, type)\n        }\n\n        if (resultType === 'error') {\n            const decoder = new TextDecoder()\n            const bytes = this._apiEncoder.decodeWithType(data, 'contract_bytearray')\n\n            return decoder.decode(bytes)\n        }\n\n        if (resultType === 'revert') {\n            return this._byteArrayEncoder.decodeWithType(data, FateTypeString())\n        }\n\n        throw new EncoderError(`Unknown call resutls type: \"${resultType}\"`)\n    }\n}\n\nmodule.exports = BytecodeContractCallEncoder\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}