{"ast":null,"code":"import _defineProperty from \"@babel/runtime-corejs3/helpers/defineProperty\";\nimport EventEmitter from 'events';\nimport { snakeToPascal } from \"../utils/string.mjs\";\nimport { buildTx, unpackTx } from \"../tx/builder/index.mjs\";\nimport { Tag } from \"../tx/builder/constants.mjs\";\nimport * as handlers from \"./handlers.mjs\";\nimport { initialize, enqueueAction, notify, call, disconnect as channelDisconnect } from \"./internal.mjs\";\nimport { ChannelError } from \"../utils/errors.mjs\";\nfunction snakeToPascalObjKeys(obj) {\n  return Object.entries(obj).reduce((result, _ref) => {\n    let [key, val] = _ref;\n    return {\n      ...result,\n      [snakeToPascal(key)]: val\n    };\n  }, {});\n}\n\n/**\n * Channel\n * @example\n * ```js\n * await Channel.initialize({\n *   url: 'ws://localhost:3001',\n *   role: 'initiator'\n *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n *   initiatorAmount: 1e18,\n *   responderAmount: 1e18,\n *   pushAmount: 0,\n *   channelReserve: 0,\n *   ttl: 1000,\n *   host: 'localhost',\n *   port: 3002,\n *   lockPeriod: 10,\n *   async sign (tag, tx) => await account.signTransaction(tx)\n * })\n * ```\n */\nexport default class Channel {\n  constructor() {\n    _defineProperty(this, \"_eventEmitter\", new EventEmitter());\n    _defineProperty(this, \"_nextRpcMessageId\", 0);\n    _defineProperty(this, \"_rpcCallbacks\", new Map());\n    _defineProperty(this, \"_messageQueue\", []);\n    _defineProperty(this, \"_isMessageQueueLocked\", false);\n    _defineProperty(this, \"_actionQueue\", []);\n    _defineProperty(this, \"_isActionQueueLocked\", false);\n    _defineProperty(this, \"_status\", 'disconnected');\n    _defineProperty(this, \"_state\", '');\n  }\n  /**\n   * @param options - Channel params\n   * @param options.url - Channel url (for example: \"ws://localhost:3001\")\n   * @param options.role - Participant role (\"initiator\" or \"responder\")\n   * @param options.initiatorId - Initiator's public key\n   * @param options.responderId - Responder's public key\n   * @param options.pushAmount - Initial deposit in favour of the responder by the initiator\n   * @param options.initiatorAmount - Amount of coins the initiator has committed to\n   * the channel\n   * @param options.responderAmount - Amount of coins the responder has committed to\n   * the channel\n   * @param options.channelReserve - The minimum amount both peers need to maintain\n   * @param options.ttl - Minimum block height to include the channel_create_tx\n   * @param options.host - Host of the responder's node\n   * @param options.port - The port of the responders node\n   * @param options.lockPeriod - Amount of blocks for disputing a solo close\n   * @param options.minimumDepthStrategy - How to calculate minimum depth (default: txfee)\n   * @param options.minimumDepth - The minimum amount of blocks to be mined\n   * @param options.fee - The fee to be used for the channel open transaction\n   * @param options.gasPrice - Used for the fee computation of the channel open transaction\n   * @param options.existingChannelId - Existing channel id (required if reestablishing a\n   * channel)\n   * @param options.offchainTx - Offchain transaction (required if reestablishing\n   * a channel)\n   * @param options.timeoutIdle - The time waiting for a new event to be initiated\n   * (default: 600000)\n   * @param options.timeoutFundingCreate - The time waiting for the initiator to produce\n   * the create channel transaction after the noise session had been established (default: 120000)\n   * @param options.timeoutFundingSign - The time frame the other client has to sign an\n   * off-chain update after our client had initiated and signed it. This applies only for double\n   * signed on-chain intended updates: channel create transaction, deposit, withdrawal and etc.\n   * (default: 120000)\n   * @param options.timeoutFundingLock - The time frame the other client has to confirm an\n   * on-chain transaction reaching maturity (passing minimum depth) after the local node has\n   * detected this. This applies only for double signed on-chain intended updates: channel create\n   * transaction, deposit, withdrawal and etc. (default: 360000)\n   * @param options.timeoutSign - The time frame the client has to return a signed\n   * off-chain update or to decline it. This applies for all off-chain updates (default: 500000)\n   * @param options.timeoutAccept - The time frame the other client has to react to an\n   * event. This applies for all off-chain updates that are not meant to land on-chain, as well as\n   * some special cases: opening a noise connection, mutual closing acknowledgement and\n   * reestablishing an existing channel (default: 120000)\n   * @param options.timeoutInitialized - the time frame the responder has to accept an\n   * incoming noise session. Applicable only for initiator (default: timeout_accept's value)\n   * @param options.timeoutAwaitingOpen - The time frame the initiator has to start an\n   * outgoing noise session to the responder's node. Applicable only for responder (default:\n   * timeout_idle's value)\n   * @param options.debug=false - Log websocket communication\n   * @param options.sign - Function which verifies and signs transactions\n   */\n  static async initialize(options) {\n    return Channel._initialize(new Channel(), options);\n  }\n  static async _initialize(channel, options) {\n    await initialize(channel, options.existingFsmId != null ? handlers.awaitingReconnection : handlers.awaitingConnection, handlers.channelOpen, options);\n    return channel;\n  }\n\n  /**\n   * Register event listener function\n   *\n   * Possible events:\n   *\n   *   - \"error\"\n   *   - \"stateChanged\"\n   *   - \"statusChanged\"\n   *   - \"message\"\n   *   - \"peerDisconnected\"\n   *   - \"onChainTx\"\n   *   - \"ownWithdrawLocked\"\n   *   - \"withdrawLocked\"\n   *   - \"ownDepositLocked\"\n   *   - \"depositLocked\"\n   *   - \"channelReestablished\"\n   *   - \"newContract\"\n   *\n   *\n   * @param eventName - Event name\n   * @param callback - Callback function\n   */\n  on(eventName, callback) {\n    this._eventEmitter.on(eventName, callback);\n  }\n\n  /**\n   * Remove event listener function\n   * @param eventName - Event name\n   * @param callback - Callback function\n   */\n  off(eventName, callback) {\n    this._eventEmitter.removeListener(eventName, callback);\n  }\n\n  /**\n   * Close the connection\n   */\n  disconnect() {\n    return channelDisconnect(this);\n  }\n\n  /**\n   * Get current status\n   */\n  status() {\n    return this._status;\n  }\n\n  /**\n   * Get current state\n   */\n  async state() {\n    const res = snakeToPascalObjKeys(await call(this, 'channels.get.offchain_state', {}));\n    return {\n      calls: unpackTx(res.calls, Tag.CallsMtree),\n      ...(res.halfSignedTx !== '' && {\n        halfSignedTx: unpackTx(res.halfSignedTx, Tag.SignedTx)\n      }),\n      ...(res.signedTx !== '' && {\n        signedTx: unpackTx(res.signedTx, Tag.SignedTx)\n      }),\n      trees: unpackTx(res.trees, Tag.StateTrees)\n    };\n  }\n\n  /**\n   * Get current round\n   *\n   * If round cannot be determined (for example when channel has not been opened)\n   * it will return `null`.\n   */\n  round() {\n    if (this._state === '') {\n      return null;\n    }\n    const params = unpackTx(this._state, Tag.SignedTx).encodedTx;\n    switch (params.tag) {\n      case Tag.ChannelCreateTx:\n        return 1;\n      case Tag.ChannelOffChainTx:\n      case Tag.ChannelWithdrawTx:\n      case Tag.ChannelDepositTx:\n        return params.round;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get channel id\n   *\n   */\n  id() {\n    if (this._channelId == null) throw new ChannelError('Channel is not initialized');\n    return this._channelId;\n  }\n\n  /**\n   * Get channel's fsm id\n   *\n   */\n  fsmId() {\n    if (this._fsmId == null) throw new ChannelError('Channel is not initialized');\n    return this._fsmId;\n  }\n  async enqueueAction(action) {\n    return enqueueAction(this, (channel, state) => (state === null || state === void 0 ? void 0 : state.handler) === handlers.channelOpen, action);\n  }\n\n  /**\n   * Leave channel\n   *\n   * It is possible to leave a channel and then later reestablish the channel\n   * off-chain state and continue operation. When a leave method is called,\n   * the channel fsm passes it on to the peer fsm, reports the current mutually\n   * signed state and then terminates.\n   *\n   * The channel can be reestablished by instantiating another Channel instance\n   * with two extra params: existingChannelId and offchainTx (returned from leave\n   * method as channelId and signedTx respectively).\n   *\n   * @example\n   * ```js\n   * channel.leave().then(({ channelId, signedTx }) => {\n   *   console.log(channelId)\n   *   console.log(signedTx)\n   * })\n   * ```\n   */\n  async leave() {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.leave');\n      return {\n        handler: handlers.awaitingLeave\n      };\n    });\n  }\n\n  /**\n   * Trigger mutual close\n   *\n   * At any moment after the channel is opened, a closing procedure can be triggered.\n   * This can be done by either of the parties. The process is similar to the off-chain updates.\n   *\n   * @param sign - Function which verifies and signs mutual close transaction\n   * @example\n   * ```js\n   * channel.shutdown(\n   *   async (tx) => await account.signTransaction(tx)\n   * ).then(tx => console.log('on_chain_tx', tx))\n   * ```\n   */\n  async shutdown(sign) {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.shutdown');\n      return {\n        handler: handlers.awaitingShutdownTx,\n        state: {\n          sign\n        }\n      };\n    });\n  }\n  static async reconnect(options, txParams) {\n    const {\n      sign\n    } = options;\n    return Channel.initialize({\n      ...options,\n      reconnectTx: await sign('reconnect', buildTx({\n        ...txParams,\n        tag: Tag.ChannelClientReconnectTx\n      }))\n    });\n  }\n}","map":{"version":3,"names":["EventEmitter","snakeToPascal","buildTx","unpackTx","Tag","handlers","initialize","enqueueAction","notify","call","disconnect","channelDisconnect","ChannelError","snakeToPascalObjKeys","obj","Object","entries","reduce","result","_ref","key","val","Channel","constructor","_defineProperty","Map","options","_initialize","channel","existingFsmId","awaitingReconnection","awaitingConnection","channelOpen","on","eventName","callback","_eventEmitter","off","removeListener","status","_status","state","res","calls","CallsMtree","halfSignedTx","SignedTx","signedTx","trees","StateTrees","round","_state","params","encodedTx","tag","ChannelCreateTx","ChannelOffChainTx","ChannelWithdrawTx","ChannelDepositTx","id","_channelId","fsmId","_fsmId","action","handler","leave","awaitingLeave","shutdown","sign","awaitingShutdownTx","reconnect","txParams","reconnectTx","ChannelClientReconnectTx"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\channel\\Base.ts"],"sourcesContent":["import EventEmitter from 'events';\nimport { w3cwebsocket as W3CWebSocket } from 'websocket';\nimport { snakeToPascal } from '../utils/string';\nimport { buildTx, unpackTx } from '../tx/builder';\nimport { Tag } from '../tx/builder/constants';\nimport * as handlers from './handlers';\nimport {\n  initialize,\n  enqueueAction,\n  notify,\n  call,\n  disconnect as channelDisconnect,\n  SignTx,\n  ChannelOptions,\n  ChannelState,\n  ChannelHandler,\n  ChannelAction,\n  ChannelStatus,\n  ChannelFsm,\n  ChannelMessage,\n  ChannelEvents,\n} from './internal';\nimport { ChannelError } from '../utils/errors';\nimport { Encoded } from '../utils/encoder';\nimport { TxUnpacked } from '../tx/builder/schema.generated';\n\nfunction snakeToPascalObjKeys<Type>(obj: object): Type {\n  return Object.entries(obj).reduce((result, [key, val]) => ({\n    ...result,\n    [snakeToPascal(key)]: val,\n  }), {}) as Type;\n}\n\n/**\n * Channel\n * @example\n * ```js\n * await Channel.initialize({\n *   url: 'ws://localhost:3001',\n *   role: 'initiator'\n *   initiatorId: 'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n *   responderId: 'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n *   initiatorAmount: 1e18,\n *   responderAmount: 1e18,\n *   pushAmount: 0,\n *   channelReserve: 0,\n *   ttl: 1000,\n *   host: 'localhost',\n *   port: 3002,\n *   lockPeriod: 10,\n *   async sign (tag, tx) => await account.signTransaction(tx)\n * })\n * ```\n */\nexport default class Channel {\n  _eventEmitter = new EventEmitter();\n\n  _pingTimeoutId!: NodeJS.Timeout;\n\n  _nextRpcMessageId = 0;\n\n  _rpcCallbacks = new Map<number, (message: object) => void>();\n\n  _fsmId?: Encoded.Bytearray;\n\n  _messageQueue: ChannelMessage[] = [];\n\n  _isMessageQueueLocked = false;\n\n  _actionQueue: ChannelAction[] = [];\n\n  _isActionQueueLocked = false;\n\n  _status: ChannelStatus = 'disconnected';\n\n  _fsm!: ChannelFsm;\n\n  _websocket!: W3CWebSocket;\n\n  _state: Encoded.Transaction | '' = '';\n\n  _options!: ChannelOptions;\n\n  _channelId?: Encoded.Channel;\n\n  /**\n   * @param options - Channel params\n   * @param options.url - Channel url (for example: \"ws://localhost:3001\")\n   * @param options.role - Participant role (\"initiator\" or \"responder\")\n   * @param options.initiatorId - Initiator's public key\n   * @param options.responderId - Responder's public key\n   * @param options.pushAmount - Initial deposit in favour of the responder by the initiator\n   * @param options.initiatorAmount - Amount of coins the initiator has committed to\n   * the channel\n   * @param options.responderAmount - Amount of coins the responder has committed to\n   * the channel\n   * @param options.channelReserve - The minimum amount both peers need to maintain\n   * @param options.ttl - Minimum block height to include the channel_create_tx\n   * @param options.host - Host of the responder's node\n   * @param options.port - The port of the responders node\n   * @param options.lockPeriod - Amount of blocks for disputing a solo close\n   * @param options.minimumDepthStrategy - How to calculate minimum depth (default: txfee)\n   * @param options.minimumDepth - The minimum amount of blocks to be mined\n   * @param options.fee - The fee to be used for the channel open transaction\n   * @param options.gasPrice - Used for the fee computation of the channel open transaction\n   * @param options.existingChannelId - Existing channel id (required if reestablishing a\n   * channel)\n   * @param options.offchainTx - Offchain transaction (required if reestablishing\n   * a channel)\n   * @param options.timeoutIdle - The time waiting for a new event to be initiated\n   * (default: 600000)\n   * @param options.timeoutFundingCreate - The time waiting for the initiator to produce\n   * the create channel transaction after the noise session had been established (default: 120000)\n   * @param options.timeoutFundingSign - The time frame the other client has to sign an\n   * off-chain update after our client had initiated and signed it. This applies only for double\n   * signed on-chain intended updates: channel create transaction, deposit, withdrawal and etc.\n   * (default: 120000)\n   * @param options.timeoutFundingLock - The time frame the other client has to confirm an\n   * on-chain transaction reaching maturity (passing minimum depth) after the local node has\n   * detected this. This applies only for double signed on-chain intended updates: channel create\n   * transaction, deposit, withdrawal and etc. (default: 360000)\n   * @param options.timeoutSign - The time frame the client has to return a signed\n   * off-chain update or to decline it. This applies for all off-chain updates (default: 500000)\n   * @param options.timeoutAccept - The time frame the other client has to react to an\n   * event. This applies for all off-chain updates that are not meant to land on-chain, as well as\n   * some special cases: opening a noise connection, mutual closing acknowledgement and\n   * reestablishing an existing channel (default: 120000)\n   * @param options.timeoutInitialized - the time frame the responder has to accept an\n   * incoming noise session. Applicable only for initiator (default: timeout_accept's value)\n   * @param options.timeoutAwaitingOpen - The time frame the initiator has to start an\n   * outgoing noise session to the responder's node. Applicable only for responder (default:\n   * timeout_idle's value)\n   * @param options.debug=false - Log websocket communication\n   * @param options.sign - Function which verifies and signs transactions\n   */\n  static async initialize(options: ChannelOptions): Promise<Channel> {\n    return Channel._initialize(new Channel(), options);\n  }\n\n  static async _initialize<T extends Channel>(channel: T, options: ChannelOptions): Promise<T> {\n    await initialize(\n      channel,\n      options.existingFsmId != null ? handlers.awaitingReconnection : handlers.awaitingConnection,\n      handlers.channelOpen,\n      options,\n    );\n    return channel;\n  }\n\n  /**\n   * Register event listener function\n   *\n   * Possible events:\n   *\n   *   - \"error\"\n   *   - \"stateChanged\"\n   *   - \"statusChanged\"\n   *   - \"message\"\n   *   - \"peerDisconnected\"\n   *   - \"onChainTx\"\n   *   - \"ownWithdrawLocked\"\n   *   - \"withdrawLocked\"\n   *   - \"ownDepositLocked\"\n   *   - \"depositLocked\"\n   *   - \"channelReestablished\"\n   *   - \"newContract\"\n   *\n   *\n   * @param eventName - Event name\n   * @param callback - Callback function\n   */\n  on<E extends keyof ChannelEvents>(eventName: E, callback: ChannelEvents[E]): void {\n    this._eventEmitter.on(eventName, callback);\n  }\n\n  /**\n   * Remove event listener function\n   * @param eventName - Event name\n   * @param callback - Callback function\n   */\n  off<E extends keyof ChannelEvents>(eventName: E, callback: ChannelEvents[E]): void {\n    this._eventEmitter.removeListener(eventName, callback);\n  }\n\n  /**\n   * Close the connection\n   */\n  disconnect(): void {\n    return channelDisconnect(this);\n  }\n\n  /**\n   * Get current status\n   */\n  status(): ChannelStatus {\n    return this._status;\n  }\n\n  /**\n   * Get current state\n   */\n  async state(): Promise<{\n    calls: TxUnpacked & { tag: Tag.CallsMtree };\n    halfSignedTx?: TxUnpacked & { tag: Tag.SignedTx };\n    signedTx?: TxUnpacked & { tag: Tag.SignedTx };\n    trees: TxUnpacked & { tag: Tag.StateTrees };\n  }> {\n    const res = snakeToPascalObjKeys<{\n      calls: Encoded.CallStateTree;\n      halfSignedTx: Encoded.Transaction | '';\n      signedTx: Encoded.Transaction | '';\n      trees: Encoded.StateTrees;\n    }>(await call(this, 'channels.get.offchain_state', {}));\n    return {\n      calls: unpackTx(res.calls, Tag.CallsMtree),\n      ...res.halfSignedTx !== '' && { halfSignedTx: unpackTx(res.halfSignedTx, Tag.SignedTx) },\n      ...res.signedTx !== '' && { signedTx: unpackTx(res.signedTx, Tag.SignedTx) },\n      trees: unpackTx(res.trees, Tag.StateTrees),\n    };\n  }\n\n  /**\n   * Get current round\n   *\n   * If round cannot be determined (for example when channel has not been opened)\n   * it will return `null`.\n   */\n  round(): number | null {\n    if (this._state === '') {\n      return null;\n    }\n    const params = unpackTx(this._state, Tag.SignedTx).encodedTx;\n    switch (params.tag) {\n      case Tag.ChannelCreateTx:\n        return 1;\n      case Tag.ChannelOffChainTx:\n      case Tag.ChannelWithdrawTx:\n      case Tag.ChannelDepositTx:\n        return params.round;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get channel id\n   *\n   */\n  id(): Encoded.Channel {\n    if (this._channelId == null) throw new ChannelError('Channel is not initialized');\n    return this._channelId;\n  }\n\n  /**\n   * Get channel's fsm id\n   *\n   */\n  fsmId(): Encoded.Bytearray {\n    if (this._fsmId == null) throw new ChannelError('Channel is not initialized');\n    return this._fsmId;\n  }\n\n  protected async enqueueAction(\n    action: () => { handler: ChannelHandler; state?: Partial<ChannelState> },\n  ): Promise<any> {\n    return enqueueAction(\n      this,\n      (channel, state) => state?.handler === handlers.channelOpen,\n      action,\n    );\n  }\n\n  /**\n   * Leave channel\n   *\n   * It is possible to leave a channel and then later reestablish the channel\n   * off-chain state and continue operation. When a leave method is called,\n   * the channel fsm passes it on to the peer fsm, reports the current mutually\n   * signed state and then terminates.\n   *\n   * The channel can be reestablished by instantiating another Channel instance\n   * with two extra params: existingChannelId and offchainTx (returned from leave\n   * method as channelId and signedTx respectively).\n   *\n   * @example\n   * ```js\n   * channel.leave().then(({ channelId, signedTx }) => {\n   *   console.log(channelId)\n   *   console.log(signedTx)\n   * })\n   * ```\n   */\n  async leave(): Promise<{ channelId: Encoded.Bytearray; signedTx: Encoded.Transaction }> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.leave');\n      return { handler: handlers.awaitingLeave };\n    });\n  }\n\n  /**\n   * Trigger mutual close\n   *\n   * At any moment after the channel is opened, a closing procedure can be triggered.\n   * This can be done by either of the parties. The process is similar to the off-chain updates.\n   *\n   * @param sign - Function which verifies and signs mutual close transaction\n   * @example\n   * ```js\n   * channel.shutdown(\n   *   async (tx) => await account.signTransaction(tx)\n   * ).then(tx => console.log('on_chain_tx', tx))\n   * ```\n   */\n  async shutdown(sign: SignTx): Promise<Encoded.Transaction> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.shutdown');\n      return {\n        handler: handlers.awaitingShutdownTx,\n        state: { sign },\n      };\n    });\n  }\n\n  static async reconnect(options: ChannelOptions, txParams: any): Promise<Channel> {\n    const { sign } = options;\n\n    return Channel.initialize({\n      ...options,\n      reconnectTx: await sign(\n        'reconnect',\n        buildTx({ ...txParams, tag: Tag.ChannelClientReconnectTx }),\n      ),\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}