{"ast":null,"code":"import { Tag } from \"../constants.mjs\";\nimport { encode, Encoding, decode } from \"../../../utils/encoder.mjs\";\nexport default function genMapField(encoding, tag) {\n  return {\n    serialize(object, _ref) {\n      let {\n        buildTx\n      } = _ref;\n      return decode(buildTx({\n        tag: Tag.Mtree,\n        values: Object.entries(object).map(_ref2 => {\n          let [key, value] = _ref2;\n          return {\n            tag: Tag.MtreeValue,\n            key: decode(key),\n            value: decode(buildTx({\n              ...value,\n              tag\n            }))\n          };\n        })\n      }));\n    },\n    deserialize(buffer, _ref3) {\n      let {\n        unpackTx\n      } = _ref3;\n      const {\n        values\n      } = unpackTx(encode(buffer, Encoding.Transaction), Tag.Mtree);\n      return Object.fromEntries(values\n      // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066\n      .filter(_ref4 => {\n        let {\n          key\n        } = _ref4;\n        return encoding !== Encoding.ContractAddress || key.length === 32;\n      }).map(_ref5 => {\n        let {\n          key,\n          value\n        } = _ref5;\n        return [encode(key, encoding), unpackTx(encode(value, Encoding.Transaction), tag)];\n      }));\n    },\n    recursiveType: true\n  };\n}","map":{"version":3,"names":["Tag","encode","Encoding","decode","genMapField","encoding","tag","serialize","object","_ref","buildTx","Mtree","values","Object","entries","map","_ref2","key","value","MtreeValue","deserialize","buffer","_ref3","unpackTx","Transaction","fromEntries","filter","_ref4","ContractAddress","length","_ref5","recursiveType"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\tx\\builder\\field-types\\map.ts"],"sourcesContent":["import { Tag } from '../constants';\nimport {\n  encode, Encoding, Encoded, decode,\n} from '../../../utils/encoder';\nimport type { unpackTx as unpackTxType, buildTx as buildTxType } from '../index';\n\nexport default function genMapField<E extends Encoding, T extends Tag>(encoding: E, tag: T): {\n  serialize: (\n    // TODO: replace with `TxParams & { tag: T }`,\n    //  but fix TS2502 value is referenced directly or indirectly in its own type annotation\n    value: Record<Encoded.Generic<E>, any>, options: { buildTx: typeof buildTxType }\n  ) => Buffer;\n  deserialize: (\n    value: Buffer, options: { unpackTx: typeof unpackTxType },\n    // TODO: replace with `TxUnpacked & { tag: T }`,\n    //  TS2577 Return type annotation circularly references itself\n  ) => Record<Encoded.Generic<E>, any>;\n  recursiveType: true;\n} {\n  return {\n    serialize(object, { buildTx }) {\n      return decode(buildTx({\n        tag: Tag.Mtree,\n        values: Object.entries(object).map(([key, value]) => ({\n          tag: Tag.MtreeValue,\n          key: decode(key as Encoded.Generic<E>),\n          value: decode(buildTx({ ...value as any, tag })),\n        })),\n      }));\n    },\n\n    deserialize(buffer, { unpackTx }) {\n      const { values } = unpackTx(encode(buffer, Encoding.Transaction), Tag.Mtree);\n      return Object.fromEntries(values\n        // TODO: remove after resolving https://github.com/aeternity/aeternity/issues/4066\n        .filter(({ key }) => encoding !== Encoding.ContractAddress || key.length === 32)\n        .map(({ key, value }) => [\n          encode(key, encoding),\n          unpackTx(encode(value, Encoding.Transaction), tag),\n        ])) as Record<Encoded.Generic<E>, any>;\n    },\n\n    recursiveType: true,\n  };\n}\n"],"mappings":"SAASA,GAAG;AAAA,SAEVC,MAAM,EAAEC,QAAQ,EAAWC,MAAM;AAInC,eAAe,SAASC,WAAWA,CAAoCC,QAAW,EAAEC,GAAM,EAYxF;EACA,OAAO;IACLC,SAASA,CAACC,MAAM,EAAAC,IAAA,EAAe;MAAA,IAAb;QAAEC;MAAQ,CAAC,GAAAD,IAAA;MAC3B,OAAON,MAAM,CAACO,OAAO,CAAC;QACpBJ,GAAG,EAAEN,GAAG,CAACW,KAAK;QACdC,MAAM,EAAEC,MAAM,CAACC,OAAO,CAACN,MAAM,CAAC,CAACO,GAAG,CAACC,KAAA;UAAA,IAAC,CAACC,GAAG,EAAEC,KAAK,CAAC,GAAAF,KAAA;UAAA,OAAM;YACpDV,GAAG,EAAEN,GAAG,CAACmB,UAAU;YACnBF,GAAG,EAAEd,MAAM,CAACc,GAAyB,CAAC;YACtCC,KAAK,EAAEf,MAAM,CAACO,OAAO,CAAC;cAAE,GAAGQ,KAAY;cAAEZ;YAAI,CAAC,CAAC;UACjD,CAAC;QAAA,CAAC;MACJ,CAAC,CAAC,CAAC;IACL,CAAC;IAEDc,WAAWA,CAACC,MAAM,EAAAC,KAAA,EAAgB;MAAA,IAAd;QAAEC;MAAS,CAAC,GAAAD,KAAA;MAC9B,MAAM;QAAEV;MAAO,CAAC,GAAGW,QAAQ,CAACtB,MAAM,CAACoB,MAAM,EAAEnB,QAAQ,CAACsB,WAAW,CAAC,EAAExB,GAAG,CAACW,KAAK,CAAC;MAC5E,OAAOE,MAAM,CAACY,WAAW,CAACb;MACxB;MAAA,CACCc,MAAM,CAACC,KAAA;QAAA,IAAC;UAAEV;QAAI,CAAC,GAAAU,KAAA;QAAA,OAAKtB,QAAQ,KAAKH,QAAQ,CAAC0B,eAAe,IAAIX,GAAG,CAACY,MAAM,KAAK,EAAE;MAAA,EAAC,CAC/Ed,GAAG,CAACe,KAAA;QAAA,IAAC;UAAEb,GAAG;UAAEC;QAAM,CAAC,GAAAY,KAAA;QAAA,OAAK,CACvB7B,MAAM,CAACgB,GAAG,EAAEZ,QAAQ,CAAC,EACrBkB,QAAQ,CAACtB,MAAM,CAACiB,KAAK,EAAEhB,QAAQ,CAACsB,WAAW,CAAC,EAAElB,GAAG,CAAC,CACnD;MAAA,EAAC,CAAC;IACP,CAAC;IAEDyB,aAAa,EAAE;EACjB,CAAC;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}