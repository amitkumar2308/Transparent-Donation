{"ast":null,"code":"const TypeResolver = require('./TypeResolver');\nconst TypeResolveError = require('./Errors/TypeResolveError');\nconst {\n  FateTypeEvent\n} = require('./FateTypes');\nconst isObject = value => {\n  return value && typeof value === 'object' && value.constructor === Object;\n};\nconst isOption = ({\n  type\n}) => {\n  let key = type;\n  let _;\n  if (isObject(key)) {\n    [[key, _]] = Object.entries(key);\n  }\n  return key === 'option';\n};\nclass AciTypeResolver extends TypeResolver {\n  constructor(aci) {\n    super();\n    this.aci = aci;\n  }\n  getCallTypes(contract, funName) {\n    const funcAci = this.getNamespaceAci(contract).functions.find(e => e.name === funName);\n    if (funcAci) {\n      const types = funcAci.arguments.map(e => this.resolveType(e.type));\n      const options = funcAci.arguments.filter(isOption);\n      return {\n        types,\n        required: types.length - options.length\n      };\n    }\n    if (funName === 'init') {\n      return {\n        types: [],\n        required: 0\n      };\n    }\n    throw new TypeResolveError(`Unknown function ${funName}`);\n  }\n  getReturnType(contract, funName) {\n    if (funName === 'init') {\n      return this.resolveType('void');\n    }\n    const funcAci = this.getNamespaceAci(contract).functions.find(e => e.name === funName);\n    if (!funcAci) {\n      throw new TypeResolveError(`Unknown function ${funName}`);\n    }\n    return this.resolveType(funcAci.returns);\n  }\n  getEventType(contract, topics) {\n    const aci = this.getNamespaceAci(contract);\n    if (!aci.hasOwnProperty('event')) {\n      throw new TypeResolveError('Missing event declaration');\n    }\n    return FateTypeEvent(this.resolveType(aci.event), topics);\n  }\n  isCustomType(type) {\n    if (typeof type !== 'string') {\n      return false;\n    }\n    if (this.isStdType(type)) {\n      return false;\n    }\n    const [namespace, _localType] = type.split('.');\n    const namespaceData = this.getNamespaceAci(namespace);\n    return !!namespaceData;\n  }\n  isStdType(type) {\n    if (type === 'Set.set') {\n      return true;\n    }\n    return false;\n  }\n  getNamespaceAci(name) {\n    for (const e of this.aci) {\n      const [[_type, data]] = Object.entries(e);\n      if (data.name === name) {\n        return data;\n      }\n    }\n    return null;\n  }\n  resolveTypeDef(type, params = []) {\n    const [namespace, localType] = type.split('.');\n    const namespaceData = this.getNamespaceAci(namespace);\n\n    // not a custom type\n    if (!namespaceData) {\n      throw new TypeResolveError('Unknown namespace for ' + JSON.stringify(type));\n    }\n    if (namespaceData.name === type) {\n      return ['contract_pubkey', []];\n    }\n    const def = [\n    /**\n     * @deprecated use ACIs generated by aesophia@^7.1.0\n     * TODO remove `type_defs` in next major release\n     */\n    ...(namespaceData.typedefs || namespaceData.type_defs), ...(namespaceData.state ? [{\n      name: 'state',\n      typedef: namespaceData.state,\n      vars: []\n    }] : [])].find(e => e.name === localType);\n    if (!def) {\n      throw new TypeResolveError('Unknown type definition: ' + JSON.stringify(type));\n    }\n    const vars = {};\n    def.vars.forEach((e, i) => {\n      const [[_, k]] = Object.entries(e);\n      vars[k] = params[i];\n    });\n    const typeDef = vars.hasOwnProperty(def.typedef) ? vars[def.typedef] : def.typedef;\n    return [typeDef, vars];\n  }\n}\nmodule.exports = AciTypeResolver;","map":{"version":3,"names":["TypeResolver","require","TypeResolveError","FateTypeEvent","isObject","value","constructor","Object","isOption","type","key","_","entries","AciTypeResolver","aci","getCallTypes","contract","funName","funcAci","getNamespaceAci","functions","find","e","name","types","arguments","map","resolveType","options","filter","required","length","getReturnType","returns","getEventType","topics","hasOwnProperty","event","isCustomType","isStdType","namespace","_localType","split","namespaceData","_type","data","resolveTypeDef","params","localType","JSON","stringify","def","typedefs","type_defs","state","typedef","vars","forEach","i","k","typeDef","module","exports"],"sources":["C:/Users/amitk/Desktop/Donation Project/donation-aeternity-blockchain-contract/node_modules/@aeternity/aepp-calldata/src/AciTypeResolver.js"],"sourcesContent":["const TypeResolver = require('./TypeResolver')\nconst TypeResolveError = require('./Errors/TypeResolveError')\nconst {FateTypeEvent} = require('./FateTypes')\n\nconst isObject = (value) => {\n    return value && typeof value === 'object' && value.constructor === Object\n}\n\nconst isOption = ({type}) => {\n    let key = type\n    let _\n    if (isObject(key)) {\n        [[key, _]] = Object.entries(key)\n    }\n\n    return key === 'option'\n}\n\nclass AciTypeResolver extends TypeResolver {\n    constructor(aci) {\n        super()\n\n        this.aci = aci\n    }\n\n    getCallTypes(contract, funName) {\n        const funcAci = this.getNamespaceAci(contract).functions.find(e => e.name === funName)\n\n        if (funcAci) {\n            const types = funcAci.arguments.map(e => this.resolveType(e.type))\n            const options = funcAci.arguments.filter(isOption)\n            return {\n                types,\n                required: types.length - options.length,\n            }\n        }\n\n        if (funName === 'init') {\n            return {types: [], required: 0}\n        }\n\n        throw new TypeResolveError(`Unknown function ${funName}`)\n    }\n\n    getReturnType(contract, funName) {\n        if (funName === 'init') {\n            return this.resolveType('void')\n        }\n\n        const funcAci = this.getNamespaceAci(contract).functions.find(e => e.name === funName)\n\n        if (!funcAci) {\n            throw new TypeResolveError(`Unknown function ${funName}`)\n        }\n\n        return this.resolveType(funcAci.returns)\n    }\n\n    getEventType(contract, topics) {\n        const aci = this.getNamespaceAci(contract)\n\n        if (!aci.hasOwnProperty('event')) {\n            throw new TypeResolveError('Missing event declaration')\n        }\n\n        return FateTypeEvent(this.resolveType(aci.event), topics)\n    }\n\n    isCustomType(type) {\n        if (typeof type !== 'string') {\n            return false\n        }\n\n        if (this.isStdType(type)) {\n            return false\n        }\n\n        const [namespace, _localType] = type.split('.')\n        const namespaceData = this.getNamespaceAci(namespace)\n\n        return !!namespaceData\n    }\n\n    isStdType(type) {\n        if (type === 'Set.set') {\n            return true\n        }\n\n        return false\n    }\n\n    getNamespaceAci(name) {\n        for (const e of this.aci) {\n            const [[_type, data]] = Object.entries(e)\n            if (data.name === name) {\n                return data\n            }\n        }\n\n        return null\n    }\n\n    resolveTypeDef(type, params = []) {\n        const [namespace, localType] = type.split('.')\n        const namespaceData = this.getNamespaceAci(namespace)\n\n        // not a custom type\n        if (!namespaceData) {\n            throw new TypeResolveError('Unknown namespace for ' + JSON.stringify(type))\n        }\n\n        if (namespaceData.name === type) {\n            return ['contract_pubkey', []]\n        }\n\n        const def = [\n            /**\n             * @deprecated use ACIs generated by aesophia@^7.1.0\n             * TODO remove `type_defs` in next major release\n             */\n            ...namespaceData.typedefs || namespaceData.type_defs,\n            ...namespaceData.state ? [{\n                name: 'state',\n                typedef: namespaceData.state,\n                vars: []\n            }] : []\n        ].find(e => e.name === localType)\n\n        if (!def) {\n            throw new TypeResolveError('Unknown type definition: ' + JSON.stringify(type))\n        }\n\n        const vars = {}\n        def.vars.forEach((e, i) => {\n            const [[_, k]] = Object.entries(e)\n            vars[k] = params[i]\n        })\n\n        const typeDef = vars.hasOwnProperty(def.typedef) ? vars[def.typedef] : def.typedef\n\n        return [typeDef, vars]\n    }\n}\n\nmodule.exports = AciTypeResolver\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}