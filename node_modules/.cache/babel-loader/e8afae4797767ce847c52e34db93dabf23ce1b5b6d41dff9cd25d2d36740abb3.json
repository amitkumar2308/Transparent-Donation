{"ast":null,"code":"import _classPrivateFieldSet from \"@babel/runtime-corejs3/helpers/classPrivateFieldSet\";\nimport _classPrivateFieldGet from \"@babel/runtime-corejs3/helpers/classPrivateFieldGet\";\nfunction _classPrivateFieldInitSpec(obj, privateMap, value) {\n  _checkPrivateRedeclaration(obj, privateMap);\n  privateMap.set(obj, value);\n}\nfunction _classPrivateMethodInitSpec(obj, privateSet) {\n  _checkPrivateRedeclaration(obj, privateSet);\n  privateSet.add(obj);\n}\nfunction _checkPrivateRedeclaration(obj, privateCollection) {\n  if (privateCollection.has(obj)) {\n    throw new TypeError(\"Cannot initialize the same private elements twice on an object\");\n  }\n}\nfunction _classPrivateMethodGet(receiver, privateSet, fn) {\n  if (!privateSet.has(receiver)) {\n    throw new TypeError(\"attempted to get private field on non-instance\");\n  }\n  return fn;\n}\n/**\n * Contract module - routines to interact with the Ã¦ternity contract\n *\n * High level documentation of the contracts are available at\n * https://github.com/aeternity/protocol/tree/master/contracts and\n */\n\nimport _aeternityAeppCalldata from '@aeternity/aepp-calldata';\nconst {\n  Encoder: Calldata\n} = _aeternityAeppCalldata;\nimport { DRY_RUN_ACCOUNT } from \"../tx/builder/schema.mjs\";\nimport { Tag } from \"../tx/builder/constants.mjs\";\nimport { buildContractIdByContractTx, unpackTx, buildTxAsync, buildTxHash } from \"../tx/builder/index.mjs\";\nimport { decode } from \"../utils/encoder.mjs\";\nimport { MissingContractDefError, MissingContractAddressError, InactiveContractError, BytecodeMismatchError, DuplicateContractError, MissingFunctionNameError, InvalidMethodInvocationError, NotPayableFunctionError, TypeError as _TypeError, NodeInvocationError, IllegalArgumentError, NoSuchContractFunctionError, MissingEventDefinitionError, AmbiguousEventDefinitionError, UnexpectedTsError, InternalError, NoWalletConnectedError, ContractError } from \"../utils/errors.mjs\";\nimport { hash as calcHash } from \"../utils/crypto.mjs\";\nimport { getAccount, getContract, getContractByteCode, resolveName, txDryRun, sendTransaction } from \"../chain.mjs\";\nimport { isAccountNotFoundError } from \"../utils/other.mjs\";\nvar _getCallResult = /*#__PURE__*/new WeakSet();\nvar _sendAndProcess = /*#__PURE__*/new WeakSet();\nvar _getFunctionAci = /*#__PURE__*/new WeakSet();\nvar _getContractNameByEvent = /*#__PURE__*/new WeakSet();\nvar _aciContract = /*#__PURE__*/new WeakMap();\n/**\n * Generate contract ACI object with predefined js methods for contract usage - can be used for\n * creating a reference to already deployed contracts\n * @category contract\n * @param options - Options object\n * @returns JS Contract API\n * @example\n * ```js\n * const contractIns = await aeSdk.initializeContract({ sourceCode })\n * await contractIns.$deploy([321]) or await contractIns.init(321)\n * const callResult = await contractIns.$call('setState', [123])\n * const staticCallResult = await contractIns.$call('setState', [123], { callStatic: true })\n * ```\n * Also you can call contract like: `await contractIns.setState(123, options)`\n * Then sdk decide to make on-chain or static call (dry-run API) transaction based on function is\n * stateful or not\n */\nclass Contract {\n  /**\n   * Compile contract\n   * @returns bytecode\n   */\n  async $compile() {\n    if (this.$options.bytecode != null) return this.$options.bytecode;\n    if (this.$options.onCompiler == null) throw new IllegalArgumentError('Can\\'t compile without compiler');\n    if (this.$options.sourceCode != null) {\n      const {\n        bytecode\n      } = await this.$options.onCompiler.compileBySourceCode(this.$options.sourceCode, this.$options.fileSystem);\n      this.$options.bytecode = bytecode;\n    }\n    if (this.$options.sourceCodePath != null) {\n      const {\n        bytecode\n      } = await this.$options.onCompiler.compile(this.$options.sourceCodePath);\n      this.$options.bytecode = bytecode;\n    }\n    if (this.$options.bytecode == null) {\n      throw new IllegalArgumentError('Can\\'t compile without sourceCode and sourceCodePath');\n    }\n    return this.$options.bytecode;\n  }\n  async $getCallResultByTxHash(hash, fnName, options) {\n    const {\n      callInfo\n    } = await this.$options.onNode.getTransactionInfoByHash(hash);\n    if (callInfo == null) {\n      throw new ContractError(`callInfo is not available for transaction ${hash}`);\n    }\n    const callInfoTyped = callInfo;\n    return {\n      ..._classPrivateMethodGet(this, _getCallResult, _getCallResult2).call(this, callInfoTyped, fnName, undefined, options),\n      result: callInfoTyped\n    };\n  }\n  async _estimateGas(name, params) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      result\n    } = await this.$call(name, params, {\n      ...options,\n      callStatic: true\n    });\n    if (result == null) throw new UnexpectedTsError();\n    const {\n      gasUsed\n    } = result;\n    // taken from https://github.com/aeternity/aepp-sdk-js/issues/1286#issuecomment-977814771\n    return Math.floor(gasUsed * 1.25);\n  }\n\n  /**\n   * Deploy contract\n   * @param params - Contract init function arguments array\n   * @param options - Options\n   * @returns deploy info\n   */\n  async $deploy(params, options) {\n    var _opt$gasLimit, _other$result;\n    const {\n      callStatic,\n      ...opt\n    } = {\n      ...this.$options,\n      ...options\n    };\n    if (this.$options.bytecode == null) await this.$compile();\n    if (callStatic === true) return this.$call('init', params, {\n      ...opt,\n      callStatic\n    });\n    if (this.$options.address != null) throw new DuplicateContractError();\n    if (opt.onAccount == null) throw new IllegalArgumentError('Can\\'t deploy without account');\n    const ownerId = opt.onAccount.address;\n    if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\\'t deploy without bytecode');\n    const tx = await buildTxAsync({\n      ...opt,\n      tag: Tag.ContractCreateTx,\n      gasLimit: (_opt$gasLimit = opt.gasLimit) !== null && _opt$gasLimit !== void 0 ? _opt$gasLimit : await this._estimateGas('init', params, opt),\n      callData: this._calldata.encode(this._name, 'init', params),\n      code: this.$options.bytecode,\n      ownerId\n    });\n    const {\n      hash,\n      ...other\n    } = await _classPrivateMethodGet(this, _sendAndProcess, _sendAndProcess2).call(this, tx, 'init', {\n      ...opt,\n      onAccount: opt.onAccount\n    });\n    this.$options.address = buildContractIdByContractTx(tx);\n    return {\n      ...other,\n      ...(((_other$result = other.result) === null || _other$result === void 0 ? void 0 : _other$result.log) != null && {\n        decodedEvents: this.$decodeEvents(other.result.log, opt)\n      }),\n      owner: ownerId,\n      transaction: hash,\n      address: this.$options.address\n    };\n  }\n\n  /**\n   * Get function schema from contract ACI object\n   * @param name - Function name\n   * @returns function ACI\n   */\n\n  /**\n   * Call contract function\n   * @param fn - Function name\n   * @param params - Array of function arguments\n   * @param options - Array of function arguments\n   * @returns CallResult\n   */\n  async $call(fn, params) {\n    var _opt$gasLimit2;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      callStatic,\n      top,\n      ...opt\n    } = {\n      ...this.$options,\n      ...options\n    };\n    const fnAci = _classPrivateMethodGet(this, _getFunctionAci, _getFunctionAci2).call(this, fn);\n    const contractId = this.$options.address;\n    const {\n      onNode\n    } = opt;\n    if (fn == null) throw new MissingFunctionNameError();\n    if (fn === 'init' && callStatic !== true) throw new InvalidMethodInvocationError('\"init\" can be called only via dryRun');\n    if (fn !== 'init' && opt.amount != null && Number(opt.amount) > 0 && !fnAci.payable) {\n      throw new NotPayableFunctionError(opt.amount, fn);\n    }\n    let callerId;\n    try {\n      if (opt.onAccount == null) throw new InternalError('Use fallback account');\n      callerId = opt.onAccount.address;\n    } catch (error) {\n      const useFallbackAccount = callStatic === true && (error instanceof _TypeError && error.message === 'Account should be an address (ak-prefixed string), or instance of AccountBase, got undefined instead' || error instanceof NoWalletConnectedError || error instanceof InternalError && error.message === 'Use fallback account');\n      if (!useFallbackAccount) throw error;\n      callerId = DRY_RUN_ACCOUNT.pub;\n    }\n    const callData = this._calldata.encode(this._name, fn, params);\n    if (callStatic === true) {\n      if (opt.nonce == null) {\n        const topOption = top != null && {\n          [typeof top === 'number' ? 'height' : 'hash']: top\n        };\n        const account = await getAccount(callerId, {\n          ...topOption,\n          onNode\n        }).catch(error => {\n          if (!isAccountNotFoundError(error)) throw error;\n          return {\n            kind: 'basic',\n            nonce: 0\n          };\n        });\n        opt.nonce = account.kind === 'generalized' ? 0 : account.nonce + 1;\n      }\n      const txOpt = {\n        ...opt,\n        onNode,\n        callData\n      };\n      let tx;\n      if (fn === 'init') {\n        if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\\'t dry-run \"init\" without bytecode');\n        tx = await buildTxAsync({\n          ...txOpt,\n          tag: Tag.ContractCreateTx,\n          code: this.$options.bytecode,\n          ownerId: callerId\n        });\n      } else {\n        if (contractId == null) throw new MissingContractAddressError('Can\\'t dry-run contract without address');\n        tx = await buildTxAsync({\n          ...txOpt,\n          tag: Tag.ContractCallTx,\n          callerId,\n          contractId\n        });\n      }\n      const {\n        callObj,\n        ...dryRunOther\n      } = await txDryRun(tx, callerId, {\n        ...opt,\n        top\n      });\n      if (callObj == null) {\n        throw new InternalError(`callObj is not available for transaction ${tx}`);\n      }\n      const callInfoTyped = callObj;\n      return {\n        ...dryRunOther,\n        ..._classPrivateMethodGet(this, _getCallResult, _getCallResult2).call(this, callInfoTyped, fn, tx, opt),\n        tx: unpackTx(tx),\n        result: callInfoTyped,\n        rawTx: tx,\n        hash: buildTxHash(tx),\n        txData: undefined\n      };\n    }\n    if (top != null) throw new IllegalArgumentError('Can\\'t handle `top` option in on-chain contract call');\n    if (contractId == null) throw new MissingContractAddressError('Can\\'t call contract without address');\n    const tx = await buildTxAsync({\n      ...opt,\n      tag: Tag.ContractCallTx,\n      gasLimit: (_opt$gasLimit2 = opt.gasLimit) !== null && _opt$gasLimit2 !== void 0 ? _opt$gasLimit2 : await this._estimateGas(fn, params, opt),\n      callerId,\n      contractId,\n      callData\n    });\n    if (opt.onAccount == null) throw new IllegalArgumentError('Can\\'t call contract on chain without account');\n    return _classPrivateMethodGet(this, _sendAndProcess, _sendAndProcess2).call(this, tx, fn, {\n      ...opt,\n      onAccount: opt.onAccount\n    });\n  }\n\n  /**\n   * @param ctAddress - Contract address that emitted event\n   * @param nameHash - Hash of emitted event name\n   * @param options - Options\n   * @returns Contract name\n   * @throws {@link MissingEventDefinitionError}\n   * @throws {@link AmbiguousEventDefinitionError}\n   */\n\n  /**\n   * Decode Events\n   * @param events - Array of encoded events (callRes.result.log)\n   * @param options - Options\n   * @returns DecodedEvents\n   */\n  $decodeEvents(events) {\n    let {\n      omitUnknown,\n      ...opt\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return events.map(event => {\n      const topics = event.topics.map(t => BigInt(t));\n      let contractName;\n      try {\n        contractName = _classPrivateMethodGet(this, _getContractNameByEvent, _getContractNameByEvent2).call(this, event.address, topics[0], opt);\n      } catch (error) {\n        if ((omitUnknown !== null && omitUnknown !== void 0 ? omitUnknown : false) && error instanceof MissingEventDefinitionError) return null;\n        throw error;\n      }\n      const decoded = this._calldata.decodeEvent(contractName, event.data, topics);\n      const [name, args] = Object.entries(decoded)[0];\n      return {\n        name,\n        args,\n        contract: {\n          name: contractName,\n          address: event.address\n        }\n      };\n    }).filter(e => e != null);\n  }\n  static async initialize(_ref) {\n    let {\n      onCompiler,\n      onNode,\n      bytecode,\n      aci,\n      address,\n      sourceCodePath,\n      sourceCode,\n      fileSystem,\n      validateBytecode,\n      ...otherOptions\n    } = _ref;\n    if (aci == null && onCompiler != null) {\n      let res;\n      if (sourceCodePath != null) res = await onCompiler.compile(sourceCodePath);\n      if (sourceCode != null) res = await onCompiler.compileBySourceCode(sourceCode, fileSystem);\n      if (res != null) {\n        var _bytecode;\n        aci = res.aci;\n        (_bytecode = bytecode) !== null && _bytecode !== void 0 ? _bytecode : bytecode = res.bytecode;\n      }\n    }\n    if (aci == null) throw new MissingContractDefError();\n    if (address != null) {\n      address = await resolveName(address, 'contract_pubkey', {\n        resolveByNode: true,\n        onNode\n      });\n    }\n    if (address == null && sourceCode == null && sourceCodePath == null && bytecode == null) {\n      throw new MissingContractAddressError('Can\\'t create instance by ACI without address');\n    }\n    if (address != null) {\n      const contract = await getContract(address, {\n        onNode\n      });\n      if (contract.active == null) throw new InactiveContractError(address);\n    }\n    if (validateBytecode === true) {\n      if (address == null) throw new MissingContractAddressError('Can\\'t validate bytecode without contract address');\n      const onChanBytecode = (await getContractByteCode(address, {\n        onNode\n      })).bytecode;\n      let isValid = false;\n      if (bytecode != null) isValid = bytecode === onChanBytecode;else if (sourceCode != null) {\n        if (onCompiler == null) throw new IllegalArgumentError('Can\\'t validate bytecode without compiler');\n        isValid = await onCompiler.validateBySourceCode(onChanBytecode, sourceCode, fileSystem);\n      } else if (sourceCodePath != null) {\n        if (onCompiler == null) throw new IllegalArgumentError('Can\\'t validate bytecode without compiler');\n        isValid = await onCompiler.validate(onChanBytecode, sourceCodePath);\n      }\n      if (!isValid) {\n        throw new BytecodeMismatchError((sourceCode !== null && sourceCode !== void 0 ? sourceCode : sourceCodePath) != null ? 'source code' : 'bytecode');\n      }\n    }\n    return new ContractWithMethods({\n      onCompiler,\n      onNode,\n      sourceCode,\n      sourceCodePath,\n      bytecode,\n      aci,\n      address,\n      fileSystem,\n      ...otherOptions\n    });\n  }\n  constructor(_ref2) {\n    var _this = this;\n    let {\n      aci,\n      ...otherOptions\n    } = _ref2;\n    _classPrivateMethodInitSpec(this, _getContractNameByEvent);\n    _classPrivateMethodInitSpec(this, _getFunctionAci);\n    _classPrivateMethodInitSpec(this, _sendAndProcess);\n    _classPrivateMethodInitSpec(this, _getCallResult);\n    _classPrivateFieldInitSpec(this, _aciContract, {\n      writable: true,\n      value: void 0\n    });\n    this._aci = aci;\n    const aciLast = aci[aci.length - 1];\n    if (aciLast.contract == null) {\n      throw new IllegalArgumentError(`The last 'aci' item should have 'contract' key, got ${Object.keys(aciLast)} keys instead`);\n    }\n    _classPrivateFieldSet(this, _aciContract, aciLast.contract);\n    this._name = _classPrivateFieldGet(this, _aciContract).name;\n    this._calldata = new Calldata(aci);\n    this.$options = otherOptions;\n\n    /**\n     * Generate proto function based on contract function using Contract ACI schema\n     * All function can be called like:\n     * ```js\n     * await contract.testFunction()\n     * ```\n     * then sdk will decide to use dry-run or send tx\n     * on-chain base on if function stateful or not.\n     * Also, you can manually do that:\n     * ```js\n     * await contract.testFunction({ callStatic: true }) // use call-static (dry-run)\n     * await contract.testFunction({ callStatic: false }) // send tx on-chain\n     * ```\n     */\n    Object.assign(this, Object.fromEntries(_classPrivateFieldGet(this, _aciContract).functions.map(_ref3 => {\n      let {\n        name,\n        arguments: aciArgs,\n        stateful\n      } = _ref3;\n      const callStatic = name !== 'init' && !stateful;\n      return [name, async function () {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const options = args.length === aciArgs.length + 1 ? args.pop() : {};\n        if (typeof options !== 'object') throw new _TypeError(`Options should be an object: ${options}`);\n        if (name === 'init') return _this.$deploy(args, {\n          callStatic,\n          ...options\n        });\n        return _this.$call(name, args, {\n          callStatic,\n          ...options\n        });\n      }];\n    })));\n  }\n}\nfunction _getCallResult2(_ref4, fnName, transaction, options) {\n  let {\n    returnType,\n    returnValue,\n    log\n  } = _ref4;\n  let message;\n  switch (returnType) {\n    case 'ok':\n      {\n        const fnAci = _classPrivateMethodGet(this, _getFunctionAci, _getFunctionAci2).call(this, fnName);\n        return {\n          decodedResult: this._calldata.decode(this._name, fnAci.name, returnValue),\n          decodedEvents: this.$decodeEvents(log, options)\n        };\n      }\n    case 'revert':\n      message = this._calldata.decodeFateString(returnValue);\n      break;\n    case 'error':\n      message = decode(returnValue).toString();\n      break;\n    default:\n      throw new InternalError(`Unknown return type: ${returnType}`);\n  }\n  throw new NodeInvocationError(message, transaction);\n}\nasync function _sendAndProcess2(tx, fnName, options) {\n  const txData = await sendTransaction(tx, {\n    ...this.$options,\n    ...options\n  });\n  return {\n    hash: txData.hash,\n    tx: unpackTx(txData.rawTx),\n    txData,\n    rawTx: txData.rawTx,\n    ...(txData.blockHeight != null && (await this.$getCallResultByTxHash(txData.hash, fnName, options)))\n  };\n}\nfunction _getFunctionAci2(name) {\n  const fn = _classPrivateFieldGet(this, _aciContract).functions.find(f => f.name === name);\n  if (fn != null) {\n    return fn;\n  }\n  if (name === 'init') {\n    return {\n      arguments: [],\n      name: 'init',\n      payable: false,\n      returns: 'unit',\n      stateful: true\n    };\n  }\n  throw new NoSuchContractFunctionError(`Function ${name} doesn't exist in contract`);\n}\nfunction _getContractNameByEvent2(ctAddress, nameHash, _ref5) {\n  let {\n    contractAddressToName\n  } = _ref5;\n  const addressToName = {\n    ...this.$options.contractAddressToName,\n    ...contractAddressToName\n  };\n  if (addressToName[ctAddress] != null) return addressToName[ctAddress];\n\n  // TODO: consider using a third-party library\n  const isEqual = (a, b) => JSON.stringify(a) === JSON.stringify(b);\n  const contracts = this._aci.map(_ref6 => {\n    let {\n      contract\n    } = _ref6;\n    return contract;\n  }).filter(contract => contract === null || contract === void 0 ? void 0 : contract.event);\n  const matchedEvents = contracts.map(contract => [contract.name, contract.event.variant]).map(_ref7 => {\n    let [name, events] = _ref7;\n    return events.map(event => [name, Object.keys(event)[0], Object.values(event)[0]]);\n  }).flat().filter(_ref8 => {\n    let [, eventName] = _ref8;\n    return BigInt(`0x${calcHash(eventName).toString('hex')}`) === nameHash;\n  }).filter((_ref9, idx, arr) => {\n    let [,, type] = _ref9;\n    return !arr.slice(0, idx).some(el => isEqual(el[2], type));\n  });\n  switch (matchedEvents.length) {\n    case 0:\n      throw new MissingEventDefinitionError(nameHash.toString(), ctAddress);\n    case 1:\n      return matchedEvents[0][0];\n    default:\n      throw new AmbiguousEventDefinitionError(ctAddress, matchedEvents);\n  }\n}\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nconst ContractWithMethods = Contract;\nexport default ContractWithMethods;","map":{"version":3,"names":["_aeternityAeppCalldata","Encoder","Calldata","DRY_RUN_ACCOUNT","Tag","buildContractIdByContractTx","unpackTx","buildTxAsync","buildTxHash","decode","MissingContractDefError","MissingContractAddressError","InactiveContractError","BytecodeMismatchError","DuplicateContractError","MissingFunctionNameError","InvalidMethodInvocationError","NotPayableFunctionError","TypeError","_TypeError","NodeInvocationError","IllegalArgumentError","NoSuchContractFunctionError","MissingEventDefinitionError","AmbiguousEventDefinitionError","UnexpectedTsError","InternalError","NoWalletConnectedError","ContractError","hash","calcHash","getAccount","getContract","getContractByteCode","resolveName","txDryRun","sendTransaction","isAccountNotFoundError","_getCallResult","WeakSet","_sendAndProcess","_getFunctionAci","_getContractNameByEvent","_aciContract","WeakMap","Contract","$compile","$options","bytecode","onCompiler","sourceCode","compileBySourceCode","fileSystem","sourceCodePath","compile","$getCallResultByTxHash","fnName","options","callInfo","onNode","getTransactionInfoByHash","callInfoTyped","_classPrivateMethodGet","_getCallResult2","call","undefined","result","_estimateGas","name","params","arguments","length","$call","callStatic","gasUsed","Math","floor","$deploy","_opt$gasLimit","_other$result","opt","address","onAccount","ownerId","tx","tag","ContractCreateTx","gasLimit","callData","_calldata","encode","_name","code","other","_sendAndProcess2","log","decodedEvents","$decodeEvents","owner","transaction","fn","_opt$gasLimit2","top","fnAci","_getFunctionAci2","contractId","amount","Number","payable","callerId","error","useFallbackAccount","message","pub","nonce","topOption","account","catch","kind","txOpt","ContractCallTx","callObj","dryRunOther","rawTx","txData","events","omitUnknown","map","event","topics","t","BigInt","contractName","_getContractNameByEvent2","decoded","decodeEvent","data","args","Object","entries","contract","filter","e","initialize","_ref","aci","validateBytecode","otherOptions","res","_bytecode","resolveByNode","active","onChanBytecode","isValid","validateBySourceCode","validate","ContractWithMethods","constructor","_ref2","_this","_classPrivateMethodInitSpec","_classPrivateFieldInitSpec","writable","value","_aci","aciLast","keys","_classPrivateFieldSet","_classPrivateFieldGet","assign","fromEntries","functions","_ref3","aciArgs","stateful","_len","Array","_key","pop","_ref4","returnType","returnValue","decodedResult","decodeFateString","toString","blockHeight","find","f","returns","ctAddress","nameHash","_ref5","contractAddressToName","addressToName","isEqual","a","b","JSON","stringify","contracts","_ref6","matchedEvents","variant","_ref7","values","flat","_ref8","eventName","_ref9","idx","arr","type","slice","some","el"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\contract\\Contract.ts"],"sourcesContent":["/**\n * Contract module - routines to interact with the Ã¦ternity contract\n *\n * High level documentation of the contracts are available at\n * https://github.com/aeternity/protocol/tree/master/contracts and\n */\n\nimport { Encoder as Calldata } from '@aeternity/aepp-calldata';\nimport { DRY_RUN_ACCOUNT } from '../tx/builder/schema';\nimport { Tag, AensName } from '../tx/builder/constants';\nimport {\n  buildContractIdByContractTx, unpackTx, buildTxAsync, BuildTxOptions, buildTxHash,\n} from '../tx/builder';\nimport { decode, Encoded } from '../utils/encoder';\nimport {\n  MissingContractDefError,\n  MissingContractAddressError,\n  InactiveContractError,\n  BytecodeMismatchError,\n  DuplicateContractError,\n  MissingFunctionNameError,\n  InvalidMethodInvocationError,\n  NotPayableFunctionError,\n  TypeError,\n  NodeInvocationError,\n  IllegalArgumentError,\n  NoSuchContractFunctionError,\n  MissingEventDefinitionError,\n  AmbiguousEventDefinitionError,\n  UnexpectedTsError,\n  InternalError,\n  NoWalletConnectedError,\n  ContractError,\n} from '../utils/errors';\nimport { hash as calcHash } from '../utils/crypto';\nimport {\n  ContractCallObject as NodeContractCallObject, Event as NodeEvent,\n} from '../apis/node';\nimport CompilerBase, { Aci } from './compiler/Base';\nimport Node, { TransformNodeType } from '../Node';\nimport {\n  getAccount, getContract, getContractByteCode, resolveName, txDryRun, sendTransaction,\n  SendTransactionOptions,\n} from '../chain';\nimport AccountBase from '../account/Base';\nimport { TxUnpacked } from '../tx/builder/schema.generated';\nimport { isAccountNotFoundError } from '../utils/other';\n\ntype ContractAci = NonNullable<Aci[0]['contract']>;\ntype FunctionAci = ContractAci['functions'][0];\n\ninterface Event extends NodeEvent {\n  address: Encoded.ContractAddress;\n  data: Encoded.ContractBytearray;\n}\n\nexport interface ContractCallObject extends TransformNodeType<NodeContractCallObject> {\n  returnValue: Encoded.ContractBytearray;\n  log: Event[];\n}\n\ninterface DecodedEvent {\n  name: string;\n  args: unknown[];\n  contract: {\n    name: string;\n    address: Encoded.ContractAddress;\n  };\n}\n\ntype TxData = Awaited<ReturnType<typeof sendTransaction>>;\n\ninterface SendAndProcessReturnType {\n  result?: ContractCallObject;\n  hash: TxData['hash'];\n  tx: TxUnpacked & { tag: Tag.SignedTx | Tag.ContractCallTx | Tag.ContractCreateTx };\n  txData: TxData;\n  rawTx: Encoded.Transaction;\n}\n\nexport interface ContractMethodsBase { [key: string]: (...args: any[]) => any }\n\ntype MethodsToContractApi<M extends ContractMethodsBase> = {\n  [Name in keyof M]:\n  M[Name] extends (...args: infer Args) => any\n    ? (...args: [\n      ...Args,\n      ...[] | [Name extends 'init'\n        ? Parameters<Contract<M>['$deploy']>[1] : Parameters<Contract<M>['$call']>[2]],\n    ]) => ReturnType<Contract<M>['$call']>\n    : never\n};\n\ntype ContractWithMethods<M extends ContractMethodsBase> = Contract<M> & MethodsToContractApi<M>;\n\ntype MethodNames<M extends ContractMethodsBase> = keyof M & string | 'init';\n\ntype MethodParameters<M extends ContractMethodsBase, Fn extends MethodNames<M>> =\n  Fn extends 'init'\n    ? M extends { init: any } ? Parameters<M['init']> : []\n    : Parameters<M[Fn]>;\n\ninterface GetContractNameByEventOptions {\n  contractAddressToName?: { [key: Encoded.ContractAddress]: string };\n}\n\ninterface GetCallResultByHashReturnType<M extends ContractMethodsBase, Fn extends MethodNames<M>> {\n  decodedResult: ReturnType<M[Fn]>;\n  decodedEvents?: ReturnType<Contract<M>['$decodeEvents']>;\n}\n\n/**\n * Generate contract ACI object with predefined js methods for contract usage - can be used for\n * creating a reference to already deployed contracts\n * @category contract\n * @param options - Options object\n * @returns JS Contract API\n * @example\n * ```js\n * const contractIns = await aeSdk.initializeContract({ sourceCode })\n * await contractIns.$deploy([321]) or await contractIns.init(321)\n * const callResult = await contractIns.$call('setState', [123])\n * const staticCallResult = await contractIns.$call('setState', [123], { callStatic: true })\n * ```\n * Also you can call contract like: `await contractIns.setState(123, options)`\n * Then sdk decide to make on-chain or static call (dry-run API) transaction based on function is\n * stateful or not\n */\nclass Contract<M extends ContractMethodsBase> {\n  /**\n   * Compile contract\n   * @returns bytecode\n   */\n  async $compile(): Promise<Encoded.ContractBytearray> {\n    if (this.$options.bytecode != null) return this.$options.bytecode;\n    if (this.$options.onCompiler == null) throw new IllegalArgumentError('Can\\'t compile without compiler');\n    if (this.$options.sourceCode != null) {\n      const { bytecode } = await this.$options.onCompiler\n        .compileBySourceCode(this.$options.sourceCode, this.$options.fileSystem);\n      this.$options.bytecode = bytecode;\n    }\n    if (this.$options.sourceCodePath != null) {\n      const { bytecode } = await this.$options.onCompiler.compile(this.$options.sourceCodePath);\n      this.$options.bytecode = bytecode;\n    }\n    if (this.$options.bytecode == null) {\n      throw new IllegalArgumentError('Can\\'t compile without sourceCode and sourceCodePath');\n    }\n    return this.$options.bytecode;\n  }\n\n  #getCallResult<Fn extends MethodNames<M>>(\n    { returnType, returnValue, log }: ContractCallObject,\n    fnName: Fn,\n    transaction: Encoded.Transaction | undefined,\n    options: Parameters<Contract<M>['$decodeEvents']>[1],\n  ): GetCallResultByHashReturnType<M, Fn> {\n    let message: string;\n    switch (returnType) {\n      case 'ok': {\n        const fnAci = this.#getFunctionAci(fnName);\n        return {\n          decodedResult: this._calldata.decode(this._name, fnAci.name, returnValue),\n          decodedEvents: this.$decodeEvents(log, options),\n        };\n      }\n      case 'revert':\n        message = this._calldata.decodeFateString(returnValue);\n        break;\n      case 'error':\n        message = decode(returnValue).toString();\n        break;\n      default:\n        throw new InternalError(`Unknown return type: ${returnType}`);\n    }\n    throw new NodeInvocationError(message, transaction);\n  }\n\n  async #sendAndProcess<Fn extends MethodNames<M>>(\n    tx: Encoded.Transaction,\n    fnName: Fn,\n    options: SendTransactionOptions & Parameters<Contract<M>['$getCallResultByTxHash']>[2],\n  ): Promise<SendAndProcessReturnType & Partial<GetCallResultByHashReturnType<M, Fn>>> {\n    const txData = await sendTransaction(tx, { ...this.$options, ...options });\n    return {\n      hash: txData.hash,\n      tx: unpackTx<Tag.ContractCallTx | Tag.ContractCreateTx>(txData.rawTx),\n      txData,\n      rawTx: txData.rawTx,\n      ...txData.blockHeight != null && (\n        await this.$getCallResultByTxHash(txData.hash, fnName, options)\n      ),\n    };\n  }\n\n  async $getCallResultByTxHash<Fn extends MethodNames<M>>(\n    hash: Encoded.TxHash,\n    fnName: Fn,\n    options?: Parameters<Contract<M>['$decodeEvents']>[1],\n  ): Promise<GetCallResultByHashReturnType<M, Fn> & { result: ContractCallObject }> {\n    const { callInfo } = await this.$options.onNode.getTransactionInfoByHash(hash);\n    if (callInfo == null) {\n      throw new ContractError(`callInfo is not available for transaction ${hash}`);\n    }\n    const callInfoTyped = callInfo as ContractCallObject;\n    return {\n      ...this.#getCallResult(callInfoTyped, fnName, undefined, options),\n      result: callInfoTyped,\n    };\n  }\n\n  async _estimateGas<Fn extends MethodNames<M>>(\n    name: Fn,\n    params: MethodParameters<M, Fn>,\n    options: Omit<Parameters<Contract<M>['$call']>[2], 'callStatic'> = {},\n  ): Promise<number> {\n    const { result } = await this.$call(name, params, { ...options, callStatic: true });\n    if (result == null) throw new UnexpectedTsError();\n    const { gasUsed } = result;\n    // taken from https://github.com/aeternity/aepp-sdk-js/issues/1286#issuecomment-977814771\n    return Math.floor(gasUsed * 1.25);\n  }\n\n  /**\n   * Deploy contract\n   * @param params - Contract init function arguments array\n   * @param options - Options\n   * @returns deploy info\n   */\n  async $deploy(\n    params: MethodParameters<M, 'init'>,\n    options?: Parameters<Contract<M>['$call']>[2]\n    & Partial<BuildTxOptions<Tag.ContractCreateTx, 'ownerId' | 'code' | 'callData'>>,\n  ): Promise<Omit<SendAndProcessReturnType, 'hash'> & {\n      transaction?: Encoded.TxHash;\n      owner?: Encoded.AccountAddress;\n      address?: Encoded.ContractAddress;\n      decodedEvents?: ReturnType<Contract<M>['$decodeEvents']>;\n    }> {\n    const { callStatic, ...opt } = { ...this.$options, ...options };\n    if (this.$options.bytecode == null) await this.$compile();\n    if (callStatic === true) return this.$call('init', params, { ...opt, callStatic });\n    if (this.$options.address != null) throw new DuplicateContractError();\n\n    if (opt.onAccount == null) throw new IllegalArgumentError('Can\\'t deploy without account');\n    const ownerId = opt.onAccount.address;\n    if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\\'t deploy without bytecode');\n    const tx = await buildTxAsync({\n      ...opt,\n      tag: Tag.ContractCreateTx,\n      gasLimit: opt.gasLimit ?? await this._estimateGas('init', params, opt),\n      callData: this._calldata.encode(this._name, 'init', params),\n      code: this.$options.bytecode,\n      ownerId,\n    });\n    const { hash, ...other } = await this.#sendAndProcess(\n      tx,\n      'init',\n      { ...opt, onAccount: opt.onAccount },\n    );\n    this.$options.address = buildContractIdByContractTx(tx);\n    return {\n      ...other,\n      ...other.result?.log != null && {\n        decodedEvents: this.$decodeEvents(other.result.log, opt),\n      },\n      owner: ownerId,\n      transaction: hash,\n      address: this.$options.address,\n    };\n  }\n\n  /**\n   * Get function schema from contract ACI object\n   * @param name - Function name\n   * @returns function ACI\n   */\n  #getFunctionAci(name: string): FunctionAci {\n    const fn = this.#aciContract.functions.find(\n      (f: { name: string }) => f.name === name,\n    );\n    if (fn != null) {\n      return fn;\n    }\n    if (name === 'init') {\n      return {\n        arguments: [], name: 'init', payable: false, returns: 'unit', stateful: true,\n      };\n    }\n    throw new NoSuchContractFunctionError(`Function ${name} doesn't exist in contract`);\n  }\n\n  /**\n   * Call contract function\n   * @param fn - Function name\n   * @param params - Array of function arguments\n   * @param options - Array of function arguments\n   * @returns CallResult\n   */\n  async $call<Fn extends MethodNames<M>>(\n    fn: Fn,\n    params: MethodParameters<M, Fn>,\n    options: Partial<BuildTxOptions<Tag.ContractCallTx, 'callerId' | 'contractId' | 'callData'>>\n    & Parameters<Contract<M>['$decodeEvents']>[1]\n    & Omit<SendTransactionOptions, 'onAccount' | 'onNode'>\n    & Omit<Parameters<typeof txDryRun>[2], 'onNode'>\n    & { onAccount?: AccountBase; onNode?: Node; callStatic?: boolean } = {},\n  ): Promise<SendAndProcessReturnType & Partial<GetCallResultByHashReturnType<M, Fn>>> {\n    const { callStatic, top, ...opt } = { ...this.$options, ...options };\n    const fnAci = this.#getFunctionAci(fn);\n    const contractId = this.$options.address;\n    const { onNode } = opt;\n\n    if (fn == null) throw new MissingFunctionNameError();\n    if (fn === 'init' && callStatic !== true) throw new InvalidMethodInvocationError('\"init\" can be called only via dryRun');\n    if (fn !== 'init' && opt.amount != null && Number(opt.amount) > 0 && !fnAci.payable) {\n      throw new NotPayableFunctionError(opt.amount, fn);\n    }\n\n    let callerId;\n    try {\n      if (opt.onAccount == null) throw new InternalError('Use fallback account');\n      callerId = opt.onAccount.address;\n    } catch (error) {\n      const useFallbackAccount = callStatic === true && (\n        (error instanceof TypeError && error.message === 'Account should be an address (ak-prefixed string), or instance of AccountBase, got undefined instead')\n        || (error instanceof NoWalletConnectedError)\n        || (error instanceof InternalError && error.message === 'Use fallback account')\n      );\n      if (!useFallbackAccount) throw error;\n      callerId = DRY_RUN_ACCOUNT.pub;\n    }\n    const callData = this._calldata.encode(this._name, fn, params);\n\n    if (callStatic === true) {\n      if (opt.nonce == null) {\n        const topOption = top != null && { [typeof top === 'number' ? 'height' : 'hash']: top };\n        const account = await getAccount(callerId, { ...topOption, onNode }).catch((error) => {\n          if (!isAccountNotFoundError(error)) throw error;\n          return { kind: 'basic', nonce: 0 };\n        });\n        opt.nonce = account.kind === 'generalized' ? 0 : account.nonce + 1;\n      }\n\n      const txOpt = { ...opt, onNode, callData };\n      let tx;\n      if (fn === 'init') {\n        if (this.$options.bytecode == null) throw new IllegalArgumentError('Can\\'t dry-run \"init\" without bytecode');\n        tx = await buildTxAsync({\n          ...txOpt, tag: Tag.ContractCreateTx, code: this.$options.bytecode, ownerId: callerId,\n        });\n      } else {\n        if (contractId == null) throw new MissingContractAddressError('Can\\'t dry-run contract without address');\n        tx = await buildTxAsync({\n          ...txOpt, tag: Tag.ContractCallTx, callerId, contractId,\n        });\n      }\n\n      const { callObj, ...dryRunOther } = await txDryRun(tx, callerId, { ...opt, top });\n      if (callObj == null) {\n        throw new InternalError(`callObj is not available for transaction ${tx}`);\n      }\n      const callInfoTyped = callObj as ContractCallObject;\n      return {\n        ...dryRunOther,\n        ...this.#getCallResult(callInfoTyped, fn, tx, opt),\n        tx: unpackTx(tx),\n        result: callInfoTyped,\n        rawTx: tx,\n        hash: buildTxHash(tx),\n        txData: undefined as any,\n      };\n    }\n\n    if (top != null) throw new IllegalArgumentError('Can\\'t handle `top` option in on-chain contract call');\n    if (contractId == null) throw new MissingContractAddressError('Can\\'t call contract without address');\n    const tx = await buildTxAsync({\n      ...opt,\n      tag: Tag.ContractCallTx,\n      gasLimit: opt.gasLimit ?? await this._estimateGas(fn, params, opt),\n      callerId,\n      contractId,\n      callData,\n    });\n    if (opt.onAccount == null) throw new IllegalArgumentError('Can\\'t call contract on chain without account');\n    return this.#sendAndProcess(tx, fn, { ...opt, onAccount: opt.onAccount });\n  }\n\n  /**\n   * @param ctAddress - Contract address that emitted event\n   * @param nameHash - Hash of emitted event name\n   * @param options - Options\n   * @returns Contract name\n   * @throws {@link MissingEventDefinitionError}\n   * @throws {@link AmbiguousEventDefinitionError}\n   */\n  #getContractNameByEvent(\n    ctAddress: Encoded.ContractAddress,\n    nameHash: BigInt,\n    { contractAddressToName }: GetContractNameByEventOptions,\n  ): string {\n    const addressToName = { ...this.$options.contractAddressToName, ...contractAddressToName };\n    if (addressToName[ctAddress] != null) return addressToName[ctAddress];\n\n    // TODO: consider using a third-party library\n    const isEqual = (a: any, b: any): boolean => JSON.stringify(a) === JSON.stringify(b);\n\n    const contracts = this._aci\n      .map(({ contract }) => contract)\n      .filter((contract) => contract?.event) as ContractAci[];\n    const matchedEvents = contracts\n      .map((contract) => [contract.name, contract.event.variant])\n      .map(([name, events]) => events.map((event: {}) => (\n        [name, Object.keys(event)[0], Object.values(event)[0]]\n      )))\n      .flat()\n      .filter(([, eventName]) => BigInt(`0x${calcHash(eventName).toString('hex')}`) === nameHash)\n      .filter(([, , type], idx, arr) => !arr.slice(0, idx).some((el) => isEqual(el[2], type)));\n    switch (matchedEvents.length) {\n      case 0: throw new MissingEventDefinitionError(nameHash.toString(), ctAddress);\n      case 1: return matchedEvents[0][0];\n      default: throw new AmbiguousEventDefinitionError(ctAddress, matchedEvents);\n    }\n  }\n\n  /**\n   * Decode Events\n   * @param events - Array of encoded events (callRes.result.log)\n   * @param options - Options\n   * @returns DecodedEvents\n   */\n  $decodeEvents(\n    events: Event[],\n    { omitUnknown, ...opt }: { omitUnknown?: boolean } & GetContractNameByEventOptions = {},\n  ): DecodedEvent[] {\n    return events\n      .map((event) => {\n        const topics = event.topics.map((t: string | number) => BigInt(t));\n        let contractName;\n        try {\n          contractName = this.#getContractNameByEvent(event.address, topics[0], opt);\n        } catch (error) {\n          if ((omitUnknown ?? false) && error instanceof MissingEventDefinitionError) return null;\n          throw error;\n        }\n        const decoded = this._calldata.decodeEvent(contractName, event.data, topics);\n        const [name, args] = Object.entries(decoded)[0];\n        return {\n          name,\n          args,\n          contract: {\n            name: contractName,\n            address: event.address,\n          },\n        };\n      }).filter((e: DecodedEvent | null): e is DecodedEvent => e != null);\n  }\n\n  static async initialize<M extends ContractMethodsBase>(\n    {\n      onCompiler,\n      onNode,\n      bytecode,\n      aci,\n      address,\n      sourceCodePath,\n      sourceCode,\n      fileSystem,\n      validateBytecode,\n      ...otherOptions\n    }: Omit<ConstructorParameters<typeof Contract>[0], 'aci' | 'address'> & {\n      validateBytecode?: boolean;\n      aci?: Aci;\n      address?: Encoded.ContractAddress | AensName;\n    },\n  ): Promise<ContractWithMethods<M>> {\n    if (aci == null && onCompiler != null) {\n      let res;\n      if (sourceCodePath != null) res = await onCompiler.compile(sourceCodePath);\n      if (sourceCode != null) res = await onCompiler.compileBySourceCode(sourceCode, fileSystem);\n      if (res != null) {\n        aci = res.aci;\n        bytecode ??= res.bytecode;\n      }\n    }\n    if (aci == null) throw new MissingContractDefError();\n\n    if (address != null) {\n      address = await resolveName(\n        address,\n        'contract_pubkey',\n        { resolveByNode: true, onNode },\n      ) as Encoded.ContractAddress;\n    }\n\n    if (address == null && sourceCode == null && sourceCodePath == null && bytecode == null) {\n      throw new MissingContractAddressError('Can\\'t create instance by ACI without address');\n    }\n\n    if (address != null) {\n      const contract = await getContract(address, { onNode });\n      if (contract.active == null) throw new InactiveContractError(address);\n    }\n\n    if (validateBytecode === true) {\n      if (address == null) throw new MissingContractAddressError('Can\\'t validate bytecode without contract address');\n      const onChanBytecode = (await getContractByteCode(address, { onNode })).bytecode;\n      let isValid = false;\n      if (bytecode != null) isValid = bytecode === onChanBytecode;\n      else if (sourceCode != null) {\n        if (onCompiler == null) throw new IllegalArgumentError('Can\\'t validate bytecode without compiler');\n        isValid = await onCompiler.validateBySourceCode(onChanBytecode, sourceCode, fileSystem);\n      } else if (sourceCodePath != null) {\n        if (onCompiler == null) throw new IllegalArgumentError('Can\\'t validate bytecode without compiler');\n        isValid = await onCompiler.validate(onChanBytecode, sourceCodePath);\n      }\n      if (!isValid) {\n        throw new BytecodeMismatchError((sourceCode ?? sourceCodePath) != null ? 'source code' : 'bytecode');\n      }\n    }\n\n    return new ContractWithMethods<M>({\n      onCompiler,\n      onNode,\n      sourceCode,\n      sourceCodePath,\n      bytecode,\n      aci,\n      address,\n      fileSystem,\n      ...otherOptions,\n    });\n  }\n\n  _aci: Aci;\n\n  #aciContract: ContractAci;\n\n  _name: string;\n\n  _calldata: Calldata;\n\n  $options: Omit<ConstructorParameters<typeof Contract>[0], 'aci'>;\n\n  constructor({ aci, ...otherOptions }: {\n    onCompiler?: CompilerBase;\n    onNode: Node;\n    bytecode?: Encoded.ContractBytearray;\n    aci: Aci;\n    address?: Encoded.ContractAddress;\n    sourceCodePath?: Parameters<CompilerBase['compile']>[0];\n    sourceCode?: Parameters<CompilerBase['compileBySourceCode']>[0];\n    fileSystem?: Parameters<CompilerBase['compileBySourceCode']>[1];\n  } & Parameters<Contract<M>['$deploy']>[1]) {\n    this._aci = aci;\n    const aciLast = aci[aci.length - 1];\n    if (aciLast.contract == null) {\n      throw new IllegalArgumentError(`The last 'aci' item should have 'contract' key, got ${Object.keys(aciLast)} keys instead`);\n    }\n    this.#aciContract = aciLast.contract;\n    this._name = this.#aciContract.name;\n    this._calldata = new Calldata(aci);\n    this.$options = otherOptions;\n\n    /**\n     * Generate proto function based on contract function using Contract ACI schema\n     * All function can be called like:\n     * ```js\n     * await contract.testFunction()\n     * ```\n     * then sdk will decide to use dry-run or send tx\n     * on-chain base on if function stateful or not.\n     * Also, you can manually do that:\n     * ```js\n     * await contract.testFunction({ callStatic: true }) // use call-static (dry-run)\n     * await contract.testFunction({ callStatic: false }) // send tx on-chain\n     * ```\n     */\n    Object.assign(\n      this,\n      Object.fromEntries(this.#aciContract.functions\n        .map(({ name, arguments: aciArgs, stateful }: FunctionAci) => {\n          const callStatic = name !== 'init' && !stateful;\n          return [\n            name,\n            async (...args: any) => {\n              const options = args.length === aciArgs.length + 1 ? args.pop() : {};\n              if (typeof options !== 'object') throw new TypeError(`Options should be an object: ${options}`);\n              if (name === 'init') return this.$deploy(args, { callStatic, ...options });\n              return this.$call(name, args, { callStatic, ...options });\n            },\n          ];\n        })),\n    );\n  }\n}\n\ninterface ContractWithMethodsClass {\n  new <M extends ContractMethodsBase>(\n    options: ConstructorParameters<typeof Contract>[0],\n  ): ContractWithMethods<M>;\n  initialize: typeof Contract['initialize'];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nconst ContractWithMethods: ContractWithMethodsClass = Contract as any;\n\nexport default ContractWithMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}