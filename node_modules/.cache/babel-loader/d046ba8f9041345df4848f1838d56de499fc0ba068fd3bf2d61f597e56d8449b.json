{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\nimport _defineProperty from \"@babel/runtime-corejs3/helpers/defineProperty\";\nimport { v4 as uuid } from '@aeternity/uuid';\nimport AeSdk from \"./AeSdk.mjs\";\nimport verifyTransaction from \"./tx/validator.mjs\";\nimport RpcClient from \"./aepp-wallet-communication/rpc/RpcClient.mjs\";\nimport { METHODS, RPC_STATUS, SUBSCRIPTION_TYPES, RpcInvalidTransactionError, RpcNotAuthorizeError, RpcPermissionDenyError, RpcUnsupportedProtocolError } from \"./aepp-wallet-communication/schema.mjs\";\nimport { InternalError, UnknownRpcClientError } from \"./utils/errors.mjs\";\nimport { RPC_VERSION } from \"./aepp-wallet-communication/rpc/types.mjs\";\nimport jsonBig from \"./utils/json-big.mjs\";\n/**\n * Contain functionality for aepp interaction and managing multiple aepps\n * @category aepp wallet communication\n */\nexport default class AeSdkWallet extends AeSdk {\n  /**\n   * @param options - Options\n   * @param options.name - Wallet name\n   * @param options.id - Wallet id\n   * @param options.type - Wallet type\n   * @param options.onConnection - Call-back function for incoming AEPP connection\n   * @param options.onSubscription - Call-back function for incoming AEPP account subscription\n   * @param options.onAskAccounts - Call-back function for incoming AEPP get address request\n   * @param options.onDisconnect - Call-back function for disconnect event\n   */\n  constructor(_ref) {\n    let {\n      name,\n      id,\n      type,\n      onConnection,\n      onSubscription,\n      onDisconnect,\n      onAskAccounts,\n      ...options\n    } = _ref;\n    super(options);\n    _defineProperty(this, \"_clients\", new Map());\n    this.onConnection = onConnection;\n    this.onSubscription = onSubscription;\n    this.onDisconnect = onDisconnect;\n    this.onAskAccounts = onAskAccounts;\n    this.name = name;\n    this.id = id;\n    this._type = type;\n  }\n  _getAccountsForClient(_ref2) {\n    let {\n      addressSubscription\n    } = _ref2;\n    const {\n      current,\n      connected\n    } = this.getAccounts();\n    return {\n      current: addressSubscription.has('current') || addressSubscription.has('connected') ? current : {},\n      connected: addressSubscription.has('connected') ? connected : {}\n    };\n  }\n  _pushAccountsToApps() {\n    if (this._clients == null) return;\n    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).filter(client => client.addressSubscription.size !== 0).forEach(client => client.rpc.notify(METHODS.updateAddress, this._getAccountsForClient(client)));\n  }\n  selectAccount(address) {\n    super.selectAccount(address);\n    this._pushAccountsToApps();\n  }\n  addAccount(account, options) {\n    super.addAccount(account, options);\n    this._pushAccountsToApps();\n  }\n  _getNode() {\n    this.ensureNodeConnected();\n    return {\n      node: {\n        url: this.api.$host,\n        name: this.selectedNodeName\n      }\n    };\n  }\n  async selectNode(name) {\n    super.selectNode(name);\n    const networkId = await this.api.getNetworkId();\n    Array.from(this._clients.keys()).filter(clientId => this._isRpcClientConnected(clientId)).map(clientId => this._getClient(clientId)).forEach(client => {\n      client.rpc.notify(METHODS.updateNetwork, {\n        networkId,\n        ...(client.connectNode && this._getNode())\n      });\n    });\n  }\n  _getClient(clientId) {\n    const client = this._clients.get(clientId);\n    if (client == null) throw new UnknownRpcClientError(clientId);\n    return client;\n  }\n  _isRpcClientConnected(clientId) {\n    return RPC_STATUS.CONNECTED === this._getClient(clientId).status && this._getClient(clientId).rpc.connection.isConnected();\n  }\n  _disconnectRpcClient(clientId) {\n    const client = this._getClient(clientId);\n    client.rpc.connection.disconnect();\n    client.status = RPC_STATUS.DISCONNECTED;\n    client.addressSubscription = new Set();\n  }\n\n  /**\n   * Remove specific RpcClient by ID\n   * @param id - Client ID\n   */\n  removeRpcClient(id) {\n    this._disconnectRpcClient(id);\n    this._clients.delete(id);\n  }\n\n  /**\n   * Add new client by AEPP connection\n   * @param clientConnection - AEPP connection object\n   * @returns Client ID\n   */\n  addRpcClient(clientConnection) {\n    // @TODO  detect if aepp has some history based on origin????\n    // if yes use this instance for connection\n    const id = uuid();\n    let disconnectParams;\n    const client = {\n      id,\n      status: RPC_STATUS.WAITING_FOR_CONNECTION_REQUEST,\n      addressSubscription: new Set(),\n      connectNode: false,\n      rpc: new RpcClient(clientConnection, () => {\n        this._clients.delete(id);\n        this.onDisconnect(id, disconnectParams); // also related info\n      }, {\n        [METHODS.closeConnection]: params => {\n          disconnectParams = params;\n          this._disconnectRpcClient(id);\n        },\n        // Store client info and prepare two fn for each client `connect` and `denyConnection`\n        // which automatically prepare and send response for that client\n        [METHODS.connect]: async (_ref3, origin) => {\n          let {\n            name,\n            version,\n            icons,\n            connectNode\n          } = _ref3;\n          if (version !== RPC_VERSION) throw new RpcUnsupportedProtocolError();\n          await this.onConnection(id, {\n            name,\n            icons,\n            connectNode\n          }, origin);\n          client.status = RPC_STATUS.CONNECTED;\n          client.connectNode = connectNode;\n          return {\n            ...(await this.getWalletInfo()),\n            ...(connectNode && this._getNode())\n          };\n        },\n        [METHODS.subscribeAddress]: async (_ref4, origin) => {\n          let {\n            type,\n            value\n          } = _ref4;\n          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n          switch (type) {\n            case SUBSCRIPTION_TYPES.subscribe:\n              // TODO: remove `type` as it always subscribe\n              await this.onSubscription(id, {\n                type,\n                value\n              }, origin);\n              client.addressSubscription.add(value);\n              break;\n            case SUBSCRIPTION_TYPES.unsubscribe:\n              client.addressSubscription.delete(value);\n              break;\n            default:\n              throw new InternalError(`Unknown subscription type: ${type}`);\n          }\n          return {\n            subscription: Array.from(client.addressSubscription),\n            address: this._getAccountsForClient(client)\n          };\n        },\n        [METHODS.address]: async (params, origin) => {\n          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n          await this.onAskAccounts(id, params, origin);\n          return this.addresses();\n        },\n        [METHODS.sign]: async (_ref5, origin) => {\n          let {\n            tx,\n            onAccount = this.address,\n            returnSigned,\n            innerTx\n          } = _ref5;\n          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n          if (!this.addresses().includes(onAccount)) {\n            throw new RpcPermissionDenyError(onAccount);\n          }\n          const parameters = {\n            onAccount,\n            aeppOrigin: origin,\n            aeppRpcClientId: id,\n            innerTx\n          };\n          if (returnSigned || innerTx === true) {\n            return {\n              signedTransaction: await this.signTransaction(tx, parameters)\n            };\n          }\n          try {\n            return jsonBig.parse(jsonBig.stringify({\n              transactionHash: await this.sendTransaction(tx, {\n                ...parameters,\n                verify: false\n              })\n            }));\n          } catch (error) {\n            const validation = await verifyTransaction(tx, this.api);\n            if (validation.length > 0) throw new RpcInvalidTransactionError(validation);\n            throw error;\n          }\n        },\n        [METHODS.signMessage]: async (_ref6, origin) => {\n          let {\n            message,\n            onAccount = this.address\n          } = _ref6;\n          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n          if (!this.addresses().includes(onAccount)) {\n            throw new RpcPermissionDenyError(onAccount);\n          }\n          const parameters = {\n            onAccount,\n            aeppOrigin: origin,\n            aeppRpcClientId: id\n          };\n          return {\n            signature: _Buffer.from(await this.signMessage(message, parameters)).toString('hex')\n          };\n        },\n        [METHODS.signTypedData]: async (_ref7, origin) => {\n          let {\n            domain,\n            aci,\n            data,\n            onAccount = this.address\n          } = _ref7;\n          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n          if (!this.addresses().includes(onAccount)) {\n            throw new RpcPermissionDenyError(onAccount);\n          }\n          const parameters = {\n            ...domain,\n            onAccount,\n            aeppOrigin: origin,\n            aeppRpcClientId: id\n          };\n          return {\n            signature: await this.signTypedData(data, aci, parameters)\n          };\n        },\n        [METHODS.signDelegationToContract]: async (_ref8, origin) => {\n          var _ref9, _ref10;\n          let {\n            contractAddress,\n            name,\n            oracleQueryId,\n            onAccount = this.address\n          } = _ref8;\n          if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n          if (!this.addresses().includes(onAccount)) {\n            throw new RpcPermissionDenyError(onAccount);\n          }\n          const parameters = {\n            onAccount,\n            aeppOrigin: origin,\n            aeppRpcClientId: id\n          };\n          const signature = await ((_ref9 = (_ref10 = name == null ? null : this.signNameDelegationToContract(contractAddress, name, parameters)) !== null && _ref10 !== void 0 ? _ref10 : oracleQueryId == null ? null : this.signOracleQueryDelegationToContract(contractAddress, oracleQueryId, parameters)) !== null && _ref9 !== void 0 ? _ref9 : this.signDelegationToContract(contractAddress, parameters));\n          return {\n            signature\n          };\n        }\n      })\n    };\n    this._clients.set(id, client);\n    return id;\n  }\n\n  /**\n   * Send shareWalletInfo message to notify AEPP about wallet\n   * @param clientId - ID of RPC client send message to\n   */\n  async shareWalletInfo(clientId) {\n    this._getClient(clientId).rpc.notify(METHODS.readyToConnect, await this.getWalletInfo());\n  }\n\n  /**\n   * Get Wallet info object\n   * @returns Object with wallet information\n   */\n  async getWalletInfo() {\n    return {\n      id: this.id,\n      name: this.name,\n      networkId: await this.api.getNetworkId(),\n      origin: window.location.origin,\n      type: this._type\n    };\n  }\n\n  /**\n   * Get Wallet accounts\n   * @returns Object with accounts information (\\{ connected: Object, current: Object \\})\n   */\n  getAccounts() {\n    return {\n      current: this.selectedAddress != null ? {\n        [this.selectedAddress]: {}\n      } : {},\n      connected: this.addresses().filter(a => a !== this.selectedAddress).reduce((acc, a) => ({\n        ...acc,\n        [a]: {}\n      }), {})\n    };\n  }\n}","map":{"version":3,"names":["v4","uuid","AeSdk","verifyTransaction","RpcClient","METHODS","RPC_STATUS","SUBSCRIPTION_TYPES","RpcInvalidTransactionError","RpcNotAuthorizeError","RpcPermissionDenyError","RpcUnsupportedProtocolError","InternalError","UnknownRpcClientError","RPC_VERSION","jsonBig","AeSdkWallet","constructor","_ref","name","id","type","onConnection","onSubscription","onDisconnect","onAskAccounts","options","_defineProperty","Map","_type","_getAccountsForClient","_ref2","addressSubscription","current","connected","getAccounts","has","_pushAccountsToApps","_clients","Array","from","keys","filter","clientId","_isRpcClientConnected","map","_getClient","client","size","forEach","rpc","notify","updateAddress","selectAccount","address","addAccount","account","_getNode","ensureNodeConnected","node","url","api","$host","selectedNodeName","selectNode","networkId","getNetworkId","updateNetwork","connectNode","get","CONNECTED","status","connection","isConnected","_disconnectRpcClient","disconnect","DISCONNECTED","Set","removeRpcClient","delete","addRpcClient","clientConnection","disconnectParams","WAITING_FOR_CONNECTION_REQUEST","closeConnection","params","connect","_ref3","origin","version","icons","getWalletInfo","subscribeAddress","_ref4","value","subscribe","add","unsubscribe","subscription","addresses","sign","_ref5","tx","onAccount","returnSigned","innerTx","includes","parameters","aeppOrigin","aeppRpcClientId","signedTransaction","signTransaction","parse","stringify","transactionHash","sendTransaction","verify","error","validation","length","signMessage","_ref6","message","signature","_Buffer","toString","signTypedData","_ref7","domain","aci","data","signDelegationToContract","_ref8","_ref9","_ref10","contractAddress","oracleQueryId","signNameDelegationToContract","signOracleQueryDelegationToContract","set","shareWalletInfo","readyToConnect","window","location","selectedAddress","a","reduce","acc"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\AeSdkWallet.ts"],"sourcesContent":["import { v4 as uuid } from '@aeternity/uuid';\nimport AeSdk from './AeSdk';\nimport verifyTransaction from './tx/validator';\nimport RpcClient from './aepp-wallet-communication/rpc/RpcClient';\nimport {\n  METHODS, RPC_STATUS, SUBSCRIPTION_TYPES, WALLET_TYPE,\n  RpcInvalidTransactionError,\n  RpcNotAuthorizeError, RpcPermissionDenyError, RpcUnsupportedProtocolError,\n} from './aepp-wallet-communication/schema';\nimport { InternalError, UnknownRpcClientError } from './utils/errors';\nimport AccountBase from './account/Base';\nimport BrowserConnection from './aepp-wallet-communication/connection/Browser';\nimport {\n  Accounts,\n  AeppApi,\n  Network,\n  RPC_VERSION,\n  WalletApi,\n  WalletInfo,\n} from './aepp-wallet-communication/rpc/types';\nimport { Encoded } from './utils/encoder';\nimport jsonBig from './utils/json-big';\n\ntype RpcClientWallet = RpcClient<AeppApi, WalletApi>;\n\ntype OnConnection = (\n  clientId: string, params: Omit<Parameters<WalletApi[METHODS.connect]>[0], 'version'>, origin: string\n) => void;\n\ntype OnSubscription = (\n  clientId: string, params: Parameters<WalletApi[METHODS.subscribeAddress]>[0], origin: string\n) => void;\n\ntype OnDisconnect = (\n  clientId: string, params: Parameters<WalletApi[METHODS.closeConnection]>[0]\n) => void;\n\ntype OnAskAccounts = (\n  clientId: string, params: undefined, origin: string\n) => void;\n\ninterface RpcClientsInfo {\n  id: string;\n  status: RPC_STATUS;\n  connectNode: boolean;\n  addressSubscription: Set<'connected' | 'current'>;\n  rpc: RpcClientWallet;\n}\n\n/**\n * Contain functionality for aepp interaction and managing multiple aepps\n * @category aepp wallet communication\n */\nexport default class AeSdkWallet extends AeSdk {\n  id: string;\n\n  _type: WALLET_TYPE;\n\n  name: string;\n\n  _clients = new Map<string, RpcClientsInfo>();\n\n  onConnection: OnConnection;\n\n  onSubscription: OnSubscription;\n\n  onDisconnect: OnDisconnect;\n\n  onAskAccounts: OnAskAccounts;\n\n  /**\n   * @param options - Options\n   * @param options.name - Wallet name\n   * @param options.id - Wallet id\n   * @param options.type - Wallet type\n   * @param options.onConnection - Call-back function for incoming AEPP connection\n   * @param options.onSubscription - Call-back function for incoming AEPP account subscription\n   * @param options.onAskAccounts - Call-back function for incoming AEPP get address request\n   * @param options.onDisconnect - Call-back function for disconnect event\n   */\n  constructor({\n    name,\n    id,\n    type,\n    onConnection,\n    onSubscription,\n    onDisconnect,\n    onAskAccounts,\n    ...options\n  }: {\n    id: string;\n    type: WALLET_TYPE;\n    name: string;\n    onConnection: OnConnection;\n    onSubscription: OnSubscription;\n    onDisconnect: OnDisconnect;\n    onAskAccounts: OnAskAccounts;\n  } & ConstructorParameters<typeof AeSdk>[0]) {\n    super(options);\n    this.onConnection = onConnection;\n    this.onSubscription = onSubscription;\n    this.onDisconnect = onDisconnect;\n    this.onAskAccounts = onAskAccounts;\n    this.name = name;\n    this.id = id;\n    this._type = type;\n  }\n\n  _getAccountsForClient({ addressSubscription }: RpcClientsInfo): Accounts {\n    const { current, connected } = this.getAccounts();\n    return {\n      current: addressSubscription.has('current') || addressSubscription.has('connected')\n        ? current : {},\n      connected: addressSubscription.has('connected') ? connected : {},\n    };\n  }\n\n  _pushAccountsToApps(): void {\n    if (this._clients == null) return;\n    Array.from(this._clients.keys())\n      .filter((clientId) => this._isRpcClientConnected(clientId))\n      .map((clientId) => this._getClient(clientId))\n      .filter((client) => client.addressSubscription.size !== 0)\n      .forEach((client) => client.rpc\n        .notify(METHODS.updateAddress, this._getAccountsForClient(client)));\n  }\n\n  override selectAccount(address: Encoded.AccountAddress): void {\n    super.selectAccount(address);\n    this._pushAccountsToApps();\n  }\n\n  override addAccount(account: AccountBase, options?: Parameters<AeSdk['addAccount']>[1]): void {\n    super.addAccount(account, options);\n    this._pushAccountsToApps();\n  }\n\n  _getNode(): { node: Network['node'] } {\n    this.ensureNodeConnected();\n    return { node: { url: this.api.$host, name: this.selectedNodeName } };\n  }\n\n  override async selectNode(name: string): Promise<void> {\n    super.selectNode(name);\n    const networkId = await this.api.getNetworkId();\n    Array.from(this._clients.keys())\n      .filter((clientId) => this._isRpcClientConnected(clientId))\n      .map((clientId) => this._getClient(clientId))\n      .forEach((client) => {\n        client.rpc.notify(METHODS.updateNetwork, {\n          networkId,\n          ...client.connectNode && this._getNode(),\n        });\n      });\n  }\n\n  _getClient(clientId: string): RpcClientsInfo {\n    const client = this._clients.get(clientId);\n    if (client == null) throw new UnknownRpcClientError(clientId);\n    return client;\n  }\n\n  _isRpcClientConnected(clientId: string): boolean {\n    return RPC_STATUS.CONNECTED === this._getClient(clientId).status\n      && this._getClient(clientId).rpc.connection.isConnected();\n  }\n\n  _disconnectRpcClient(clientId: string): void {\n    const client = this._getClient(clientId);\n    client.rpc.connection.disconnect();\n    client.status = RPC_STATUS.DISCONNECTED;\n    client.addressSubscription = new Set();\n  }\n\n  /**\n   * Remove specific RpcClient by ID\n   * @param id - Client ID\n   */\n  removeRpcClient(id: string): void {\n    this._disconnectRpcClient(id);\n    this._clients.delete(id);\n  }\n\n  /**\n   * Add new client by AEPP connection\n   * @param clientConnection - AEPP connection object\n   * @returns Client ID\n   */\n  addRpcClient(clientConnection: BrowserConnection): string {\n    // @TODO  detect if aepp has some history based on origin????\n    // if yes use this instance for connection\n    const id = uuid();\n    let disconnectParams: any;\n    const client: RpcClientsInfo = {\n      id,\n      status: RPC_STATUS.WAITING_FOR_CONNECTION_REQUEST,\n      addressSubscription: new Set(),\n      connectNode: false,\n      rpc: new RpcClient<AeppApi, WalletApi>(\n        clientConnection,\n        () => {\n          this._clients.delete(id);\n          this.onDisconnect(id, disconnectParams); // also related info\n        },\n        {\n          [METHODS.closeConnection]: (params) => {\n            disconnectParams = params;\n            this._disconnectRpcClient(id);\n          },\n          // Store client info and prepare two fn for each client `connect` and `denyConnection`\n          // which automatically prepare and send response for that client\n          [METHODS.connect]: async ({\n            name, version, icons, connectNode,\n          }, origin) => {\n            if (version !== RPC_VERSION) throw new RpcUnsupportedProtocolError();\n\n            await this.onConnection(id, { name, icons, connectNode }, origin);\n            client.status = RPC_STATUS.CONNECTED;\n            client.connectNode = connectNode;\n            return {\n              ...await this.getWalletInfo(),\n              ...connectNode && this._getNode(),\n            };\n          },\n          [METHODS.subscribeAddress]: async ({ type, value }, origin) => {\n            if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n\n            switch (type) {\n              case SUBSCRIPTION_TYPES.subscribe:\n                // TODO: remove `type` as it always subscribe\n                await this.onSubscription(id, { type, value }, origin);\n                client.addressSubscription.add(value);\n                break;\n              case SUBSCRIPTION_TYPES.unsubscribe:\n                client.addressSubscription.delete(value);\n                break;\n              default:\n                throw new InternalError(`Unknown subscription type: ${type}`);\n            }\n\n            return {\n              subscription: Array.from(client.addressSubscription),\n              address: this._getAccountsForClient(client),\n            };\n          },\n          [METHODS.address]: async (params, origin) => {\n            if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n            await this.onAskAccounts(id, params, origin);\n            return this.addresses();\n          },\n          [METHODS.sign]: async (\n            {\n              tx, onAccount = this.address, returnSigned, innerTx,\n            },\n            origin,\n          ) => {\n            if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n            if (!this.addresses().includes(onAccount)) {\n              throw new RpcPermissionDenyError(onAccount);\n            }\n\n            const parameters = {\n              onAccount, aeppOrigin: origin, aeppRpcClientId: id, innerTx,\n            };\n            if (returnSigned || innerTx === true) {\n              return { signedTransaction: await this.signTransaction(tx, parameters) };\n            }\n            try {\n              return jsonBig.parse(jsonBig.stringify({\n                transactionHash: await this.sendTransaction(tx, { ...parameters, verify: false }),\n              }));\n            } catch (error) {\n              const validation = await verifyTransaction(tx, this.api);\n              if (validation.length > 0) throw new RpcInvalidTransactionError(validation);\n              throw error;\n            }\n          },\n          [METHODS.signMessage]: async ({ message, onAccount = this.address }, origin) => {\n            if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n            if (!this.addresses().includes(onAccount)) {\n              throw new RpcPermissionDenyError(onAccount);\n            }\n\n            const parameters = { onAccount, aeppOrigin: origin, aeppRpcClientId: id };\n            return {\n              signature: Buffer.from(await this.signMessage(message, parameters)).toString('hex'),\n            };\n          },\n          [METHODS.signTypedData]: async ({\n            domain, aci, data, onAccount = this.address,\n          }, origin) => {\n            if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n            if (!this.addresses().includes(onAccount)) {\n              throw new RpcPermissionDenyError(onAccount);\n            }\n\n            const parameters = {\n              ...domain, onAccount, aeppOrigin: origin, aeppRpcClientId: id,\n            };\n            return {\n              signature: await this.signTypedData(data, aci, parameters),\n            };\n          },\n          [METHODS.signDelegationToContract]: async ({\n            contractAddress, name, oracleQueryId, onAccount = this.address,\n          }, origin) => {\n            if (!this._isRpcClientConnected(id)) throw new RpcNotAuthorizeError();\n            if (!this.addresses().includes(onAccount)) {\n              throw new RpcPermissionDenyError(onAccount);\n            }\n\n            const parameters = { onAccount, aeppOrigin: origin, aeppRpcClientId: id };\n            const signature = await (\n              (name == null ? null : this\n                .signNameDelegationToContract(contractAddress, name, parameters))\n              ?? (oracleQueryId == null ? null : this\n                .signOracleQueryDelegationToContract(contractAddress, oracleQueryId, parameters))\n              ?? this.signDelegationToContract(contractAddress, parameters)\n            );\n            return { signature };\n          },\n        },\n      ),\n    };\n    this._clients.set(id, client);\n    return id;\n  }\n\n  /**\n   * Send shareWalletInfo message to notify AEPP about wallet\n   * @param clientId - ID of RPC client send message to\n   */\n  async shareWalletInfo(clientId: string): Promise<void> {\n    this._getClient(clientId).rpc.notify(METHODS.readyToConnect, await this.getWalletInfo());\n  }\n\n  /**\n   * Get Wallet info object\n   * @returns Object with wallet information\n   */\n  async getWalletInfo(): Promise<WalletInfo> {\n    return {\n      id: this.id,\n      name: this.name,\n      networkId: await this.api.getNetworkId(),\n      origin: window.location.origin,\n      type: this._type,\n    };\n  }\n\n  /**\n   * Get Wallet accounts\n   * @returns Object with accounts information (\\{ connected: Object, current: Object \\})\n   */\n  getAccounts(): Accounts {\n    return {\n      current: this.selectedAddress != null ? { [this.selectedAddress]: {} } : {},\n      connected: this.addresses()\n        .filter((a) => a !== this.selectedAddress)\n        .reduce((acc, a) => ({ ...acc, [a]: {} }), {}),\n    };\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}