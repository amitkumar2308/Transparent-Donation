{"ast":null,"code":"const TypeResolveError = require('./Errors/TypeResolveError');\nconst {\n  FateTypeVoid,\n  FateTypeInt,\n  FateTypeBool,\n  FateTypeString,\n  FateTypeBits,\n  FateTypeBytes,\n  FateTypeHash,\n  FateTypeSignature,\n  FateTypeAccountAddress,\n  FateTypeContractAddress,\n  FateTypeOracleAddress,\n  FateTypeOracleQueryAddress,\n  FateTypeList,\n  FateTypeMap,\n  FateTypeTuple,\n  FateTypeRecord,\n  FateTypeSet,\n  FateTypeVariant,\n  FateTypeOption,\n  FateTypeChainTTL,\n  FateTypeChainGAMetaTx,\n  FateTypeChainPayingForTx,\n  FateTypeChainBaseTx,\n  FateTypeAENSPointee,\n  FateTypeAENSName,\n  FateTypeBls12381Fr,\n  FateTypeBls12381Fp\n} = require('./FateTypes');\nconst isObject = value => {\n  return value && typeof value === 'object' && value.constructor === Object;\n};\nclass TypeResolver {\n  isCustomType() {\n    return false;\n  }\n  resolveTypeDef(type, valueTypes) {\n    return [type, valueTypes];\n  }\n  resolveValueTypes(valueTypes, vars) {\n    if (!Array.isArray(valueTypes)) {\n      return [];\n    }\n    return valueTypes.map(v => {\n      const tpl = v.hasOwnProperty('type') ? v.type : v;\n      const t = vars.hasOwnProperty(tpl) ? vars[tpl] : tpl;\n      return this.resolveType(t, vars);\n    });\n  }\n  resolveType(type, vars = {}) {\n    let key = type;\n    let valueTypes = [];\n    let resolvedTypes = [];\n    if (isObject(type)) {\n      [[key, valueTypes]] = Object.entries(type);\n    }\n    if (this.isCustomType(key)) {\n      const [typeDef, typeVars] = this.resolveTypeDef(key, valueTypes);\n      return this.resolveType(typeDef, typeVars);\n    }\n\n    // variant value types are resolved in its own method\n    if (key !== 'variant') {\n      resolvedTypes = this.resolveValueTypes(valueTypes, vars);\n    }\n    if (key === 'void') {\n      return FateTypeVoid();\n    }\n    if (key === 'unit') {\n      return FateTypeTuple([]);\n    }\n    if (key === 'int') {\n      return FateTypeInt();\n    }\n    if (key === 'bool') {\n      return FateTypeBool();\n    }\n    if (key === 'string') {\n      return FateTypeString();\n    }\n    if (key === 'bits') {\n      return FateTypeBits();\n    }\n    if (key === 'hash') {\n      return FateTypeHash();\n    }\n    if (key === 'signature') {\n      return FateTypeSignature();\n    }\n    if (key === 'address') {\n      return FateTypeAccountAddress();\n    }\n    if (key === 'contract_pubkey') {\n      return FateTypeContractAddress();\n    }\n    if (key === 'Chain.ttl') {\n      return FateTypeChainTTL();\n    }\n    if (key === 'Chain.ga_meta_tx') {\n      return FateTypeChainGAMetaTx();\n    }\n    if (key === 'Chain.paying_for_tx') {\n      return FateTypeChainPayingForTx();\n    }\n    if (key === 'Chain.base_tx') {\n      return FateTypeChainBaseTx();\n    }\n    if (key === 'AENS.pointee') {\n      return FateTypeAENSPointee();\n    }\n    if (key === 'AENS.name') {\n      return FateTypeAENSName();\n    }\n    if (key === 'Set.set') {\n      return FateTypeSet(...resolvedTypes);\n    }\n    if (key === 'MCL_BLS12_381.fr') {\n      return FateTypeBls12381Fr();\n    }\n    if (key === 'MCL_BLS12_381.fp') {\n      return FateTypeBls12381Fp();\n    }\n    if (key === 'bytes') {\n      return FateTypeBytes(valueTypes);\n    }\n    if (key === 'list') {\n      return FateTypeList(...resolvedTypes);\n    }\n    if (key === 'map') {\n      return FateTypeMap(...resolvedTypes);\n    }\n\n    // Unbox singleton tuples and records\n    // https://github.com/aeternity/aesophia/pull/205\n    // https://github.com/aeternity/aesophia/commit/a403a9d227ac56266cf5bb8fbc916f17e6141d15\n    if ((key === 'tuple' || key === 'record') && resolvedTypes.length === 1) {\n      return resolvedTypes[0];\n    }\n    if (key === 'tuple') {\n      return FateTypeTuple(resolvedTypes);\n    }\n    if (key === 'record') {\n      const keys = valueTypes.map(e => e.name);\n      return FateTypeRecord(keys, resolvedTypes);\n    }\n    if (key === 'variant') {\n      return this.resolveVariant(valueTypes, vars);\n    }\n    if (key === 'option') {\n      return FateTypeOption(resolvedTypes);\n    }\n    if (key === 'oracle') {\n      return FateTypeOracleAddress(...resolvedTypes);\n    }\n    if (key === 'oracle_query') {\n      return FateTypeOracleQueryAddress(...resolvedTypes);\n    }\n    throw new TypeResolveError('Cannot resolve type: ' + JSON.stringify(type));\n  }\n  resolveVariant(valueTypes, vars) {\n    const variants = valueTypes.map(e => {\n      const [[variant, args]] = Object.entries(e);\n      const resolvedArgs = args.map(v => {\n        const t = vars.hasOwnProperty(v) ? vars[v] : v;\n        return this.resolveType(t, vars);\n      });\n      return {\n        [variant]: resolvedArgs\n      };\n    });\n    return FateTypeVariant(variants);\n  }\n}\nmodule.exports = TypeResolver;","map":{"version":3,"names":["TypeResolveError","require","FateTypeVoid","FateTypeInt","FateTypeBool","FateTypeString","FateTypeBits","FateTypeBytes","FateTypeHash","FateTypeSignature","FateTypeAccountAddress","FateTypeContractAddress","FateTypeOracleAddress","FateTypeOracleQueryAddress","FateTypeList","FateTypeMap","FateTypeTuple","FateTypeRecord","FateTypeSet","FateTypeVariant","FateTypeOption","FateTypeChainTTL","FateTypeChainGAMetaTx","FateTypeChainPayingForTx","FateTypeChainBaseTx","FateTypeAENSPointee","FateTypeAENSName","FateTypeBls12381Fr","FateTypeBls12381Fp","isObject","value","constructor","Object","TypeResolver","isCustomType","resolveTypeDef","type","valueTypes","resolveValueTypes","vars","Array","isArray","map","v","tpl","hasOwnProperty","t","resolveType","key","resolvedTypes","entries","typeDef","typeVars","length","keys","e","name","resolveVariant","JSON","stringify","variants","variant","args","resolvedArgs","module","exports"],"sources":["C:/Users/amitk/Desktop/Donation Project/donation-aeternity-blockchain-contract/node_modules/@aeternity/aepp-calldata/src/TypeResolver.js"],"sourcesContent":["const TypeResolveError = require('./Errors/TypeResolveError')\nconst {\n    FateTypeVoid,\n    FateTypeInt,\n    FateTypeBool,\n    FateTypeString,\n    FateTypeBits,\n    FateTypeBytes,\n    FateTypeHash,\n    FateTypeSignature,\n    FateTypeAccountAddress,\n    FateTypeContractAddress,\n    FateTypeOracleAddress,\n    FateTypeOracleQueryAddress,\n    FateTypeList,\n    FateTypeMap,\n    FateTypeTuple,\n    FateTypeRecord,\n    FateTypeSet,\n    FateTypeVariant,\n    FateTypeOption,\n    FateTypeChainTTL,\n    FateTypeChainGAMetaTx,\n    FateTypeChainPayingForTx,\n    FateTypeChainBaseTx,\n    FateTypeAENSPointee,\n    FateTypeAENSName,\n    FateTypeBls12381Fr,\n    FateTypeBls12381Fp\n} = require('./FateTypes')\n\nconst isObject = (value) => {\n    return value && typeof value === 'object' && value.constructor === Object\n}\n\nclass TypeResolver {\n    isCustomType() {\n        return false\n    }\n\n    resolveTypeDef(type, valueTypes) {\n        return [type, valueTypes]\n    }\n\n    resolveValueTypes(valueTypes, vars) {\n        if (!Array.isArray(valueTypes)) {\n            return []\n        }\n\n        return valueTypes.map(v => {\n            const tpl = v.hasOwnProperty('type') ? v.type : v\n            const t = vars.hasOwnProperty(tpl) ? vars[tpl] : tpl\n\n            return this.resolveType(t, vars)\n        })\n    }\n\n    resolveType(type, vars = {}) {\n        let key = type\n        let valueTypes = []\n        let resolvedTypes = []\n\n        if (isObject(type)) {\n            [[key, valueTypes]] = Object.entries(type)\n        }\n\n        if (this.isCustomType(key)) {\n            const [typeDef, typeVars] = this.resolveTypeDef(key, valueTypes)\n\n            return this.resolveType(typeDef, typeVars)\n        }\n\n        // variant value types are resolved in its own method\n        if (key !== 'variant') {\n            resolvedTypes = this.resolveValueTypes(valueTypes, vars)\n        }\n\n        if (key === 'void') {\n            return FateTypeVoid()\n        }\n\n        if (key === 'unit') {\n            return FateTypeTuple([])\n        }\n\n        if (key === 'int') {\n            return FateTypeInt()\n        }\n\n        if (key === 'bool') {\n            return FateTypeBool()\n        }\n\n        if (key === 'string') {\n            return FateTypeString()\n        }\n\n        if (key === 'bits') {\n            return FateTypeBits()\n        }\n\n        if (key === 'hash') {\n            return FateTypeHash()\n        }\n\n        if (key === 'signature') {\n            return FateTypeSignature()\n        }\n\n        if (key === 'address') {\n            return FateTypeAccountAddress()\n        }\n\n        if (key === 'contract_pubkey') {\n            return FateTypeContractAddress()\n        }\n\n        if (key === 'Chain.ttl') {\n            return FateTypeChainTTL()\n        }\n\n        if (key === 'Chain.ga_meta_tx') {\n            return FateTypeChainGAMetaTx()\n        }\n\n        if (key === 'Chain.paying_for_tx') {\n            return FateTypeChainPayingForTx()\n        }\n\n        if (key === 'Chain.base_tx') {\n            return FateTypeChainBaseTx()\n        }\n\n        if (key === 'AENS.pointee') {\n            return FateTypeAENSPointee()\n        }\n\n        if (key === 'AENS.name') {\n            return FateTypeAENSName()\n        }\n\n        if (key === 'Set.set') {\n            return FateTypeSet(...resolvedTypes)\n        }\n\n        if (key === 'MCL_BLS12_381.fr') {\n            return FateTypeBls12381Fr()\n        }\n\n        if (key === 'MCL_BLS12_381.fp') {\n            return FateTypeBls12381Fp()\n        }\n\n        if (key === 'bytes') {\n            return FateTypeBytes(valueTypes)\n        }\n\n        if (key === 'list') {\n            return FateTypeList(...resolvedTypes)\n        }\n\n        if (key === 'map') {\n            return FateTypeMap(...resolvedTypes)\n        }\n\n        // Unbox singleton tuples and records\n        // https://github.com/aeternity/aesophia/pull/205\n        // https://github.com/aeternity/aesophia/commit/a403a9d227ac56266cf5bb8fbc916f17e6141d15\n        if ((key === 'tuple' || key === 'record') && resolvedTypes.length === 1) {\n            return resolvedTypes[0]\n        }\n\n        if (key === 'tuple') {\n            return FateTypeTuple(resolvedTypes)\n        }\n\n        if (key === 'record') {\n            const keys = valueTypes.map(e => e.name)\n\n            return FateTypeRecord(keys, resolvedTypes)\n        }\n\n        if (key === 'variant') {\n            return this.resolveVariant(valueTypes, vars)\n        }\n\n        if (key === 'option') {\n            return FateTypeOption(resolvedTypes)\n        }\n\n        if (key === 'oracle') {\n            return FateTypeOracleAddress(...resolvedTypes)\n        }\n\n        if (key === 'oracle_query') {\n            return FateTypeOracleQueryAddress(...resolvedTypes)\n        }\n\n        throw new TypeResolveError('Cannot resolve type: ' + JSON.stringify(type))\n    }\n\n    resolveVariant(valueTypes, vars) {\n        const variants = valueTypes.map(e => {\n            const [[variant, args]] = Object.entries(e)\n            const resolvedArgs = args.map(v => {\n                const t = vars.hasOwnProperty(v) ? vars[v] : v\n                return this.resolveType(t, vars)\n            })\n\n            return {[variant]: resolvedArgs}\n        })\n\n        return FateTypeVariant(variants)\n    }\n}\n\nmodule.exports = TypeResolver\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}