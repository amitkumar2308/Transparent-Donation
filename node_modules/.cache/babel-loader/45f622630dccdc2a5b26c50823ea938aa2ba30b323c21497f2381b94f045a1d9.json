{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\nimport { RestError } from '@azure/core-rest-pipeline';\nimport { hash, verify } from \"../utils/crypto.mjs\";\nimport { ProtocolToVmAbi } from \"./builder/field-types/ct-version.mjs\";\nimport { Tag } from \"./builder/constants.mjs\";\nimport { buildTx, unpackTx } from \"./builder/index.mjs\";\nimport { concatBuffers, isAccountNotFoundError } from \"../utils/other.mjs\";\nimport { decode } from \"../utils/encoder.mjs\";\nimport Node from \"../Node.mjs\";\nimport { genAggressiveCacheGetResponsesPolicy } from \"../utils/autorest.mjs\";\nimport { UnexpectedTsError } from \"../utils/errors.mjs\";\nimport getTransactionSignerAddress from \"./transaction-signer.mjs\";\nimport { getExecutionCostUsingNode } from \"./execution-cost.mjs\";\nconst validators = [];\nasync function verifyTransactionInternal(tx, node, parentTxTypes) {\n  const address = getTransactionSignerAddress(buildTx(tx));\n  const [account, {\n    height\n  }, {\n    consensusProtocolVersion,\n    nodeNetworkId\n  }] = await Promise.all([node.getAccountByPubkey(address).catch(error => {\n    if (!isAccountNotFoundError(error)) throw error;\n    return {\n      id: address,\n      balance: 0n,\n      nonce: 0\n    };\n  })\n  // TODO: remove after fixing https://github.com/aeternity/aepp-sdk-js/issues/1537\n  .then(acc => ({\n    ...acc,\n    id: acc.id\n  })), node.getCurrentKeyBlockHeight(), node.getNodeInfo()]);\n  return (await Promise.all(validators.map(async v => v(tx, {\n    node,\n    account,\n    height,\n    consensusProtocolVersion,\n    nodeNetworkId,\n    parentTxTypes\n  })))).flat();\n}\n\n/**\n * Transaction Validator\n * This function validates some transaction properties,\n * to make sure it can be posted it to the chain\n * @category transaction builder\n * @param transaction - Base64Check-encoded transaction\n * @param nodeNotCached - Node to validate transaction against\n * @returns Array with verification errors\n * @example const errors = await verifyTransaction(transaction, node)\n */\nexport default async function verifyTransaction(transaction, nodeNotCached) {\n  const node = new Node(nodeNotCached.$host, {\n    ignoreVersion: true,\n    pipeline: nodeNotCached.pipeline.clone(),\n    additionalPolicies: [genAggressiveCacheGetResponsesPolicy()]\n  });\n  return verifyTransactionInternal(unpackTx(transaction), node, []);\n}\nvalidators.push((tx, _ref) => {\n  let {\n    account,\n    nodeNetworkId,\n    parentTxTypes\n  } = _ref;\n  if (tx.tag !== Tag.SignedTx) return [];\n  const {\n    encodedTx,\n    signatures\n  } = tx;\n  if ((encodedTx !== null && encodedTx !== void 0 ? encodedTx : signatures) == null) return [];\n  if (signatures.length !== 1) return []; // TODO: Support multisignature like in state channels\n  const prefix = _Buffer.from([nodeNetworkId, ...(parentTxTypes.includes(Tag.PayingForTx) ? ['inner_tx'] : [])].join('-'));\n  const txBinary = decode(buildTx(encodedTx));\n  const txWithNetworkId = concatBuffers([prefix, txBinary]);\n  const txHashWithNetworkId = concatBuffers([prefix, hash(txBinary)]);\n  if (verify(txWithNetworkId, signatures[0], account.id) || verify(txHashWithNetworkId, signatures[0], account.id)) return [];\n  return [{\n    message: 'Signature cannot be verified, please ensure that you transaction have' + ' the correct prefix and the correct private key for the sender address',\n    key: 'InvalidSignature',\n    checkedKeys: ['encodedTx', 'signatures']\n  }];\n}, async (tx, _ref2) => {\n  let {\n    node,\n    parentTxTypes\n  } = _ref2;\n  let nestedTx;\n  if ('encodedTx' in tx) nestedTx = tx.encodedTx;\n  if ('tx' in tx) nestedTx = tx.tx;\n  if (nestedTx == null) return [];\n  return verifyTransactionInternal(nestedTx, node, [...parentTxTypes, tx.tag]);\n}, (tx, _ref3) => {\n  let {\n    height\n  } = _ref3;\n  if (!('ttl' in tx)) return [];\n  if (tx.ttl === 0 || tx.ttl >= height) return [];\n  return [{\n    message: `TTL ${tx.ttl} is already expired, current height is ${height}`,\n    key: 'ExpiredTTL',\n    checkedKeys: ['ttl']\n  }];\n}, async (tx, _ref4) => {\n  let {\n    account,\n    parentTxTypes,\n    node\n  } = _ref4;\n  if (parentTxTypes.length !== 0) return [];\n  const cost = await getExecutionCostUsingNode(buildTx(tx), node).catch(() => 0n);\n  if (cost <= account.balance) return [];\n  return [{\n    message: `Account balance ${account.balance} is not enough to execute the transaction that costs ${cost}`,\n    key: 'InsufficientBalance',\n    checkedKeys: ['amount', 'fee', 'nameFee', 'gasLimit', 'gasPrice']\n  }];\n}, (tx, _ref5) => {\n  let {\n    account\n  } = _ref5;\n  let message;\n  if (tx.tag === Tag.SignedTx && account.kind === 'generalized' && tx.signatures.length !== 0) {\n    message = 'Generalized account can\\'t be used to generate SignedTx with signatures';\n  }\n  if (tx.tag === Tag.GaMetaTx && account.kind === 'basic') {\n    message = 'Basic account can\\'t be used to generate GaMetaTx';\n  }\n  if (message == null) return [];\n  return [{\n    message,\n    key: 'InvalidAccountType',\n    checkedKeys: ['tag']\n  }];\n},\n// TODO: revert nonce check\n// TODO: ensure nonce valid when paying for own tx\n(tx, _ref6) => {\n  var _ref7, _ref8;\n  let {\n    consensusProtocolVersion\n  } = _ref6;\n  const oracleCall = Tag.Oracle === tx.tag || Tag.OracleRegisterTx === tx.tag;\n  const contractCreate = Tag.ContractCreateTx === tx.tag || Tag.GaAttachTx === tx.tag;\n  const contractCall = Tag.ContractCallTx === tx.tag || Tag.GaMetaTx === tx.tag;\n  const type = (_ref7 = (_ref8 = oracleCall ? 'oracle-call' : null) !== null && _ref8 !== void 0 ? _ref8 : contractCreate ? 'contract-create' : null) !== null && _ref7 !== void 0 ? _ref7 : contractCall ? 'contract-call' : null;\n  if (type == null) return [];\n  const protocol = ProtocolToVmAbi[consensusProtocolVersion][type];\n  let ctVersion;\n  if ('abiVersion' in tx) ctVersion = {\n    abiVersion: tx.abiVersion\n  };\n  if ('ctVersion' in tx) ctVersion = tx.ctVersion;\n  if (ctVersion == null) throw new UnexpectedTsError();\n  if (!protocol.abiVersion.includes(ctVersion.abiVersion) || contractCreate && !protocol.vmVersion.includes(ctVersion.vmVersion)) {\n    return [{\n      message: `ABI/VM version ${JSON.stringify(ctVersion)} is wrong, supported is: ${JSON.stringify(protocol)}`,\n      key: 'VmAndAbiVersionMismatch',\n      checkedKeys: ['ctVersion', 'abiVersion']\n    }];\n  }\n  return [];\n}, async (tx, _ref9) => {\n  let {\n    node\n  } = _ref9;\n  if (Tag.ContractCallTx !== tx.tag) return [];\n  try {\n    const {\n      active\n    } = await node.getContract(tx.contractId);\n    if (active) return [];\n    return [{\n      message: `Contract ${tx.contractId} is not active`,\n      key: 'ContractNotActive',\n      checkedKeys: ['contractId']\n    }];\n  } catch (error) {\n    var _error$response;\n    if (!(error instanceof RestError) || ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.bodyAsText) == null) throw error;\n    return [{\n      message: JSON.parse(error.response.bodyAsText).reason,\n      // TODO: use parsedBody instead\n      key: 'ContractNotFound',\n      checkedKeys: ['contractId']\n    }];\n  }\n});","map":{"version":3,"names":["RestError","hash","verify","ProtocolToVmAbi","Tag","buildTx","unpackTx","concatBuffers","isAccountNotFoundError","decode","Node","genAggressiveCacheGetResponsesPolicy","UnexpectedTsError","getTransactionSignerAddress","getExecutionCostUsingNode","validators","verifyTransactionInternal","tx","node","parentTxTypes","address","account","height","consensusProtocolVersion","nodeNetworkId","Promise","all","getAccountByPubkey","catch","error","id","balance","nonce","then","acc","getCurrentKeyBlockHeight","getNodeInfo","map","v","flat","verifyTransaction","transaction","nodeNotCached","$host","ignoreVersion","pipeline","clone","additionalPolicies","push","_ref","tag","SignedTx","encodedTx","signatures","length","prefix","_Buffer","from","includes","PayingForTx","join","txBinary","txWithNetworkId","txHashWithNetworkId","message","key","checkedKeys","_ref2","nestedTx","_ref3","ttl","_ref4","cost","_ref5","kind","GaMetaTx","_ref6","_ref7","_ref8","oracleCall","Oracle","OracleRegisterTx","contractCreate","ContractCreateTx","GaAttachTx","contractCall","ContractCallTx","type","protocol","ctVersion","abiVersion","vmVersion","JSON","stringify","_ref9","active","getContract","contractId","_error$response","response","bodyAsText","parse","reason"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\tx\\validator.ts"],"sourcesContent":["import { RestError } from '@azure/core-rest-pipeline';\nimport { hash, verify } from '../utils/crypto';\nimport { TxUnpacked } from './builder/schema.generated';\nimport { CtVersion, ProtocolToVmAbi } from './builder/field-types/ct-version';\nimport { Tag, ConsensusProtocolVersion } from './builder/constants';\nimport { buildTx, unpackTx } from './builder';\nimport { concatBuffers, isAccountNotFoundError } from '../utils/other';\nimport { Encoded, decode } from '../utils/encoder';\nimport Node, { TransformNodeType } from '../Node';\nimport { Account } from '../apis/node';\nimport { genAggressiveCacheGetResponsesPolicy } from '../utils/autorest';\nimport { UnexpectedTsError } from '../utils/errors';\nimport getTransactionSignerAddress from './transaction-signer';\nimport { getExecutionCostUsingNode } from './execution-cost';\n\nexport interface ValidatorResult {\n  message: string;\n  key: string;\n  checkedKeys: string[];\n}\n\ntype Validator = (\n  tx: TxUnpacked,\n  options: {\n    // TODO: remove after fixing node types\n    account: TransformNodeType<Account> & { id: Encoded.AccountAddress };\n    nodeNetworkId: string;\n    parentTxTypes: Tag[];\n    node: Node;\n    height: number;\n    consensusProtocolVersion: ConsensusProtocolVersion;\n  }\n) => ValidatorResult[] | Promise<ValidatorResult[]>;\n\nconst validators: Validator[] = [];\n\nasync function verifyTransactionInternal(\n  tx: TxUnpacked,\n  node: Node,\n  parentTxTypes: Tag[],\n): Promise<ValidatorResult[]> {\n  const address = getTransactionSignerAddress(buildTx(tx));\n  const [account, { height }, { consensusProtocolVersion, nodeNetworkId }] = await Promise.all([\n    node.getAccountByPubkey(address)\n      .catch((error) => {\n        if (!isAccountNotFoundError(error)) throw error;\n        return { id: address, balance: 0n, nonce: 0 };\n      })\n      // TODO: remove after fixing https://github.com/aeternity/aepp-sdk-js/issues/1537\n      .then((acc) => ({ ...acc, id: acc.id as Encoded.AccountAddress })),\n    node.getCurrentKeyBlockHeight(),\n    node.getNodeInfo(),\n  ]);\n\n  return (await Promise.all(\n    validators.map(async (v) => v(\n      tx,\n      {\n        node, account, height, consensusProtocolVersion, nodeNetworkId, parentTxTypes,\n      },\n    )),\n  )).flat();\n}\n\n/**\n * Transaction Validator\n * This function validates some transaction properties,\n * to make sure it can be posted it to the chain\n * @category transaction builder\n * @param transaction - Base64Check-encoded transaction\n * @param nodeNotCached - Node to validate transaction against\n * @returns Array with verification errors\n * @example const errors = await verifyTransaction(transaction, node)\n */\nexport default async function verifyTransaction(\n  transaction: Parameters<typeof unpackTx>[0],\n  nodeNotCached: Node,\n): Promise<ValidatorResult[]> {\n  const node = new Node(nodeNotCached.$host, {\n    ignoreVersion: true,\n    pipeline: nodeNotCached.pipeline.clone(),\n    additionalPolicies: [genAggressiveCacheGetResponsesPolicy()],\n  });\n  return verifyTransactionInternal(unpackTx(transaction), node, []);\n}\n\nvalidators.push(\n  (tx, { account, nodeNetworkId, parentTxTypes }) => {\n    if (tx.tag !== Tag.SignedTx) return [];\n    const { encodedTx, signatures } = tx;\n    if ((encodedTx ?? signatures) == null) return [];\n    if (signatures.length !== 1) return []; // TODO: Support multisignature like in state channels\n    const prefix = Buffer.from([\n      nodeNetworkId,\n      ...parentTxTypes.includes(Tag.PayingForTx) ? ['inner_tx'] : [],\n    ].join('-'));\n    const txBinary = decode(buildTx(encodedTx));\n    const txWithNetworkId = concatBuffers([prefix, txBinary]);\n    const txHashWithNetworkId = concatBuffers([prefix, hash(txBinary)]);\n    if (verify(txWithNetworkId, signatures[0], account.id)\n      || verify(txHashWithNetworkId, signatures[0], account.id)) return [];\n    return [{\n      message: 'Signature cannot be verified, please ensure that you transaction have'\n        + ' the correct prefix and the correct private key for the sender address',\n      key: 'InvalidSignature',\n      checkedKeys: ['encodedTx', 'signatures'],\n    }];\n  },\n  async (tx, { node, parentTxTypes }) => {\n    let nestedTx;\n    if ('encodedTx' in tx) nestedTx = tx.encodedTx;\n    if ('tx' in tx) nestedTx = tx.tx;\n    if (nestedTx == null) return [];\n    return verifyTransactionInternal(nestedTx, node, [...parentTxTypes, tx.tag]);\n  },\n  (tx, { height }) => {\n    if (!('ttl' in tx)) return [];\n    if (tx.ttl === 0 || tx.ttl >= height) return [];\n    return [{\n      message: `TTL ${tx.ttl} is already expired, current height is ${height}`,\n      key: 'ExpiredTTL',\n      checkedKeys: ['ttl'],\n    }];\n  },\n  async (tx, { account, parentTxTypes, node }) => {\n    if (parentTxTypes.length !== 0) return [];\n    const cost = await getExecutionCostUsingNode(buildTx(tx), node).catch(() => 0n);\n    if (cost <= account.balance) return [];\n    return [{\n      message: `Account balance ${account.balance} is not enough to execute the transaction that costs ${cost}`,\n      key: 'InsufficientBalance',\n      checkedKeys: ['amount', 'fee', 'nameFee', 'gasLimit', 'gasPrice'],\n    }];\n  },\n  (tx, { account }) => {\n    let message;\n    if (tx.tag === Tag.SignedTx && account.kind === 'generalized' && tx.signatures.length !== 0) {\n      message = 'Generalized account can\\'t be used to generate SignedTx with signatures';\n    }\n    if (tx.tag === Tag.GaMetaTx && account.kind === 'basic') {\n      message = 'Basic account can\\'t be used to generate GaMetaTx';\n    }\n    if (message == null) return [];\n    return [{ message, key: 'InvalidAccountType', checkedKeys: ['tag'] }];\n  },\n  // TODO: revert nonce check\n  // TODO: ensure nonce valid when paying for own tx\n  (tx, { consensusProtocolVersion }) => {\n    const oracleCall = Tag.Oracle === tx.tag || Tag.OracleRegisterTx === tx.tag;\n    const contractCreate = Tag.ContractCreateTx === tx.tag || Tag.GaAttachTx === tx.tag;\n    const contractCall = Tag.ContractCallTx === tx.tag || Tag.GaMetaTx === tx.tag;\n    const type = (oracleCall ? 'oracle-call' : null)\n      ?? (contractCreate ? 'contract-create' : null)\n      ?? (contractCall ? 'contract-call' : null);\n    if (type == null) return [];\n    const protocol = ProtocolToVmAbi[consensusProtocolVersion][type] as {\n      abiVersion: readonly any[];\n      vmVersion: readonly any[];\n    };\n\n    let ctVersion: Partial<CtVersion> | undefined;\n    if ('abiVersion' in tx) ctVersion = { abiVersion: tx.abiVersion };\n    if ('ctVersion' in tx) ctVersion = tx.ctVersion;\n    if (ctVersion == null) throw new UnexpectedTsError();\n    if (\n      !protocol.abiVersion.includes(ctVersion.abiVersion)\n      || (contractCreate && !protocol.vmVersion.includes(ctVersion.vmVersion))\n    ) {\n      return [{\n        message: `ABI/VM version ${JSON.stringify(ctVersion)} is wrong, supported is: ${JSON.stringify(protocol)}`,\n        key: 'VmAndAbiVersionMismatch',\n        checkedKeys: ['ctVersion', 'abiVersion'],\n      }];\n    }\n    return [];\n  },\n  async (tx, { node }) => {\n    if (Tag.ContractCallTx !== tx.tag) return [];\n    try {\n      const { active } = await node.getContract(tx.contractId);\n      if (active) return [];\n      return [{\n        message: `Contract ${tx.contractId} is not active`,\n        key: 'ContractNotActive',\n        checkedKeys: ['contractId'],\n      }];\n    } catch (error) {\n      if (!(error instanceof RestError) || error.response?.bodyAsText == null) throw error;\n      return [{\n        message: JSON.parse(error.response.bodyAsText).reason, // TODO: use parsedBody instead\n        key: 'ContractNotFound',\n        checkedKeys: ['contractId'],\n      }];\n    }\n  },\n);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}