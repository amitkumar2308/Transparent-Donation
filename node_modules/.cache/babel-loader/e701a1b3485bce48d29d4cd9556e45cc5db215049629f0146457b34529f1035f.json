{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\nimport AccountLedger, { CLA, GET_ADDRESS, GET_APP_CONFIGURATION } from \"./Ledger.mjs\";\nimport { UnsupportedVersionError } from \"../utils/errors.mjs\";\nimport semverSatisfies from \"../utils/semver-satisfies.mjs\";\n/**\n * A factory class that generates instances of AccountLedger based on provided transport.\n */\nexport default class AccountLedgerFactory {\n  /**\n   * @param transport - Connection to Ledger to use\n   */\n  constructor(transport) {\n    this.transport = transport;\n    this.versionCheckPromise = this.getAppConfiguration().then(_ref => {\n      let {\n        version\n      } = _ref;\n      const args = [version, '0.4.4', '0.5.0'];\n      if (!semverSatisfies(...args)) throw new UnsupportedVersionError('app on ledger', ...args);\n    });\n    const scrambleKey = 'w0w';\n    transport.decorateAppAPIMethods(this, ['getAddress', 'getAppConfiguration'], scrambleKey);\n  }\n\n  /**\n   * @returns the version of app installed on Ledger wallet\n   */\n  async getAppConfiguration() {\n    await this.versionCheckPromise;\n    const response = await this.transport.send(CLA, GET_APP_CONFIGURATION, 0x00, 0x00);\n    return {\n      version: [response[1], response[2], response[3]].join('.')\n    };\n  }\n\n  /**\n   * Get `ak_`-prefixed address for a given account index.\n   * @param accountIndex - Index of account\n   * @param verify - Ask user to confirm address by showing it on the device screen\n   */\n  async getAddress(accountIndex) {\n    let verify = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    await this.versionCheckPromise;\n    const buffer = _Buffer.alloc(4);\n    buffer.writeUInt32BE(accountIndex, 0);\n    const response = await this.transport.send(CLA, GET_ADDRESS, verify ? 0x01 : 0x00, 0x00, buffer);\n    const addressLength = response[0];\n    return response.subarray(1, 1 + addressLength).toString('ascii');\n  }\n\n  /**\n   * Get an instance of AccountLedger for a given account index.\n   * @param accountIndex - Index of account\n   */\n  async initialize(accountIndex) {\n    await this.versionCheckPromise;\n    return new AccountLedger(this.transport, accountIndex, await this.getAddress(accountIndex));\n  }\n\n  /**\n   * Discovers accounts on Ledger that already have been used (has any on-chain transactions).\n   * It returns an empty array if none of accounts been used.\n   * If a used account is preceded by an unused account then it would be ignored.\n   * @param node - Instance of Node to get account information from\n   */\n  async discover(node) {\n    let index = 0;\n    const result = [];\n    let account;\n    do {\n      if (account != null) result.push(account);\n      account = await this.initialize(index);\n      index += 1;\n    } while (await node.getAccountByPubkey(account.address).then(() => true, () => false));\n    return result;\n  }\n}","map":{"version":3,"names":["AccountLedger","CLA","GET_ADDRESS","GET_APP_CONFIGURATION","UnsupportedVersionError","semverSatisfies","AccountLedgerFactory","constructor","transport","versionCheckPromise","getAppConfiguration","then","_ref","version","args","scrambleKey","decorateAppAPIMethods","response","send","join","getAddress","accountIndex","verify","arguments","length","undefined","buffer","_Buffer","alloc","writeUInt32BE","addressLength","subarray","toString","initialize","discover","node","index","result","account","push","getAccountByPubkey","address"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\account\\LedgerFactory.ts"],"sourcesContent":["import type Transport from '@ledgerhq/hw-transport';\nimport AccountLedger, { CLA, GET_ADDRESS, GET_APP_CONFIGURATION } from './Ledger';\nimport { UnsupportedVersionError } from '../utils/errors';\nimport { Encoded } from '../utils/encoder';\nimport semverSatisfies from '../utils/semver-satisfies';\nimport Node from '../Node';\n\n/**\n * A factory class that generates instances of AccountLedger based on provided transport.\n */\nexport default class AccountLedgerFactory {\n  readonly transport: Transport;\n\n  private readonly versionCheckPromise: Promise<void>;\n\n  /**\n   * @param transport - Connection to Ledger to use\n   */\n  constructor(transport: Transport) {\n    this.transport = transport;\n    this.versionCheckPromise = this.getAppConfiguration().then(({ version }) => {\n      const args = [version, '0.4.4', '0.5.0'] as const;\n      if (!semverSatisfies(...args)) throw new UnsupportedVersionError('app on ledger', ...args);\n    });\n    const scrambleKey = 'w0w';\n    transport.decorateAppAPIMethods(this, ['getAddress', 'getAppConfiguration'], scrambleKey);\n  }\n\n  /**\n   * @returns the version of app installed on Ledger wallet\n   */\n  async getAppConfiguration(): Promise<{ version: string }> {\n    await this.versionCheckPromise;\n    const response = await this.transport.send(CLA, GET_APP_CONFIGURATION, 0x00, 0x00);\n    return {\n      version: [response[1], response[2], response[3]].join('.'),\n    };\n  }\n\n  /**\n   * Get `ak_`-prefixed address for a given account index.\n   * @param accountIndex - Index of account\n   * @param verify - Ask user to confirm address by showing it on the device screen\n   */\n  async getAddress(accountIndex: number, verify = false): Promise<Encoded.AccountAddress> {\n    await this.versionCheckPromise;\n    const buffer = Buffer.alloc(4);\n    buffer.writeUInt32BE(accountIndex, 0);\n    const response = await this.transport.send(\n      CLA,\n      GET_ADDRESS,\n      verify ? 0x01 : 0x00,\n      0x00,\n      buffer,\n    );\n    const addressLength = response[0];\n    return response.subarray(1, 1 + addressLength).toString('ascii') as Encoded.AccountAddress;\n  }\n\n  /**\n   * Get an instance of AccountLedger for a given account index.\n   * @param accountIndex - Index of account\n   */\n  async initialize(accountIndex: number): Promise<AccountLedger> {\n    await this.versionCheckPromise;\n    return new AccountLedger(this.transport, accountIndex, await this.getAddress(accountIndex));\n  }\n\n  /**\n   * Discovers accounts on Ledger that already have been used (has any on-chain transactions).\n   * It returns an empty array if none of accounts been used.\n   * If a used account is preceded by an unused account then it would be ignored.\n   * @param node - Instance of Node to get account information from\n   */\n  async discover(node: Node): Promise<AccountLedger[]> {\n    let index = 0;\n    const result = [];\n    let account;\n    do {\n      if (account != null) result.push(account);\n      account = await this.initialize(index);\n      index += 1;\n    } while (await node.getAccountByPubkey(account.address).then(() => true, () => false));\n    return result;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}