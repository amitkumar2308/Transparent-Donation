{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\nimport _bs from 'bs58';\n// js extension is required for mjs build, not importing the whole package to reduce bundle size\n// eslint-disable-next-line import/extensions\nconst {\n  encode: bs58Encode,\n  decode: bs58Decode\n} = _bs;\nimport Sha256 from 'sha.js/sha256.js';\nimport { DecodeError, ArgumentError, InvalidChecksumError, PayloadLengthError } from \"./errors.mjs\";\nimport { concatBuffers, isKeyOfObject } from \"./other.mjs\";\nimport * as Encoded from \"./encoder-types.mjs\";\nimport { Encoding } from \"./encoder-types.mjs\";\nexport { Encoded, Encoding };\n\n/**\n * Calculate SHA256 hash of `input`\n * @param input - Data to hash\n * @returns Hash\n */\nexport function sha256hash(input) {\n  return new Sha256().update(input).digest();\n}\n\n/**\n * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L177-L202}\n */\nconst base64Types = [Encoding.ContractBytearray, Encoding.ContractStoreKey, Encoding.ContractStoreValue, Encoding.Transaction, Encoding.OracleQuery, Encoding.OracleResponse, Encoding.State, Encoding.Poi, Encoding.StateTrees, Encoding.CallStateTree, Encoding.Bytearray];\nconst base58Types = [Encoding.KeyBlockHash, Encoding.MicroBlockHash, Encoding.BlockPofHash, Encoding.BlockTxHash, Encoding.BlockStateHash, Encoding.Channel, Encoding.ContractAddress, Encoding.TxHash, Encoding.OracleAddress, Encoding.OracleQueryId, Encoding.AccountAddress, Encoding.Signature, Encoding.Commitment, Encoding.PeerPubkey, Encoding.Name];\n\n/**\n * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L261-L286}\n */\nconst byteSizeForType = {\n  [Encoding.KeyBlockHash]: 32,\n  [Encoding.MicroBlockHash]: 32,\n  [Encoding.BlockPofHash]: 32,\n  [Encoding.BlockTxHash]: 32,\n  [Encoding.BlockStateHash]: 32,\n  [Encoding.Channel]: 32,\n  [Encoding.ContractAddress]: 32,\n  [Encoding.TxHash]: 32,\n  [Encoding.OracleAddress]: 32,\n  [Encoding.OracleQueryId]: 32,\n  [Encoding.AccountAddress]: 32,\n  [Encoding.Signature]: 64,\n  [Encoding.Commitment]: 32,\n  [Encoding.PeerPubkey]: 32,\n  [Encoding.State]: 32\n};\nfunction ensureValidLength(data, type) {\n  if (!isKeyOfObject(type, byteSizeForType)) return;\n  const reqLen = byteSizeForType[type];\n  if (reqLen == null || data.length === reqLen) return;\n  throw new PayloadLengthError(`Payload should be ${reqLen} bytes, got ${data.length} instead`);\n}\nconst getChecksum = payload => sha256hash(sha256hash(payload)).slice(0, 4);\nconst addChecksum = payload => concatBuffers([payload, getChecksum(payload)]);\nfunction getPayload(buffer) {\n  const payload = buffer.slice(0, -4);\n  if (!getChecksum(payload).equals(buffer.slice(-4))) throw new InvalidChecksumError();\n  return payload;\n}\nconst base64 = {\n  encode: buffer => addChecksum(buffer).toString('base64'),\n  decode: string => getPayload(_Buffer.from(string, 'base64'))\n};\nconst base58 = {\n  encode: buffer => bs58Encode(addChecksum(buffer)),\n  decode: string => getPayload(_Buffer.from(bs58Decode(string)))\n};\nconst parseType = maybeType => {\n  const base64Type = base64Types.find(t => t === maybeType);\n  if (base64Type != null) return [base64Type, base64];\n  const base58Type = base58Types.find(t => t === maybeType);\n  if (base58Type != null) return [base58Type, base58];\n  throw new ArgumentError('prefix', `one of ${[...base58Types, ...base64Types].join(', ')}`, maybeType);\n};\n\n/**\n * Decode data using the default encoding/decoding algorithm\n * @param data - An Base58/64check encoded and prefixed string\n * (ex tx_..., sg_..., ak_....)\n * @returns Decoded data\n */\nexport function decode(data) {\n  const [prefix, encodedPayload, extra] = data.split('_');\n  if (encodedPayload == null) throw new DecodeError(`Encoded string missing payload: ${data}`);\n  if (extra != null) throw new DecodeError(`Encoded string have extra parts: ${data}`);\n  const [type, encoder] = parseType(prefix);\n  const payload = encoder.decode(encodedPayload);\n  ensureValidLength(payload, type);\n  return payload;\n}\n\n/**\n * Encode data using the default encoding/decoding algorithm\n * @param data - An decoded data\n * @param type - Prefix of Transaction\n * @returns Encoded string Base58check or Base64check data\n */\nexport function encode(data, type) {\n  const [, encoder] = parseType(type);\n  ensureValidLength(data, type);\n  return `${type}_${encoder.encode(data)}`;\n}","map":{"version":3,"names":["_bs","encode","bs58Encode","decode","bs58Decode","Sha256","DecodeError","ArgumentError","InvalidChecksumError","PayloadLengthError","concatBuffers","isKeyOfObject","Encoded","Encoding","sha256hash","input","update","digest","base64Types","ContractBytearray","ContractStoreKey","ContractStoreValue","Transaction","OracleQuery","OracleResponse","State","Poi","StateTrees","CallStateTree","Bytearray","base58Types","KeyBlockHash","MicroBlockHash","BlockPofHash","BlockTxHash","BlockStateHash","Channel","ContractAddress","TxHash","OracleAddress","OracleQueryId","AccountAddress","Signature","Commitment","PeerPubkey","Name","byteSizeForType","ensureValidLength","data","type","reqLen","length","getChecksum","payload","slice","addChecksum","getPayload","buffer","equals","base64","toString","string","_Buffer","from","base58","parseType","maybeType","base64Type","find","t","base58Type","join","prefix","encodedPayload","extra","split","encoder"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\utils\\encoder.ts"],"sourcesContent":["import { encode as bs58Encode, decode as bs58Decode } from 'bs58';\n// js extension is required for mjs build, not importing the whole package to reduce bundle size\n// eslint-disable-next-line import/extensions\nimport Sha256 from 'sha.js/sha256.js';\nimport {\n  DecodeError,\n  ArgumentError,\n  InvalidChecksumError,\n  PayloadLengthError,\n} from './errors';\nimport { concatBuffers, isKeyOfObject } from './other';\nimport * as Encoded from './encoder-types';\nimport { Encoding } from './encoder-types';\n\nexport { Encoded, Encoding };\n\n/**\n * Calculate SHA256 hash of `input`\n * @param input - Data to hash\n * @returns Hash\n */\nexport function sha256hash(input: Uint8Array | string): Buffer {\n  return new Sha256().update(input).digest();\n}\n\n/**\n * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L177-L202}\n */\nconst base64Types = [\n  Encoding.ContractBytearray,\n  Encoding.ContractStoreKey,\n  Encoding.ContractStoreValue,\n  Encoding.Transaction,\n  Encoding.OracleQuery,\n  Encoding.OracleResponse,\n  Encoding.State,\n  Encoding.Poi,\n  Encoding.StateTrees,\n  Encoding.CallStateTree,\n  Encoding.Bytearray,\n] as const;\nconst base58Types = [\n  Encoding.KeyBlockHash,\n  Encoding.MicroBlockHash,\n  Encoding.BlockPofHash,\n  Encoding.BlockTxHash,\n  Encoding.BlockStateHash,\n  Encoding.Channel,\n  Encoding.ContractAddress,\n  Encoding.TxHash,\n  Encoding.OracleAddress,\n  Encoding.OracleQueryId,\n  Encoding.AccountAddress,\n  Encoding.Signature,\n  Encoding.Commitment,\n  Encoding.PeerPubkey,\n  Encoding.Name,\n] as const;\n\n/**\n * @see {@link https://github.com/aeternity/aeserialization/blob/eb68fe331bd476910394966b7f5ede7a74d37e35/src/aeser_api_encoder.erl#L261-L286}\n */\nconst byteSizeForType = {\n  [Encoding.KeyBlockHash]: 32,\n  [Encoding.MicroBlockHash]: 32,\n  [Encoding.BlockPofHash]: 32,\n  [Encoding.BlockTxHash]: 32,\n  [Encoding.BlockStateHash]: 32,\n  [Encoding.Channel]: 32,\n  [Encoding.ContractAddress]: 32,\n  [Encoding.TxHash]: 32,\n  [Encoding.OracleAddress]: 32,\n  [Encoding.OracleQueryId]: 32,\n  [Encoding.AccountAddress]: 32,\n  [Encoding.Signature]: 64,\n  [Encoding.Commitment]: 32,\n  [Encoding.PeerPubkey]: 32,\n  [Encoding.State]: 32,\n} as const;\n\nfunction ensureValidLength(data: Uint8Array, type: Encoding): void {\n  if (!isKeyOfObject(type, byteSizeForType)) return;\n  const reqLen = byteSizeForType[type];\n  if (reqLen == null || data.length === reqLen) return;\n  throw new PayloadLengthError(`Payload should be ${reqLen} bytes, got ${data.length} instead`);\n}\n\nconst getChecksum = (payload: Uint8Array): Buffer => sha256hash(sha256hash(payload)).slice(0, 4);\n\nconst addChecksum = (payload: Uint8Array): Buffer => concatBuffers([payload, getChecksum(payload)]);\n\nfunction getPayload(buffer: Buffer): Buffer {\n  const payload = buffer.slice(0, -4);\n  if (!getChecksum(payload).equals(buffer.slice(-4))) throw new InvalidChecksumError();\n  return payload;\n}\n\nconst base64 = {\n  encode: (buffer: Uint8Array) => addChecksum(buffer).toString('base64'),\n  decode: (string: string) => getPayload(Buffer.from(string, 'base64')),\n};\n\nconst base58 = {\n  encode: (buffer: Uint8Array) => bs58Encode(addChecksum(buffer)),\n  decode: (string: string) => getPayload(Buffer.from(bs58Decode(string))),\n};\n\nconst parseType = (maybeType: unknown): [Encoding, typeof base64] => {\n  const base64Type = base64Types.find((t) => t === maybeType);\n  if (base64Type != null) return [base64Type, base64];\n  const base58Type = base58Types.find((t) => t === maybeType);\n  if (base58Type != null) return [base58Type, base58];\n  throw new ArgumentError('prefix', `one of ${[...base58Types, ...base64Types].join(', ')}`, maybeType);\n};\n\n/**\n * Decode data using the default encoding/decoding algorithm\n * @param data - An Base58/64check encoded and prefixed string\n * (ex tx_..., sg_..., ak_....)\n * @returns Decoded data\n */\nexport function decode(data: Encoded.Any): Buffer {\n  const [prefix, encodedPayload, extra] = data.split('_');\n  if (encodedPayload == null) throw new DecodeError(`Encoded string missing payload: ${data}`);\n  if (extra != null) throw new DecodeError(`Encoded string have extra parts: ${data}`);\n  const [type, encoder] = parseType(prefix);\n  const payload = encoder.decode(encodedPayload);\n  ensureValidLength(payload, type);\n  return payload;\n}\n\n/**\n * Encode data using the default encoding/decoding algorithm\n * @param data - An decoded data\n * @param type - Prefix of Transaction\n * @returns Encoded string Base58check or Base64check data\n */\nexport function encode<Type extends Encoding>(\n  data: Uint8Array,\n  type: Type,\n): Encoded.Generic<Type> {\n  const [, encoder] = parseType(type);\n  ensureValidLength(data, type);\n  return `${type}_${encoder.encode(data)}`;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}