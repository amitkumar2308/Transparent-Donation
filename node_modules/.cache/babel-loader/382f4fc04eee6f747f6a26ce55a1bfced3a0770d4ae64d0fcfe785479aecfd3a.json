{"ast":null,"code":"import { notify, call, changeState } from \"./internal.mjs\";\nimport { pause } from \"../utils/other.mjs\";\nimport Channel from \"./Base.mjs\";\nimport { ChannelConnectionError } from \"../utils/errors.mjs\";\nimport { awaitingCompletion, channelOpen, handleUnexpectedMessage, signAndNotify } from \"./handlers.mjs\";\nimport { unpackTx } from \"../tx/builder/index.mjs\";\nimport { Tag } from \"../tx/builder/constants.mjs\";\nexport default class ChannelSpend extends Channel {\n  /**\n   * Trigger a transfer update\n   *\n   * The transfer update is moving coins from one channel account to another.\n   * The update is a change to be applied on top of the latest state.\n   *\n   * Sender and receiver are the channel parties. Both the initiator and responder\n   * can take those roles. Any public key outside the channel is considered invalid.\n   *\n   * @param from - Sender's public address\n   * @param to - Receiver's public address\n   * @param amount - Transaction amount\n   * @param sign - Function which verifies and signs offchain transaction\n   * @param metadata - Metadata\n    * @example\n   * ```js\n   * channel.update(\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n   *   10,\n   *   async (tx) => await account.signTransaction(tx)\n   * ).then(({ accepted, signedTx }) =>\n   *   if (accepted) {\n   *     console.log('Update has been accepted')\n   *   }\n   * )\n   * ```\n   */\n  async update(from, to, amount, sign) {\n    let metadata = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    return this.enqueueAction(() => {\n      notify(this, 'channels.update.new', {\n        from,\n        to,\n        amount,\n        meta: metadata\n      });\n      const awaitingOffChainTx = async (_, message, state) => {\n        if (message.method === 'channels.sign.update') {\n          const isError = await signAndNotify(this, 'channels.update', message.params.data, async tx => sign(tx, {\n            updates: message.params.data.updates\n          }));\n          if (isError) return {\n            handler: awaitingOffChainTx,\n            state\n          };\n          return {\n            handler: (_2, message2) => awaitingCompletion(this, message2, state, () => {\n              changeState(this, message2.params.data.state);\n              state.resolve({\n                accepted: true,\n                signedTx: message2.params.data.state\n              });\n              return {\n                handler: channelOpen\n              };\n            }),\n            state\n          };\n        }\n        if (message.method === 'channels.error') {\n          state.reject(new ChannelConnectionError(message.data.message));\n          return {\n            handler: channelOpen\n          };\n        }\n        return awaitingCompletion(this, message, state);\n      };\n      return {\n        handler: awaitingOffChainTx\n      };\n    });\n  }\n\n  /**\n   * Get proof of inclusion\n   *\n   * If a certain address of an account or a contract is not found\n   * in the state tree - the response is an error.\n   *\n   * @param addresses - Addresses\n   * @param addresses.accounts - List of account addresses to include in poi\n   * @param addresses.contracts - List of contract addresses to include in poi\n   * @example\n   * ```js\n   * channel.poi({\n   *   accounts: [\n   *     'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *     'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'\n   *   ],\n   *   contracts: ['ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA']\n   * }).then(poi => console.log(poi))\n   * ```\n   */\n  async poi(_ref) {\n    let {\n      accounts,\n      contracts\n    } = _ref;\n    return unpackTx((await call(this, 'channels.get.poi', {\n      accounts,\n      contracts\n    })).poi, Tag.TreesPoi);\n  }\n\n  /**\n   * Get balances\n   *\n   * The accounts param contains a list of addresses to fetch balances of.\n   * Those can be either account balances or a contract ones, encoded as an account addresses.\n   *\n   * If a certain account address had not being found in the state tree - it is simply\n   * skipped in the response.\n   *\n   * @param accounts - List of addresses to fetch balances from\n   * @example\n   * ```js\n   * channel.balances([\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'\n   *   'ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA'\n   * ]).then(balances =>\n   *   console.log(balances['ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'])\n   * )\n   * ```\n   */\n  async balances(accounts) {\n    return Object.fromEntries((await call(this, 'channels.get.balances', {\n      accounts\n    })).map(item => [item.account, item.balance]));\n  }\n  async awaitingActionTx(action, message, state) {\n    if (message.method !== `channels.sign.${action}_tx`) {\n      return handleUnexpectedMessage(this, message, state);\n    }\n    const awaitingActionCompletion = (_, message2) => {\n      if (message2.method === 'channels.on_chain_tx') {\n        var _state$onOnChainTx;\n        (_state$onOnChainTx = state.onOnChainTx) === null || _state$onOnChainTx === void 0 ? void 0 : _state$onOnChainTx.call(state, message2.params.data.tx);\n        return {\n          handler: awaitingActionCompletion,\n          state\n        };\n      }\n      if (message2.method === 'channels.info' && [`own_${action}_locked`, `${action}_locked`].includes(message2.params.data.event)) {\n        var _state;\n        const Action = action === 'deposit' ? 'Deposit' : 'Withdraw';\n        const isOwn = message2.params.data.event.startsWith('own_');\n        (_state = state[`on${isOwn ? 'Own' : ''}${Action}Locked`]) === null || _state === void 0 ? void 0 : _state.call(state);\n        return {\n          handler: awaitingActionCompletion,\n          state\n        };\n      }\n      return awaitingCompletion(this, message2, state, () => {\n        changeState(this, message2.params.data.state);\n        state.resolve({\n          accepted: true,\n          signedTx: message2.params.data.state\n        });\n        return {\n          handler: channelOpen\n        };\n      });\n    };\n    const {\n      sign\n    } = state;\n    await signAndNotify(this, `channels.${action}_tx`, message.params.data, async tx => sign(tx, {\n      updates: message.params.data.updates\n    }));\n    return {\n      handler: awaitingActionCompletion,\n      state\n    };\n  }\n\n  /**\n   * Withdraw coins from the channel\n   *\n   * After the channel had been opened any of the participants can initiate a withdrawal.\n   * The process closely resembles the update. The most notable difference is that the\n   * transaction has been co-signed: it is channel_withdraw_tx and after the procedure\n   * is finished - it is being posted on-chain.\n   *\n   * Any of the participants can initiate a withdrawal. The only requirements are:\n   *\n   *   - Channel is already opened\n   *   - No off-chain update/deposit/withdrawal is currently being performed\n   *   - Channel is not being closed or in a solo closing state\n   *   - The withdrawal amount must be equal to or greater than zero, and cannot exceed\n   *     the available balance on the channel (minus the channel_reserve)\n   *\n   * After the other party had signed the withdraw transaction, the transaction is posted\n   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.\n   * After computing transaction hash it can be tracked on the chain: entering the mempool,\n   * block inclusion and a number of confirmations.\n   *\n   * After the minimum_depth block confirmations onOwnWithdrawLocked callback is called\n   * (without any arguments).\n   *\n   * When the other party had confirmed that the block height needed is reached\n   * onWithdrawLocked callback is called (without any arguments).\n   *\n   * @param amount - Amount of coins to withdraw\n   * @param sign - Function which verifies and signs withdraw transaction\n   * @param callbacks - Callbacks\n   * @param callbacks.onOnChainTx - Called when withdraw transaction has been posted\n   * on chain\n   * @param callbacks.onOwnWithdrawLocked\n   * @param callbacks.onWithdrawLocked\n   * @example\n   * ```js\n   * channel.withdraw(\n   *   100,\n   *   async (tx) => await account.signTransaction(tx),\n   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }\n   * ).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Withdrawal has been accepted')\n   *   } else {\n   *     console.log('Withdrawal has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async withdraw(amount, sign) {\n    let {\n      onOnChainTx,\n      onOwnWithdrawLocked,\n      onWithdrawLocked\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.enqueueAction(() => {\n      notify(this, 'channels.withdraw', {\n        amount\n      });\n      return {\n        handler: async (_, message, state) => this.awaitingActionTx('withdraw', message, state),\n        state: {\n          sign,\n          onOnChainTx,\n          onOwnWithdrawLocked,\n          onWithdrawLocked\n        }\n      };\n    });\n  }\n\n  /**\n   * Deposit coins into the channel\n   *\n   * After the channel had been opened any of the participants can initiate a deposit.\n   * The process closely resembles the update. The most notable difference is that the\n   * transaction has been co-signed: it is channel_deposit_tx and after the procedure\n   * is finished - it is being posted on-chain.\n   *\n   * Any of the participants can initiate a deposit. The only requirements are:\n   *\n   *   - Channel is already opened\n   *   - No off-chain update/deposit/withdrawal is currently being performed\n   *   - Channel is not being closed or in a solo closing state\n   *   - The deposit amount must be equal to or greater than zero, and cannot exceed\n   *     the available balance on the channel (minus the channel_reserve)\n   *\n   * After the other party had signed the deposit transaction, the transaction is posted\n   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.\n   * After computing transaction hash it can be tracked on the chain: entering the mempool,\n   * block inclusion and a number of confirmations.\n   *\n   * After the minimum_depth block confirmations onOwnDepositLocked callback is called\n   * (without any arguments).\n   *\n   * When the other party had confirmed that the block height needed is reached\n   * onDepositLocked callback is called (without any arguments).\n   *\n   * @param amount - Amount of coins to deposit\n   * @param sign - Function which verifies and signs deposit transaction\n   * @param callbacks - Callbacks\n   * @param callbacks.onOnChainTx - Called when deposit transaction has been posted\n   * on chain\n   * @param callbacks.onOwnDepositLocked\n   * @param callbacks.onDepositLocked\n   * @example\n   * ```js\n   * channel.deposit(\n   *   100,\n   *   async (tx) => await account.signTransaction(tx),\n   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }\n   * ).then(({ accepted, state }) => {\n   *   if (accepted) {\n   *     console.log('Deposit has been accepted')\n   *     console.log('The new state is:', state)\n   *   } else {\n   *     console.log('Deposit has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async deposit(amount, sign) {\n    let {\n      onOnChainTx,\n      onOwnDepositLocked,\n      onDepositLocked\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.enqueueAction(() => {\n      notify(this, 'channels.deposit', {\n        amount\n      });\n      return {\n        handler: async (_, message, state) => this.awaitingActionTx('deposit', message, state),\n        state: {\n          sign,\n          onOnChainTx,\n          onOwnDepositLocked,\n          onDepositLocked\n        }\n      };\n    });\n  }\n\n  /**\n   * Send generic message\n   *\n   * If message is an object it will be serialized into JSON string\n   * before sending.\n   *\n   * If there is ongoing update that has not yet been finished the message\n   * will be sent after that update is finalized.\n   *\n   * @param message - Message\n   * @param recipient - Address of the recipient\n   * @example\n   * ```js\n   * channel.sendMessage(\n   *   'hello world',\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'\n   * )\n   * ```\n   */\n  async sendMessage(message, recipient) {\n    const info = typeof message === 'object' ? JSON.stringify(message) : message;\n    if (this.status() === 'connecting') {\n      await new Promise(resolve => {\n        const onStatusChanged = status => {\n          if (status === 'connecting') return;\n          resolve();\n          this.off('statusChanged', onStatusChanged);\n        };\n        this.on('statusChanged', onStatusChanged);\n      });\n      // For some reason we can't immediately send a message when connection is\n      // established. Thus we wait 500ms which seems to work.\n      await pause(500);\n    }\n    notify(this, 'channels.message', {\n      info,\n      to: recipient\n    });\n  }\n}","map":{"version":3,"names":["notify","call","changeState","pause","Channel","ChannelConnectionError","awaitingCompletion","channelOpen","handleUnexpectedMessage","signAndNotify","unpackTx","Tag","ChannelSpend","update","from","to","amount","sign","metadata","arguments","length","undefined","enqueueAction","meta","awaitingOffChainTx","_","message","state","method","isError","params","data","tx","updates","handler","_2","message2","resolve","accepted","signedTx","reject","poi","_ref","accounts","contracts","TreesPoi","balances","Object","fromEntries","map","item","account","balance","awaitingActionTx","action","awaitingActionCompletion","_state$onOnChainTx","onOnChainTx","includes","event","_state","Action","isOwn","startsWith","withdraw","onOwnWithdrawLocked","onWithdrawLocked","deposit","onOwnDepositLocked","onDepositLocked","sendMessage","recipient","info","JSON","stringify","status","Promise","onStatusChanged","off","on"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\channel\\Spend.ts"],"sourcesContent":["import BigNumber from 'bignumber.js';\nimport {\n  notify, call, SignTx, ChannelState, ChannelMessage, ChannelFsm, changeState,\n} from './internal';\nimport { Encoded } from '../utils/encoder';\nimport { pause } from '../utils/other';\nimport Channel from './Base';\nimport { ChannelConnectionError } from '../utils/errors';\nimport {\n  awaitingCompletion, channelOpen, handleUnexpectedMessage, signAndNotify,\n} from './handlers';\nimport { unpackTx } from '../tx/builder';\nimport { Tag } from '../tx/builder/constants';\nimport { TxUnpacked } from '../tx/builder/schema.generated';\n\nexport default class ChannelSpend extends Channel {\n  /**\n   * Trigger a transfer update\n   *\n   * The transfer update is moving coins from one channel account to another.\n   * The update is a change to be applied on top of the latest state.\n   *\n   * Sender and receiver are the channel parties. Both the initiator and responder\n   * can take those roles. Any public key outside the channel is considered invalid.\n   *\n   * @param from - Sender's public address\n   * @param to - Receiver's public address\n   * @param amount - Transaction amount\n   * @param sign - Function which verifies and signs offchain transaction\n   * @param metadata - Metadata\n\n   * @example\n   * ```js\n   * channel.update(\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E',\n   *   10,\n   *   async (tx) => await account.signTransaction(tx)\n   * ).then(({ accepted, signedTx }) =>\n   *   if (accepted) {\n   *     console.log('Update has been accepted')\n   *   }\n   * )\n   * ```\n   */\n  async update(\n    from: Encoded.AccountAddress,\n    to: Encoded.AccountAddress,\n    amount: number | BigNumber,\n    sign: SignTx,\n    metadata: string[] = [],\n  ): Promise<{\n      accepted: boolean;\n      signedTx?: Encoded.Transaction;\n      errorCode?: number;\n      errorMessage?: string;\n    }> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.update.new', {\n        from, to, amount, meta: metadata,\n      });\n\n      const awaitingOffChainTx = async (\n        _: Channel,\n        message: ChannelMessage,\n        state: ChannelState,\n      ): Promise<ChannelFsm> => {\n        if (message.method === 'channels.sign.update') {\n          const isError = await signAndNotify(\n            this,\n            'channels.update',\n            message.params.data,\n            async (tx) => sign(tx, { updates: message.params.data.updates }),\n          );\n          if (isError) return { handler: awaitingOffChainTx, state };\n          return {\n            handler: (_2: Channel, message2: ChannelMessage): ChannelFsm => (\n              awaitingCompletion(this, message2, state, () => {\n                changeState(this, message2.params.data.state);\n                state.resolve({ accepted: true, signedTx: message2.params.data.state });\n                return { handler: channelOpen };\n              })\n            ),\n            state,\n          };\n        }\n        if (message.method === 'channels.error') {\n          state.reject(new ChannelConnectionError(message.data.message));\n          return { handler: channelOpen };\n        }\n        return awaitingCompletion(this, message, state);\n      };\n\n      return { handler: awaitingOffChainTx };\n    });\n  }\n\n  /**\n   * Get proof of inclusion\n   *\n   * If a certain address of an account or a contract is not found\n   * in the state tree - the response is an error.\n   *\n   * @param addresses - Addresses\n   * @param addresses.accounts - List of account addresses to include in poi\n   * @param addresses.contracts - List of contract addresses to include in poi\n   * @example\n   * ```js\n   * channel.poi({\n   *   accounts: [\n   *     'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *     'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'\n   *   ],\n   *   contracts: ['ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA']\n   * }).then(poi => console.log(poi))\n   * ```\n   */\n  async poi(\n    { accounts, contracts }: {\n      accounts: Encoded.AccountAddress[];\n      contracts?: Encoded.ContractAddress[];\n    },\n  ): Promise<TxUnpacked & { tag: Tag.TreesPoi }> {\n    return unpackTx(\n      (await call(this, 'channels.get.poi', { accounts, contracts })).poi,\n      Tag.TreesPoi,\n    );\n  }\n\n  /**\n   * Get balances\n   *\n   * The accounts param contains a list of addresses to fetch balances of.\n   * Those can be either account balances or a contract ones, encoded as an account addresses.\n   *\n   * If a certain account address had not being found in the state tree - it is simply\n   * skipped in the response.\n   *\n   * @param accounts - List of addresses to fetch balances from\n   * @example\n   * ```js\n   * channel.balances([\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH',\n   *   'ak_V6an1xhec1xVaAhLuak7QoEbi6t7w5hEtYWp9bMKaJ19i6A9E'\n   *   'ct_2dCUAWYZdrWfACz3a2faJeKVTVrfDYxCQHCqAt5zM15f3u2UfA'\n   * ]).then(balances =>\n   *   console.log(balances['ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'])\n   * )\n   * ```\n   */\n  async balances(\n    accounts: Encoded.AccountAddress[],\n  ): Promise<{ [key: Encoded.AccountAddress]: string }> {\n    return Object.fromEntries(\n      (await call(this, 'channels.get.balances', { accounts }))\n        .map((item: {\n          account: Encoded.AccountAddress;\n          balance: string;\n        }) => [item.account, item.balance]),\n    );\n  }\n\n  private async awaitingActionTx(\n    action: 'deposit' | 'withdraw',\n    message: ChannelMessage,\n    state: ChannelState,\n  ): Promise<ChannelFsm> {\n    if (message.method !== `channels.sign.${action}_tx`) {\n      return handleUnexpectedMessage(this, message, state);\n    }\n\n    const awaitingActionCompletion = (_: Channel, message2: ChannelMessage): ChannelFsm => {\n      if (message2.method === 'channels.on_chain_tx') {\n        state.onOnChainTx?.(message2.params.data.tx);\n        return { handler: awaitingActionCompletion, state };\n      }\n      if (\n        message2.method === 'channels.info'\n        && [`own_${action}_locked`, `${action}_locked`].includes(message2.params.data.event)\n      ) {\n        const Action = action === 'deposit' ? 'Deposit' : 'Withdraw';\n        const isOwn: boolean = message2.params.data.event.startsWith('own_');\n        state[`on${isOwn ? 'Own' : ''}${Action}Locked`]?.();\n        return { handler: awaitingActionCompletion, state };\n      }\n      return awaitingCompletion(this, message2, state, () => {\n        changeState(this, message2.params.data.state);\n        state.resolve({ accepted: true, signedTx: message2.params.data.state });\n        return { handler: channelOpen };\n      });\n    };\n\n    const { sign } = state;\n    await signAndNotify(\n      this,\n      `channels.${action}_tx`,\n      message.params.data,\n      async (tx) => sign(tx, { updates: message.params.data.updates }),\n    );\n    return { handler: awaitingActionCompletion, state };\n  }\n\n  /**\n   * Withdraw coins from the channel\n   *\n   * After the channel had been opened any of the participants can initiate a withdrawal.\n   * The process closely resembles the update. The most notable difference is that the\n   * transaction has been co-signed: it is channel_withdraw_tx and after the procedure\n   * is finished - it is being posted on-chain.\n   *\n   * Any of the participants can initiate a withdrawal. The only requirements are:\n   *\n   *   - Channel is already opened\n   *   - No off-chain update/deposit/withdrawal is currently being performed\n   *   - Channel is not being closed or in a solo closing state\n   *   - The withdrawal amount must be equal to or greater than zero, and cannot exceed\n   *     the available balance on the channel (minus the channel_reserve)\n   *\n   * After the other party had signed the withdraw transaction, the transaction is posted\n   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.\n   * After computing transaction hash it can be tracked on the chain: entering the mempool,\n   * block inclusion and a number of confirmations.\n   *\n   * After the minimum_depth block confirmations onOwnWithdrawLocked callback is called\n   * (without any arguments).\n   *\n   * When the other party had confirmed that the block height needed is reached\n   * onWithdrawLocked callback is called (without any arguments).\n   *\n   * @param amount - Amount of coins to withdraw\n   * @param sign - Function which verifies and signs withdraw transaction\n   * @param callbacks - Callbacks\n   * @param callbacks.onOnChainTx - Called when withdraw transaction has been posted\n   * on chain\n   * @param callbacks.onOwnWithdrawLocked\n   * @param callbacks.onWithdrawLocked\n   * @example\n   * ```js\n   * channel.withdraw(\n   *   100,\n   *   async (tx) => await account.signTransaction(tx),\n   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }\n   * ).then(({ accepted, signedTx }) => {\n   *   if (accepted) {\n   *     console.log('Withdrawal has been accepted')\n   *   } else {\n   *     console.log('Withdrawal has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async withdraw(\n    amount: number | BigNumber,\n    sign: SignTx,\n    { onOnChainTx, onOwnWithdrawLocked, onWithdrawLocked }:\n    Pick<ChannelState, 'onOnChainTx' | 'onOwnWithdrawLocked' | 'onWithdrawLocked'> = {},\n  ): Promise<{ accepted: boolean; signedTx: Encoded.Transaction }> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.withdraw', { amount });\n      return {\n        handler: async (\n          _: Channel,\n          message: ChannelMessage,\n          state: ChannelState,\n        ): Promise<ChannelFsm> => (\n          this.awaitingActionTx('withdraw', message, state)\n        ),\n        state: {\n          sign,\n          onOnChainTx,\n          onOwnWithdrawLocked,\n          onWithdrawLocked,\n        },\n      };\n    });\n  }\n\n  /**\n   * Deposit coins into the channel\n   *\n   * After the channel had been opened any of the participants can initiate a deposit.\n   * The process closely resembles the update. The most notable difference is that the\n   * transaction has been co-signed: it is channel_deposit_tx and after the procedure\n   * is finished - it is being posted on-chain.\n   *\n   * Any of the participants can initiate a deposit. The only requirements are:\n   *\n   *   - Channel is already opened\n   *   - No off-chain update/deposit/withdrawal is currently being performed\n   *   - Channel is not being closed or in a solo closing state\n   *   - The deposit amount must be equal to or greater than zero, and cannot exceed\n   *     the available balance on the channel (minus the channel_reserve)\n   *\n   * After the other party had signed the deposit transaction, the transaction is posted\n   * on-chain and onOnChainTx callback is called with on-chain transaction as first argument.\n   * After computing transaction hash it can be tracked on the chain: entering the mempool,\n   * block inclusion and a number of confirmations.\n   *\n   * After the minimum_depth block confirmations onOwnDepositLocked callback is called\n   * (without any arguments).\n   *\n   * When the other party had confirmed that the block height needed is reached\n   * onDepositLocked callback is called (without any arguments).\n   *\n   * @param amount - Amount of coins to deposit\n   * @param sign - Function which verifies and signs deposit transaction\n   * @param callbacks - Callbacks\n   * @param callbacks.onOnChainTx - Called when deposit transaction has been posted\n   * on chain\n   * @param callbacks.onOwnDepositLocked\n   * @param callbacks.onDepositLocked\n   * @example\n   * ```js\n   * channel.deposit(\n   *   100,\n   *   async (tx) => await account.signTransaction(tx),\n   *   { onOnChainTx: (tx) => console.log('on_chain_tx', tx) }\n   * ).then(({ accepted, state }) => {\n   *   if (accepted) {\n   *     console.log('Deposit has been accepted')\n   *     console.log('The new state is:', state)\n   *   } else {\n   *     console.log('Deposit has been rejected')\n   *   }\n   * })\n   * ```\n   */\n  async deposit(\n    amount: number | BigNumber,\n    sign: SignTx,\n    { onOnChainTx, onOwnDepositLocked, onDepositLocked }:\n    Pick<ChannelState, 'onOnChainTx' | 'onOwnDepositLocked' | 'onDepositLocked'> = {},\n  ): Promise<{ accepted: boolean; state: ChannelState }> {\n    return this.enqueueAction(() => {\n      notify(this, 'channels.deposit', { amount });\n      return {\n        handler: async (\n          _: Channel,\n          message: ChannelMessage,\n          state: ChannelState,\n        ): Promise<ChannelFsm> => (\n          this.awaitingActionTx('deposit', message, state)\n        ),\n        state: {\n          sign,\n          onOnChainTx,\n          onOwnDepositLocked,\n          onDepositLocked,\n        },\n      };\n    });\n  }\n\n  /**\n   * Send generic message\n   *\n   * If message is an object it will be serialized into JSON string\n   * before sending.\n   *\n   * If there is ongoing update that has not yet been finished the message\n   * will be sent after that update is finalized.\n   *\n   * @param message - Message\n   * @param recipient - Address of the recipient\n   * @example\n   * ```js\n   * channel.sendMessage(\n   *   'hello world',\n   *   'ak_Y1NRjHuoc3CGMYMvCmdHSBpJsMDR6Ra2t5zjhRcbtMeXXLpLH'\n   * )\n   * ```\n   */\n  async sendMessage(\n    message: string | object,\n    recipient: Encoded.AccountAddress,\n  ): Promise<void> {\n    const info = typeof message === 'object' ? JSON.stringify(message) : message;\n    if (this.status() === 'connecting') {\n      await new Promise<void>((resolve) => {\n        const onStatusChanged = (status: string): void => {\n          if (status === 'connecting') return;\n          resolve();\n          this.off('statusChanged', onStatusChanged);\n        };\n        this.on('statusChanged', onStatusChanged);\n      });\n      // For some reason we can't immediately send a message when connection is\n      // established. Thus we wait 500ms which seems to work.\n      await pause(500);\n    }\n    notify(this, 'channels.message', { info, to: recipient });\n  }\n}\n"],"mappings":"SAEEA,MAAM,EAAEC,IAAI,EAAoDC,WAAW;AAAA,SAGpEC,KAAK;AAAA,OACPC,OAAO;AAAA,SACLC,sBAAsB;AAAA,SAE7BC,kBAAkB,EAAEC,WAAW,EAAEC,uBAAuB,EAAEC,aAAa;AAAA,SAEhEC,QAAQ;AAAA,SACRC,GAAG;AAGZ,eAAe,MAAMC,YAAY,SAASR,OAAO,CAAC;EAChD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAEE,MAAMS,MAAMA,CACVC,IAA4B,EAC5BC,EAA0B,EAC1BC,MAA0B,EAC1BC,IAAY,EAOT;IAAA,IANHC,QAAkB,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;IAOvB,OAAO,IAAI,CAACG,aAAa,CAAC,MAAM;MAC9BtB,MAAM,CAAC,IAAI,EAAE,qBAAqB,EAAE;QAClCc,IAAI;QAAEC,EAAE;QAAEC,MAAM;QAAEO,IAAI,EAAEL;MAC1B,CAAC,CAAC;MAEF,MAAMM,kBAAkB,GAAG,MAAAA,CACzBC,CAAU,EACVC,OAAuB,EACvBC,KAAmB,KACK;QACxB,IAAID,OAAO,CAACE,MAAM,KAAK,sBAAsB,EAAE;UAC7C,MAAMC,OAAO,GAAG,MAAMpB,aAAa,CACjC,IAAI,EACJ,iBAAiB,EACjBiB,OAAO,CAACI,MAAM,CAACC,IAAI,EACnB,MAAOC,EAAE,IAAKf,IAAI,CAACe,EAAE,EAAE;YAAEC,OAAO,EAAEP,OAAO,CAACI,MAAM,CAACC,IAAI,CAACE;UAAQ,CAAC,CACjE,CAAC;UACD,IAAIJ,OAAO,EAAE,OAAO;YAAEK,OAAO,EAAEV,kBAAkB;YAAEG;UAAM,CAAC;UAC1D,OAAO;YACLO,OAAO,EAAEA,CAACC,EAAW,EAAEC,QAAwB,KAC7C9B,kBAAkB,CAAC,IAAI,EAAE8B,QAAQ,EAAET,KAAK,EAAE,MAAM;cAC9CzB,WAAW,CAAC,IAAI,EAAEkC,QAAQ,CAACN,MAAM,CAACC,IAAI,CAACJ,KAAK,CAAC;cAC7CA,KAAK,CAACU,OAAO,CAAC;gBAAEC,QAAQ,EAAE,IAAI;gBAAEC,QAAQ,EAAEH,QAAQ,CAACN,MAAM,CAACC,IAAI,CAACJ;cAAM,CAAC,CAAC;cACvE,OAAO;gBAAEO,OAAO,EAAE3B;cAAY,CAAC;YACjC,CAAC,CACF;YACDoB;UACF,CAAC;QACH;QACA,IAAID,OAAO,CAACE,MAAM,KAAK,gBAAgB,EAAE;UACvCD,KAAK,CAACa,MAAM,CAAC,IAAInC,sBAAsB,CAACqB,OAAO,CAACK,IAAI,CAACL,OAAO,CAAC,CAAC;UAC9D,OAAO;YAAEQ,OAAO,EAAE3B;UAAY,CAAC;QACjC;QACA,OAAOD,kBAAkB,CAAC,IAAI,EAAEoB,OAAO,EAAEC,KAAK,CAAC;MACjD,CAAC;MAED,OAAO;QAAEO,OAAO,EAAEV;MAAmB,CAAC;IACxC,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMiB,GAAGA,CAAAC,IAAA,EAKsC;IAAA,IAJ7C;MAAEC,QAAQ;MAAEC;IAGZ,CAAC,GAAAF,IAAA;IAED,OAAOhC,QAAQ,CACb,CAAC,MAAMT,IAAI,CAAC,IAAI,EAAE,kBAAkB,EAAE;MAAE0C,QAAQ;MAAEC;IAAU,CAAC,CAAC,EAAEH,GAAG,EACnE9B,GAAG,CAACkC,QACN,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,QAAQA,CACZH,QAAkC,EACkB;IACpD,OAAOI,MAAM,CAACC,WAAW,CACvB,CAAC,MAAM/C,IAAI,CAAC,IAAI,EAAE,uBAAuB,EAAE;MAAE0C;IAAS,CAAC,CAAC,EACrDM,GAAG,CAAEC,IAGL,IAAK,CAACA,IAAI,CAACC,OAAO,EAAED,IAAI,CAACE,OAAO,CAAC,CACtC,CAAC;EACH;EAEA,MAAcC,gBAAgBA,CAC5BC,MAA8B,EAC9B5B,OAAuB,EACvBC,KAAmB,EACE;IACrB,IAAID,OAAO,CAACE,MAAM,KAAM,iBAAgB0B,MAAO,KAAI,EAAE;MACnD,OAAO9C,uBAAuB,CAAC,IAAI,EAAEkB,OAAO,EAAEC,KAAK,CAAC;IACtD;IAEA,MAAM4B,wBAAwB,GAAGA,CAAC9B,CAAU,EAAEW,QAAwB,KAAiB;MACrF,IAAIA,QAAQ,CAACR,MAAM,KAAK,sBAAsB,EAAE;QAAA,IAAA4B,kBAAA;QAC9C,CAAAA,kBAAA,GAAA7B,KAAK,CAAC8B,WAAW,cAAAD,kBAAA,uBAAjBA,kBAAA,CAAAvD,IAAA,CAAA0B,KAAK,EAAeS,QAAQ,CAACN,MAAM,CAACC,IAAI,CAACC,EAAE,CAAC;QAC5C,OAAO;UAAEE,OAAO,EAAEqB,wBAAwB;UAAE5B;QAAM,CAAC;MACrD;MACA,IACES,QAAQ,CAACR,MAAM,KAAK,eAAe,IAChC,CAAE,OAAM0B,MAAO,SAAQ,EAAG,GAAEA,MAAO,SAAQ,CAAC,CAACI,QAAQ,CAACtB,QAAQ,CAACN,MAAM,CAACC,IAAI,CAAC4B,KAAK,CAAC,EACpF;QAAA,IAAAC,MAAA;QACA,MAAMC,MAAM,GAAGP,MAAM,KAAK,SAAS,GAAG,SAAS,GAAG,UAAU;QAC5D,MAAMQ,KAAc,GAAG1B,QAAQ,CAACN,MAAM,CAACC,IAAI,CAAC4B,KAAK,CAACI,UAAU,CAAC,MAAM,CAAC;QACpE,CAAAH,MAAA,GAAAjC,KAAK,CAAE,KAAImC,KAAK,GAAG,KAAK,GAAG,EAAG,GAAED,MAAO,QAAO,CAAC,cAAAD,MAAA,uBAA/CA,MAAA,CAAA3D,IAAA,CAAA0B,KAAkD,CAAC;QACnD,OAAO;UAAEO,OAAO,EAAEqB,wBAAwB;UAAE5B;QAAM,CAAC;MACrD;MACA,OAAOrB,kBAAkB,CAAC,IAAI,EAAE8B,QAAQ,EAAET,KAAK,EAAE,MAAM;QACrDzB,WAAW,CAAC,IAAI,EAAEkC,QAAQ,CAACN,MAAM,CAACC,IAAI,CAACJ,KAAK,CAAC;QAC7CA,KAAK,CAACU,OAAO,CAAC;UAAEC,QAAQ,EAAE,IAAI;UAAEC,QAAQ,EAAEH,QAAQ,CAACN,MAAM,CAACC,IAAI,CAACJ;QAAM,CAAC,CAAC;QACvE,OAAO;UAAEO,OAAO,EAAE3B;QAAY,CAAC;MACjC,CAAC,CAAC;IACJ,CAAC;IAED,MAAM;MAAEU;IAAK,CAAC,GAAGU,KAAK;IACtB,MAAMlB,aAAa,CACjB,IAAI,EACH,YAAW6C,MAAO,KAAI,EACvB5B,OAAO,CAACI,MAAM,CAACC,IAAI,EACnB,MAAOC,EAAE,IAAKf,IAAI,CAACe,EAAE,EAAE;MAAEC,OAAO,EAAEP,OAAO,CAACI,MAAM,CAACC,IAAI,CAACE;IAAQ,CAAC,CACjE,CAAC;IACD,OAAO;MAAEC,OAAO,EAAEqB,wBAAwB;MAAE5B;IAAM,CAAC;EACrD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMqC,QAAQA,CACZhD,MAA0B,EAC1BC,IAAY,EAGmD;IAAA,IAF/D;MAAEwC,WAAW;MAAEQ,mBAAmB;MAAEC;IACyC,CAAC,GAAA/C,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAEnF,OAAO,IAAI,CAACG,aAAa,CAAC,MAAM;MAC9BtB,MAAM,CAAC,IAAI,EAAE,mBAAmB,EAAE;QAAEgB;MAAO,CAAC,CAAC;MAC7C,OAAO;QACLkB,OAAO,EAAE,MAAAA,CACPT,CAAU,EACVC,OAAuB,EACvBC,KAAmB,KAEnB,IAAI,CAAC0B,gBAAgB,CAAC,UAAU,EAAE3B,OAAO,EAAEC,KAAK,CACjD;QACDA,KAAK,EAAE;UACLV,IAAI;UACJwC,WAAW;UACXQ,mBAAmB;UACnBC;QACF;MACF,CAAC;IACH,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,OAAOA,CACXnD,MAA0B,EAC1BC,IAAY,EAGyC;IAAA,IAFrD;MAAEwC,WAAW;MAAEW,kBAAkB;MAAEC;IACwC,CAAC,GAAAlD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;IAEjF,OAAO,IAAI,CAACG,aAAa,CAAC,MAAM;MAC9BtB,MAAM,CAAC,IAAI,EAAE,kBAAkB,EAAE;QAAEgB;MAAO,CAAC,CAAC;MAC5C,OAAO;QACLkB,OAAO,EAAE,MAAAA,CACPT,CAAU,EACVC,OAAuB,EACvBC,KAAmB,KAEnB,IAAI,CAAC0B,gBAAgB,CAAC,SAAS,EAAE3B,OAAO,EAAEC,KAAK,CAChD;QACDA,KAAK,EAAE;UACLV,IAAI;UACJwC,WAAW;UACXW,kBAAkB;UAClBC;QACF;MACF,CAAC;IACH,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,MAAMC,WAAWA,CACf5C,OAAwB,EACxB6C,SAAiC,EAClB;IACf,MAAMC,IAAI,GAAG,OAAO9C,OAAO,KAAK,QAAQ,GAAG+C,IAAI,CAACC,SAAS,CAAChD,OAAO,CAAC,GAAGA,OAAO;IAC5E,IAAI,IAAI,CAACiD,MAAM,CAAC,CAAC,KAAK,YAAY,EAAE;MAClC,MAAM,IAAIC,OAAO,CAAQvC,OAAO,IAAK;QACnC,MAAMwC,eAAe,GAAIF,MAAc,IAAW;UAChD,IAAIA,MAAM,KAAK,YAAY,EAAE;UAC7BtC,OAAO,CAAC,CAAC;UACT,IAAI,CAACyC,GAAG,CAAC,eAAe,EAAED,eAAe,CAAC;QAC5C,CAAC;QACD,IAAI,CAACE,EAAE,CAAC,eAAe,EAAEF,eAAe,CAAC;MAC3C,CAAC,CAAC;MACF;MACA;MACA,MAAM1E,KAAK,CAAC,GAAG,CAAC;IAClB;IACAH,MAAM,CAAC,IAAI,EAAE,kBAAkB,EAAE;MAAEwE,IAAI;MAAEzD,EAAE,EAAEwD;IAAU,CAAC,CAAC;EAC3D;AACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}