{"ast":null,"code":"import { AE_AMOUNT_FORMATS, formatAmount } from \"./utils/amount-formatter.mjs\";\nimport verifyTransaction from \"./tx/validator.mjs\";\nimport { ensureError, isAccountNotFoundError, pause } from \"./utils/other.mjs\";\nimport { isNameValid, produceNameId } from \"./tx/builder/helpers.mjs\";\nimport { DRY_RUN_ACCOUNT } from \"./tx/builder/schema.mjs\";\nimport { AensPointerContextError, DryRunError, InvalidAensNameError, TransactionError, TxTimedOutError, TxNotInChainError, InternalError } from \"./utils/errors.mjs\";\nimport { decode, encode, Encoding } from \"./utils/encoder.mjs\";\nimport { buildTxHash } from \"./tx/builder/index.mjs\";\n/**\n * @category chain\n */\nexport function _getPollInterval(type,\n// TODO: rename to 'key-block' | 'micro-block'\n_ref) {\n  let {\n    _expectedMineRate = 180000,\n    _microBlockCycle = 3000,\n    _maxPollInterval = 5000\n  } = _ref;\n  const base = {\n    block: _expectedMineRate,\n    microblock: _microBlockCycle\n  }[type];\n  return Math.min(base / 3, _maxPollInterval);\n}\n\n/**\n * @category exception\n */\nexport class InvalidTxError extends TransactionError {\n  constructor(message, validation, transaction) {\n    super(message);\n    this.name = 'InvalidTxError';\n    this.validation = validation;\n    this.transaction = transaction;\n  }\n}\n\n/**\n * Obtain current height of the chain\n * @category chain\n * @returns Current chain height\n */\nexport async function getHeight(_ref2) {\n  let {\n    onNode\n  } = _ref2;\n  return (await onNode.getCurrentKeyBlockHeight()).height;\n}\n\n/**\n * Wait for a transaction to be mined\n * @category chain\n * @param th - The hash of transaction to poll\n * @param options - Options\n * @param options.interval - Interval (in ms) at which to poll the chain\n * @param options.blocks - Number of blocks mined after which to fail\n * @param options.onNode - Node to use\n * @returns The transaction as it was mined\n */\nexport async function poll(th, _ref3) {\n  var _interval;\n  let {\n    blocks = 5,\n    interval,\n    onNode,\n    ...options\n  } = _ref3;\n  (_interval = interval) !== null && _interval !== void 0 ? _interval : interval = _getPollInterval('microblock', options);\n  const max = (await getHeight({\n    onNode\n  })) + blocks;\n  do {\n    const tx = await onNode.getTransactionByHash(th);\n    if (tx.blockHeight !== -1) return tx;\n    await pause(interval);\n  } while ((await getHeight({\n    onNode\n  })) < max);\n  throw new TxTimedOutError(blocks, th);\n}\n\n/**\n * Wait for the chain to reach a specific height\n * @category chain\n * @param height - Height to wait for\n * @param options - Options\n * @param options.interval - Interval (in ms) at which to poll the chain\n * @param options.onNode - Node to use\n * @returns Current chain height\n */\nexport async function awaitHeight(height, _ref4) {\n  var _interval2;\n  let {\n    interval,\n    onNode,\n    ...options\n  } = _ref4;\n  (_interval2 = interval) !== null && _interval2 !== void 0 ? _interval2 : interval = _getPollInterval('block', options);\n  let currentHeight;\n  do {\n    if (currentHeight != null) await pause(interval);\n    currentHeight = (await onNode.getCurrentKeyBlockHeight()).height;\n  } while (currentHeight < height);\n  return currentHeight;\n}\n\n/**\n * Wait for transaction confirmation\n * @category chain\n * @param txHash - Transaction hash\n * @param options - Options\n * @param options.confirm - Number of micro blocks to wait for transaction confirmation\n * @param options.onNode - Node to use\n * @returns Current Height\n */\nexport async function waitForTxConfirm(txHash, _ref5) {\n  let {\n    confirm = 3,\n    onNode,\n    ...options\n  } = _ref5;\n  const {\n    blockHeight\n  } = await onNode.getTransactionByHash(txHash);\n  const height = await awaitHeight(blockHeight + confirm, {\n    onNode,\n    ...options\n  });\n  const {\n    blockHeight: newBlockHeight\n  } = await onNode.getTransactionByHash(txHash);\n  switch (newBlockHeight) {\n    case -1:\n      throw new TxNotInChainError(txHash);\n    case blockHeight:\n      return height;\n    default:\n      return waitForTxConfirm(txHash, {\n        onNode,\n        confirm,\n        ...options\n      });\n  }\n}\n\n/**\n * Signs and submits transaction for mining\n * @category chain\n * @param txUnsigned - Transaction to sign and submit\n * @param options - Options\n * @param options.onNode - Node to use\n * @param options.onAccount - Account to use\n * @param options.verify - Verify transaction before broadcast, throw error if not\n * @param options.waitMined - Ensure that transaction get into block\n * @param options.confirm - Number of micro blocks that should be mined after tx get included\n * @returns Transaction details\n */\nexport async function sendTransaction(txUnsigned, _ref6) {\n  let {\n    onNode,\n    onAccount,\n    verify = true,\n    waitMined = true,\n    confirm,\n    innerTx,\n    ...options\n  } = _ref6;\n  const tx = await onAccount.signTransaction(txUnsigned, {\n    ...options,\n    onNode,\n    innerTx,\n    networkId: await onNode.getNetworkId()\n  });\n  if (innerTx === true) return {\n    hash: buildTxHash(tx),\n    rawTx: tx\n  };\n  if (verify) {\n    const validation = await verifyTransaction(tx, onNode);\n    if (validation.length > 0) {\n      const message = `Transaction verification errors: ${validation.map(v => v.message).join(', ')}`;\n      throw new InvalidTxError(message, validation, tx);\n    }\n  }\n  try {\n    let __queue;\n    try {\n      __queue = onAccount != null ? `tx-${onAccount.address}` : null;\n    } catch (error) {\n      __queue = null;\n    }\n    const {\n      txHash\n    } = await onNode.postTransaction({\n      tx\n    }, __queue != null ? {\n      requestOptions: {\n        customHeaders: {\n          __queue\n        }\n      }\n    } : {});\n    if (waitMined) {\n      const pollResult = await poll(txHash, {\n        onNode,\n        ...options\n      });\n      const txData = {\n        ...pollResult,\n        hash: pollResult.hash,\n        rawTx: tx\n      };\n      // wait for transaction confirmation\n      if (confirm != null && +confirm > 0) {\n        const c = typeof confirm === 'boolean' ? undefined : confirm;\n        return {\n          ...txData,\n          confirmationHeight: await waitForTxConfirm(txHash, {\n            onNode,\n            confirm: c,\n            ...options\n          })\n        };\n      }\n      return txData;\n    }\n    return {\n      hash: txHash,\n      rawTx: tx\n    };\n  } catch (error) {\n    ensureError(error);\n    throw Object.assign(error, {\n      rawTx: tx,\n      verifyTx: async () => verifyTransaction(tx, onNode)\n    });\n  }\n}\n/**\n * Get account by account public key\n * @category chain\n * @param address - Account address (public key)\n * @param options - Options\n * @param options.height - Get account on specific block by block height\n * @param options.hash - Get account on specific block by micro block hash or key block hash\n * @param options.onNode - Node to use\n */\nexport async function getAccount(address, _ref7) {\n  let {\n    height,\n    hash,\n    onNode\n  } = _ref7;\n  if (height != null) return onNode.getAccountByPubkeyAndHeight(address, height);\n  if (hash != null) return onNode.getAccountByPubkeyAndHash(address, hash);\n  return onNode.getAccountByPubkey(address);\n}\n\n/**\n * Request the balance of specified account\n * @category chain\n * @param address - The public account address to obtain the balance for\n * @param options - Options\n * @param options.format\n * @param options.height - The chain height at which to obtain the balance for\n * (default: top of chain)\n * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)\n */\nexport async function getBalance(address, _ref8) {\n  let {\n    format = AE_AMOUNT_FORMATS.AETTOS,\n    ...options\n  } = _ref8;\n  const addr = address.startsWith('ok_') ? encode(decode(address), Encoding.AccountAddress) : address;\n  const {\n    balance\n  } = await getAccount(addr, options).catch(error => {\n    if (!isAccountNotFoundError(error)) throw error;\n    return {\n      balance: 0n\n    };\n  });\n  return formatAmount(balance, {\n    targetDenomination: format\n  });\n}\n\n/**\n * Obtain current generation\n * @category chain\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Current Generation\n */\nexport async function getCurrentGeneration(_ref9) {\n  let {\n    onNode\n  } = _ref9;\n  return onNode.getCurrentGeneration();\n}\n\n/**\n * Get generation by hash or height\n * @category chain\n * @param hashOrHeight - Generation hash or height\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Generation\n */\nexport async function getGeneration(hashOrHeight, _ref10) {\n  let {\n    onNode\n  } = _ref10;\n  if (typeof hashOrHeight === 'number') return onNode.getGenerationByHeight(hashOrHeight);\n  return onNode.getGenerationByHash(hashOrHeight);\n}\n\n/**\n * Get micro block transactions\n * @category chain\n * @param hash - Micro block hash\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Transactions\n */\nexport async function getMicroBlockTransactions(hash, _ref11) {\n  let {\n    onNode\n  } = _ref11;\n  return (await onNode.getMicroBlockTransactionsByHash(hash)).transactions;\n}\n\n/**\n * Get key block\n * @category chain\n * @param hashOrHeight - Key block hash or height\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Key Block\n */\nexport async function getKeyBlock(hashOrHeight, _ref12) {\n  let {\n    onNode\n  } = _ref12;\n  if (typeof hashOrHeight === 'number') return onNode.getKeyBlockByHeight(hashOrHeight);\n  return onNode.getKeyBlockByHash(hashOrHeight);\n}\n\n/**\n * Get micro block header\n * @category chain\n * @param hash - Micro block hash\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Micro block header\n */\nexport async function getMicroBlockHeader(hash, _ref13) {\n  let {\n    onNode\n  } = _ref13;\n  return onNode.getMicroBlockHeaderByHash(hash);\n}\nconst txDryRunRequests = new Map();\nasync function txDryRunHandler(key, onNode) {\n  const rs = txDryRunRequests.get(key);\n  txDryRunRequests.delete(key);\n  if (rs == null) throw new InternalError('Can\\'t get dry-run request');\n  let dryRunRes;\n  try {\n    const top = typeof rs[0].top === 'number' ? (await getKeyBlock(rs[0].top, {\n      onNode\n    })).hash : rs[0].top;\n    dryRunRes = await onNode.protectedDryRunTxs({\n      top,\n      txEvents: rs[0].txEvents,\n      txs: rs.map(req => ({\n        tx: req.tx\n      })),\n      accounts: Array.from(new Set(rs.map(req => req.accountAddress))).map(pubKey => ({\n        pubKey,\n        amount: DRY_RUN_ACCOUNT.amount\n      }))\n    });\n  } catch (error) {\n    rs.forEach(_ref14 => {\n      let {\n        reject\n      } = _ref14;\n      return reject(error);\n    });\n    return;\n  }\n  const {\n    results,\n    txEvents\n  } = dryRunRes;\n  results.forEach((_ref15, idx) => {\n    let {\n      result,\n      reason,\n      ...resultPayload\n    } = _ref15;\n    const {\n      resolve,\n      reject,\n      tx,\n      accountAddress\n    } = rs[idx];\n    if (result === 'ok') resolve({\n      ...resultPayload,\n      txEvents\n    });else reject(Object.assign(new DryRunError(reason), {\n      tx,\n      accountAddress\n    }));\n  });\n}\n\n/**\n * Transaction dry-run\n * @category chain\n * @param tx - transaction to execute\n * @param accountAddress - address that will be used to execute transaction\n * @param options - Options\n * @param options.top - hash of block on which to make dry-run\n * @param options.txEvents - collect and return on-chain tx events that would result from the call\n * @param options.combine - Enables combining of similar requests to a single dry-run call\n * @param options.onNode - Node to use\n */\nexport async function txDryRun(tx, accountAddress, _ref16) {\n  var _txDryRunRequests$get;\n  let {\n    top,\n    txEvents,\n    combine,\n    onNode\n  } = _ref16;\n  const key = combine === true ? [top, txEvents].join() : 'immediate';\n  const requests = (_txDryRunRequests$get = txDryRunRequests.get(key)) !== null && _txDryRunRequests$get !== void 0 ? _txDryRunRequests$get : [];\n  txDryRunRequests.set(key, requests);\n  return new Promise((resolve, reject) => {\n    var _requests$timeout;\n    requests.push({\n      tx,\n      accountAddress,\n      top,\n      txEvents,\n      resolve,\n      reject\n    });\n    if (combine !== true) {\n      void txDryRunHandler(key, onNode);\n      return;\n    }\n    (_requests$timeout = requests.timeout) !== null && _requests$timeout !== void 0 ? _requests$timeout : requests.timeout = setTimeout(() => {\n      void txDryRunHandler(key, onNode);\n    });\n  });\n}\n\n/**\n * Get contract byte code\n * @category contract\n * @param contractId - Contract address\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getContractByteCode(contractId, _ref17) {\n  let {\n    onNode\n  } = _ref17;\n  return onNode.getContractCode(contractId);\n}\n\n/**\n * Get contract entry\n * @category contract\n * @param contractId - Contract address\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getContract(contractId, _ref18) {\n  let {\n    onNode\n  } = _ref18;\n  return onNode.getContract(contractId);\n}\n\n/**\n * Get name entry\n * @category AENS\n * @param name - AENS name\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getName(name, _ref19) {\n  let {\n    onNode\n  } = _ref19;\n  return onNode.getNameEntryByName(name);\n}\n\n/**\n * Resolve AENS name and return name hash\n * @category AENS\n * @param nameOrId - AENS name or address\n * @param key - in AENS pointers record\n * @param options - Options\n * @param options.verify - To ensure that name exist and have a corresponding pointer\n * // TODO: avoid that to don't trust to current api gateway\n * @param options.resolveByNode - Enables pointer resolving using node\n * @param options.onNode - Node to use\n * @returns Address or AENS name hash\n */\nexport async function resolveName(nameOrId, key, _ref20) {\n  let {\n    verify = true,\n    resolveByNode = false,\n    onNode\n  } = _ref20;\n  if (isNameValid(nameOrId)) {\n    if (verify || resolveByNode) {\n      const name = await onNode.getNameEntryByName(nameOrId);\n      const pointer = name.pointers.find(p => p.key === key);\n      if (pointer == null) throw new AensPointerContextError(nameOrId, key);\n      if (resolveByNode) return pointer.id;\n    }\n    return produceNameId(nameOrId);\n  }\n  try {\n    decode(nameOrId);\n    return nameOrId;\n  } catch (error) {\n    throw new InvalidAensNameError(`Invalid name or address: ${nameOrId}`);\n  }\n}","map":{"version":3,"names":["AE_AMOUNT_FORMATS","formatAmount","verifyTransaction","ensureError","isAccountNotFoundError","pause","isNameValid","produceNameId","DRY_RUN_ACCOUNT","AensPointerContextError","DryRunError","InvalidAensNameError","TransactionError","TxTimedOutError","TxNotInChainError","InternalError","decode","encode","Encoding","buildTxHash","_getPollInterval","type","_ref","_expectedMineRate","_microBlockCycle","_maxPollInterval","base","block","microblock","Math","min","InvalidTxError","constructor","message","validation","transaction","name","getHeight","_ref2","onNode","getCurrentKeyBlockHeight","height","poll","th","_ref3","_interval","blocks","interval","options","max","tx","getTransactionByHash","blockHeight","awaitHeight","_ref4","_interval2","currentHeight","waitForTxConfirm","txHash","_ref5","confirm","newBlockHeight","sendTransaction","txUnsigned","_ref6","onAccount","verify","waitMined","innerTx","signTransaction","networkId","getNetworkId","hash","rawTx","length","map","v","join","__queue","address","error","postTransaction","requestOptions","customHeaders","pollResult","txData","c","undefined","confirmationHeight","Object","assign","verifyTx","getAccount","_ref7","getAccountByPubkeyAndHeight","getAccountByPubkeyAndHash","getAccountByPubkey","getBalance","_ref8","format","AETTOS","addr","startsWith","AccountAddress","balance","catch","targetDenomination","getCurrentGeneration","_ref9","getGeneration","hashOrHeight","_ref10","getGenerationByHeight","getGenerationByHash","getMicroBlockTransactions","_ref11","getMicroBlockTransactionsByHash","transactions","getKeyBlock","_ref12","getKeyBlockByHeight","getKeyBlockByHash","getMicroBlockHeader","_ref13","getMicroBlockHeaderByHash","txDryRunRequests","Map","txDryRunHandler","key","rs","get","delete","dryRunRes","top","protectedDryRunTxs","txEvents","txs","req","accounts","Array","from","Set","accountAddress","pubKey","amount","forEach","_ref14","reject","results","_ref15","idx","result","reason","resultPayload","resolve","txDryRun","_ref16","_txDryRunRequests$get","combine","requests","set","Promise","_requests$timeout","push","timeout","setTimeout","getContractByteCode","contractId","_ref17","getContractCode","getContract","_ref18","getName","_ref19","getNameEntryByName","resolveName","nameOrId","_ref20","resolveByNode","pointer","pointers","find","p","id"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\chain.ts"],"sourcesContent":["import { AE_AMOUNT_FORMATS, formatAmount } from './utils/amount-formatter';\nimport verifyTransaction, { ValidatorResult } from './tx/validator';\nimport { ensureError, isAccountNotFoundError, pause } from './utils/other';\nimport { isNameValid, produceNameId } from './tx/builder/helpers';\nimport { DRY_RUN_ACCOUNT } from './tx/builder/schema';\nimport { AensName } from './tx/builder/constants';\nimport {\n  AensPointerContextError, DryRunError, InvalidAensNameError, TransactionError,\n  TxTimedOutError, TxNotInChainError, InternalError,\n} from './utils/errors';\nimport Node, { TransformNodeType } from './Node';\nimport {\n  Account as AccountNode, ByteCode, ContractObject, DryRunResult, DryRunResults,\n  Generation, KeyBlock, MicroBlockHeader, NameEntry, SignedTx,\n} from './apis/node';\nimport {\n  decode, encode, Encoded, Encoding,\n} from './utils/encoder';\nimport AccountBase from './account/Base';\nimport { buildTxHash } from './tx/builder';\n\n/**\n * @category chain\n */\nexport function _getPollInterval(\n  type: 'block' | 'microblock', // TODO: rename to 'key-block' | 'micro-block'\n  { _expectedMineRate = 180000, _microBlockCycle = 3000, _maxPollInterval = 5000 }:\n  { _expectedMineRate?: number; _microBlockCycle?: number; _maxPollInterval?: number },\n): number {\n  const base = {\n    block: _expectedMineRate,\n    microblock: _microBlockCycle,\n  }[type];\n  return Math.min(base / 3, _maxPollInterval);\n}\n\n/**\n * @category exception\n */\nexport class InvalidTxError extends TransactionError {\n  validation: ValidatorResult[];\n\n  transaction: Encoded.Transaction;\n\n  constructor(\n    message: string,\n    validation: ValidatorResult[],\n    transaction: Encoded.Transaction,\n  ) {\n    super(message);\n    this.name = 'InvalidTxError';\n    this.validation = validation;\n    this.transaction = transaction;\n  }\n}\n\n/**\n * Obtain current height of the chain\n * @category chain\n * @returns Current chain height\n */\nexport async function getHeight({ onNode }: { onNode: Node }): Promise<number> {\n  return (await onNode.getCurrentKeyBlockHeight()).height;\n}\n\n/**\n * Wait for a transaction to be mined\n * @category chain\n * @param th - The hash of transaction to poll\n * @param options - Options\n * @param options.interval - Interval (in ms) at which to poll the chain\n * @param options.blocks - Number of blocks mined after which to fail\n * @param options.onNode - Node to use\n * @returns The transaction as it was mined\n */\nexport async function poll(\n  th: Encoded.TxHash,\n  {\n    blocks = 5, interval, onNode, ...options\n  }:\n  { blocks?: number; interval?: number; onNode: Node } & Parameters<typeof _getPollInterval>[1],\n): Promise<TransformNodeType<SignedTx>> {\n  interval ??= _getPollInterval('microblock', options);\n  const max = await getHeight({ onNode }) + blocks;\n  do {\n    const tx = await onNode.getTransactionByHash(th);\n    if (tx.blockHeight !== -1) return tx;\n    await pause(interval);\n  } while (await getHeight({ onNode }) < max);\n  throw new TxTimedOutError(blocks, th);\n}\n\n/**\n * Wait for the chain to reach a specific height\n * @category chain\n * @param height - Height to wait for\n * @param options - Options\n * @param options.interval - Interval (in ms) at which to poll the chain\n * @param options.onNode - Node to use\n * @returns Current chain height\n */\nexport async function awaitHeight(\n  height: number,\n  { interval, onNode, ...options }:\n  { interval?: number; onNode: Node } & Parameters<typeof _getPollInterval>[1],\n): Promise<number> {\n  interval ??= _getPollInterval('block', options);\n  let currentHeight;\n  do {\n    if (currentHeight != null) await pause(interval);\n    currentHeight = (await onNode.getCurrentKeyBlockHeight()).height;\n  } while (currentHeight < height);\n  return currentHeight;\n}\n\n/**\n * Wait for transaction confirmation\n * @category chain\n * @param txHash - Transaction hash\n * @param options - Options\n * @param options.confirm - Number of micro blocks to wait for transaction confirmation\n * @param options.onNode - Node to use\n * @returns Current Height\n */\nexport async function waitForTxConfirm(\n  txHash: Encoded.TxHash,\n  { confirm = 3, onNode, ...options }:\n  { confirm?: number; onNode: Node } & Parameters<typeof awaitHeight>[1],\n): Promise<number> {\n  const { blockHeight } = await onNode.getTransactionByHash(txHash);\n  const height = await awaitHeight(blockHeight + confirm, { onNode, ...options });\n  const { blockHeight: newBlockHeight } = await onNode.getTransactionByHash(txHash);\n  switch (newBlockHeight) {\n    case -1:\n      throw new TxNotInChainError(txHash);\n    case blockHeight:\n      return height;\n    default:\n      return waitForTxConfirm(txHash, { onNode, confirm, ...options });\n  }\n}\n\n/**\n * Signs and submits transaction for mining\n * @category chain\n * @param txUnsigned - Transaction to sign and submit\n * @param options - Options\n * @param options.onNode - Node to use\n * @param options.onAccount - Account to use\n * @param options.verify - Verify transaction before broadcast, throw error if not\n * @param options.waitMined - Ensure that transaction get into block\n * @param options.confirm - Number of micro blocks that should be mined after tx get included\n * @returns Transaction details\n */\nexport async function sendTransaction(\n  txUnsigned: Encoded.Transaction,\n  {\n    onNode, onAccount, verify = true, waitMined = true, confirm, innerTx, ...options\n  }:\n  SendTransactionOptions,\n): Promise<SendTransactionReturnType> {\n  const tx = await onAccount.signTransaction(txUnsigned, {\n    ...options,\n    onNode,\n    innerTx,\n    networkId: await onNode.getNetworkId(),\n  });\n\n  if (innerTx === true) return { hash: buildTxHash(tx), rawTx: tx };\n\n  if (verify) {\n    const validation = await verifyTransaction(tx, onNode);\n    if (validation.length > 0) {\n      const message = `Transaction verification errors: ${\n        validation.map((v: { message: string }) => v.message).join(', ')}`;\n      throw new InvalidTxError(message, validation, tx);\n    }\n  }\n\n  try {\n    let __queue;\n    try {\n      __queue = onAccount != null ? `tx-${onAccount.address}` : null;\n    } catch (error) {\n      __queue = null;\n    }\n    const { txHash } = await onNode.postTransaction(\n      { tx },\n      __queue != null ? { requestOptions: { customHeaders: { __queue } } } : {},\n    );\n\n    if (waitMined) {\n      const pollResult = await poll(txHash, { onNode, ...options });\n      const txData = {\n        ...pollResult,\n        hash: pollResult.hash as Encoded.TxHash,\n        rawTx: tx,\n      };\n      // wait for transaction confirmation\n      if (confirm != null && +confirm > 0) {\n        const c = typeof confirm === 'boolean' ? undefined : confirm;\n        return {\n          ...txData,\n          confirmationHeight: await waitForTxConfirm(txHash, { onNode, confirm: c, ...options }),\n        };\n      }\n      return txData;\n    }\n    return { hash: txHash, rawTx: tx };\n  } catch (error) {\n    ensureError(error);\n    throw Object.assign(error, {\n      rawTx: tx,\n      verifyTx: async () => verifyTransaction(tx, onNode),\n    });\n  }\n}\n\ntype SendTransactionOptionsType = {\n  onNode: Node;\n  onAccount: AccountBase;\n  verify?: boolean;\n  waitMined?: boolean;\n  confirm?: boolean | number;\n} & Parameters<typeof poll>[1] & Omit<Parameters<typeof waitForTxConfirm>[1], 'confirm'>\n& Parameters<AccountBase['signTransaction']>[1];\nexport interface SendTransactionOptions extends SendTransactionOptionsType {}\ninterface SendTransactionReturnType extends Partial<TransformNodeType<SignedTx>> {\n  hash: Encoded.TxHash;\n  rawTx: Encoded.Transaction;\n  confirmationHeight?: number;\n}\n\n/**\n * Get account by account public key\n * @category chain\n * @param address - Account address (public key)\n * @param options - Options\n * @param options.height - Get account on specific block by block height\n * @param options.hash - Get account on specific block by micro block hash or key block hash\n * @param options.onNode - Node to use\n */\nexport async function getAccount(\n  address: Encoded.AccountAddress | Encoded.ContractAddress,\n  { height, hash, onNode }:\n  { height?: number; hash?: Encoded.KeyBlockHash | Encoded.MicroBlockHash; onNode: Node },\n): Promise<TransformNodeType<AccountNode>> {\n  if (height != null) return onNode.getAccountByPubkeyAndHeight(address, height);\n  if (hash != null) return onNode.getAccountByPubkeyAndHash(address, hash);\n  return onNode.getAccountByPubkey(address);\n}\n\n/**\n * Request the balance of specified account\n * @category chain\n * @param address - The public account address to obtain the balance for\n * @param options - Options\n * @param options.format\n * @param options.height - The chain height at which to obtain the balance for\n * (default: top of chain)\n * @param options.hash - The block hash on which to obtain the balance for (default: top of chain)\n */\nexport async function getBalance(\n  address: Encoded.AccountAddress | Encoded.ContractAddress | Encoded.OracleAddress,\n  { format = AE_AMOUNT_FORMATS.AETTOS, ...options }:\n  { format?: AE_AMOUNT_FORMATS } & Parameters<typeof getAccount>[1],\n): Promise<string> {\n  const addr = address.startsWith('ok_')\n    ? encode(decode(address), Encoding.AccountAddress)\n    : address as Encoded.AccountAddress | Encoded.ContractAddress;\n\n  const { balance } = await getAccount(addr, options).catch((error) => {\n    if (!isAccountNotFoundError(error)) throw error;\n    return { balance: 0n };\n  });\n\n  return formatAmount(balance, { targetDenomination: format });\n}\n\n/**\n * Obtain current generation\n * @category chain\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Current Generation\n */\nexport async function getCurrentGeneration(\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<Generation>> {\n  return onNode.getCurrentGeneration();\n}\n\n/**\n * Get generation by hash or height\n * @category chain\n * @param hashOrHeight - Generation hash or height\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Generation\n */\nexport async function getGeneration(\n  hashOrHeight: Encoded.KeyBlockHash | number,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<Generation>> {\n  if (typeof hashOrHeight === 'number') return onNode.getGenerationByHeight(hashOrHeight);\n  return onNode.getGenerationByHash(hashOrHeight);\n}\n\n/**\n * Get micro block transactions\n * @category chain\n * @param hash - Micro block hash\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Transactions\n */\nexport async function getMicroBlockTransactions(\n  hash: Encoded.MicroBlockHash,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<SignedTx[]>> {\n  return (await onNode.getMicroBlockTransactionsByHash(hash)).transactions;\n}\n\n/**\n * Get key block\n * @category chain\n * @param hashOrHeight - Key block hash or height\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Key Block\n */\nexport async function getKeyBlock(\n  hashOrHeight: Encoded.KeyBlockHash | number,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<KeyBlock>> {\n  if (typeof hashOrHeight === 'number') return onNode.getKeyBlockByHeight(hashOrHeight);\n  return onNode.getKeyBlockByHash(hashOrHeight);\n}\n\n/**\n * Get micro block header\n * @category chain\n * @param hash - Micro block hash\n * @param options - Options\n * @param options.onNode - Node to use\n * @returns Micro block header\n */\nexport async function getMicroBlockHeader(\n  hash: Encoded.MicroBlockHash,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<MicroBlockHeader>> {\n  return onNode.getMicroBlockHeaderByHash(hash);\n}\n\ninterface TxDryRunArguments {\n  tx: Encoded.Transaction;\n  accountAddress: Encoded.AccountAddress;\n  top?: number | Encoded.KeyBlockHash | Encoded.MicroBlockHash;\n  txEvents?: any;\n  resolve: Function;\n  reject: Function;\n}\nconst txDryRunRequests: Map<string, TxDryRunArguments[] & { timeout?: NodeJS.Timeout }> = new Map();\n\nasync function txDryRunHandler(key: string, onNode: Node): Promise<void> {\n  const rs = txDryRunRequests.get(key);\n  txDryRunRequests.delete(key);\n  if (rs == null) throw new InternalError('Can\\'t get dry-run request');\n\n  let dryRunRes;\n  try {\n    const top = typeof rs[0].top === 'number'\n      ? (await getKeyBlock(rs[0].top, { onNode })).hash : rs[0].top;\n    dryRunRes = await onNode.protectedDryRunTxs({\n      top,\n      txEvents: rs[0].txEvents,\n      txs: rs.map((req) => ({ tx: req.tx })),\n      accounts: Array.from(new Set(rs.map((req) => req.accountAddress)))\n        .map((pubKey) => ({ pubKey, amount: DRY_RUN_ACCOUNT.amount })),\n    });\n  } catch (error) {\n    rs.forEach(({ reject }) => reject(error));\n    return;\n  }\n\n  const { results, txEvents } = dryRunRes;\n  results.forEach(({ result, reason, ...resultPayload }, idx) => {\n    const {\n      resolve, reject, tx, accountAddress,\n    } = rs[idx];\n    if (result === 'ok') resolve({ ...resultPayload, txEvents });\n    else reject(Object.assign(new DryRunError(reason as string), { tx, accountAddress }));\n  });\n}\n\n/**\n * Transaction dry-run\n * @category chain\n * @param tx - transaction to execute\n * @param accountAddress - address that will be used to execute transaction\n * @param options - Options\n * @param options.top - hash of block on which to make dry-run\n * @param options.txEvents - collect and return on-chain tx events that would result from the call\n * @param options.combine - Enables combining of similar requests to a single dry-run call\n * @param options.onNode - Node to use\n */\nexport async function txDryRun(\n  tx: Encoded.Transaction,\n  accountAddress: Encoded.AccountAddress,\n  {\n    top, txEvents, combine, onNode,\n  }:\n  { top?: TxDryRunArguments['top']; txEvents?: boolean; combine?: boolean; onNode: Node },\n): Promise<{\n    txEvents?: TransformNodeType<DryRunResults['txEvents']>;\n  } & TransformNodeType<DryRunResult>> {\n  const key = combine === true ? [top, txEvents].join() : 'immediate';\n  const requests = txDryRunRequests.get(key) ?? [];\n  txDryRunRequests.set(key, requests);\n  return new Promise((resolve, reject) => {\n    requests.push({\n      tx, accountAddress, top, txEvents, resolve, reject,\n    });\n    if (combine !== true) {\n      void txDryRunHandler(key, onNode);\n      return;\n    }\n    requests.timeout ??= setTimeout(() => { void txDryRunHandler(key, onNode); });\n  });\n}\n\n/**\n * Get contract byte code\n * @category contract\n * @param contractId - Contract address\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getContractByteCode(\n  contractId: Encoded.ContractAddress,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<ByteCode>> {\n  return onNode.getContractCode(contractId);\n}\n\n/**\n * Get contract entry\n * @category contract\n * @param contractId - Contract address\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getContract(\n  contractId: Encoded.ContractAddress,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<ContractObject>> {\n  return onNode.getContract(contractId);\n}\n\n/**\n * Get name entry\n * @category AENS\n * @param name - AENS name\n * @param options - Options\n * @param options.onNode - Node to use\n */\nexport async function getName(\n  name: AensName,\n  { onNode }: { onNode: Node },\n): Promise<TransformNodeType<NameEntry>> {\n  return onNode.getNameEntryByName(name);\n}\n\n/**\n * Resolve AENS name and return name hash\n * @category AENS\n * @param nameOrId - AENS name or address\n * @param key - in AENS pointers record\n * @param options - Options\n * @param options.verify - To ensure that name exist and have a corresponding pointer\n * // TODO: avoid that to don't trust to current api gateway\n * @param options.resolveByNode - Enables pointer resolving using node\n * @param options.onNode - Node to use\n * @returns Address or AENS name hash\n */\nexport async function resolveName <\n  Type extends Encoding.AccountAddress | Encoding.ContractAddress,\n>(\n  nameOrId: AensName | Encoded.Generic<Type>,\n  key: string,\n  { verify = true, resolveByNode = false, onNode }:\n  { verify?: boolean; resolveByNode?: boolean; onNode: Node },\n): Promise<Encoded.Generic<Type | Encoding.Name>> {\n  if (isNameValid(nameOrId)) {\n    if (verify || resolveByNode) {\n      const name = await onNode.getNameEntryByName(nameOrId);\n      const pointer = name.pointers.find((p) => p.key === key);\n      if (pointer == null) throw new AensPointerContextError(nameOrId, key);\n      if (resolveByNode) return pointer.id as Encoded.Generic<Type>;\n    }\n    return produceNameId(nameOrId);\n  }\n  try {\n    decode(nameOrId);\n    return nameOrId;\n  } catch (error) {\n    throw new InvalidAensNameError(`Invalid name or address: ${nameOrId}`);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}