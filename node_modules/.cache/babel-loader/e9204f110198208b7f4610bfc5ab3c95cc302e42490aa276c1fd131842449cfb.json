{"ast":null,"code":"const ContractEncoder = require('./ContractEncoder');\nconst TypeResolveError = require('./Errors/TypeResolveError');\nconst {\n  FateTypeVoid,\n  FateTypeTuple,\n  FateTypeEvent,\n  FateTypeList,\n  FateTypeMap,\n  FateTypeVariant,\n  FateTypeOracleAddress,\n  FateTypeOracleQueryAddress\n} = require('./FateTypes');\nclass BytecodeTypeResolver {\n  constructor(encodedContract) {\n    this._contractEncoder = new ContractEncoder();\n    this._encodedContract = encodedContract;\n    this._contract = null;\n  }\n  get _bytecode() {\n    if (this._contract === null) {\n      this._contract = this._contractEncoder.decode(this._encodedContract);\n    }\n    return this._contract.bytecode;\n  }\n  getFunctionId(funName) {\n    const {\n      symbols\n    } = this._bytecode;\n    return Object.keys(symbols).find(key => symbols[key] === funName);\n  }\n  getFunction(id) {\n    const {\n      functions\n    } = this._bytecode;\n    return functions.find(f => f.id === id);\n  }\n  getFunctionName(id) {\n    const {\n      name\n    } = this.getFunction(id);\n    return name;\n  }\n  getCallTypes(funName) {\n    const fun = this.getFunction(this.getFunctionId(funName));\n    if (fun) {\n      const types = fun.args.valueTypes.map(t => this.resolveType(t));\n      return {\n        types,\n        required: types.length\n      };\n    }\n    if (funName === 'init') {\n      return {\n        types: [],\n        required: 0\n      };\n    }\n    throw new TypeResolveError(`Unknown function ${funName}`);\n  }\n  getReturnType(funName) {\n    if (funName === 'init') {\n      return FateTypeVoid();\n    }\n    const fun = this.getFunction(this.getFunctionId(funName));\n    if (fun) {\n      return this.resolveType(fun.returnType);\n    }\n    throw new TypeResolveError(`Unknown function ${funName}`);\n  }\n  getEventType(topics) {\n    const fun = this.getFunction(this.getFunctionId('Chain.event'));\n    if (!fun) {\n      throw new TypeResolveError('The contract does not have event declaration');\n    }\n    const variantType = fun.args.valueTypes[0];\n    return FateTypeEvent(this.resolveType(variantType), topics);\n  }\n  resolveType(type) {\n    if (type.name === 'variant') {\n      const variants = type.variants.map((el, idx) => {\n        const valueTypes = el.valueTypes.map(v => this.resolveType(v));\n        return {\n          [idx]: valueTypes\n        };\n      });\n      return FateTypeVariant(variants);\n    }\n    let resolvedTypes = [];\n    if (Array.isArray(type.valueTypes)) {\n      resolvedTypes = type.valueTypes.map(t => this.resolveType(t));\n    }\n    if (type.name === 'tuple') {\n      return FateTypeTuple(resolvedTypes);\n    }\n    if (type.name === 'list') {\n      return FateTypeList(...resolvedTypes);\n    }\n    if (type.name === 'map') {\n      return FateTypeMap(...resolvedTypes);\n    }\n    if (type.name === 'oracle') {\n      return FateTypeOracleAddress(...resolvedTypes);\n    }\n    if (type.name === 'oracle_query') {\n      return FateTypeOracleQueryAddress(...resolvedTypes);\n    }\n    return type;\n  }\n}\nmodule.exports = BytecodeTypeResolver;","map":{"version":3,"names":["ContractEncoder","require","TypeResolveError","FateTypeVoid","FateTypeTuple","FateTypeEvent","FateTypeList","FateTypeMap","FateTypeVariant","FateTypeOracleAddress","FateTypeOracleQueryAddress","BytecodeTypeResolver","constructor","encodedContract","_contractEncoder","_encodedContract","_contract","_bytecode","decode","bytecode","getFunctionId","funName","symbols","Object","keys","find","key","getFunction","id","functions","f","getFunctionName","name","getCallTypes","fun","types","args","valueTypes","map","t","resolveType","required","length","getReturnType","returnType","getEventType","topics","variantType","type","variants","el","idx","v","resolvedTypes","Array","isArray","module","exports"],"sources":["C:/Users/amitk/Desktop/Donation Project/donation-aeternity-blockchain-contract/node_modules/@aeternity/aepp-calldata/src/BytecodeTypeResolver.js"],"sourcesContent":["const ContractEncoder = require('./ContractEncoder')\nconst TypeResolveError = require('./Errors/TypeResolveError')\nconst {\n    FateTypeVoid,\n    FateTypeTuple,\n    FateTypeEvent,\n    FateTypeList,\n    FateTypeMap,\n    FateTypeVariant,\n    FateTypeOracleAddress,\n    FateTypeOracleQueryAddress,\n} = require('./FateTypes')\n\nclass BytecodeTypeResolver {\n    constructor(encodedContract) {\n        this._contractEncoder = new ContractEncoder()\n        this._encodedContract = encodedContract\n        this._contract = null\n    }\n\n    get _bytecode() {\n        if (this._contract === null) {\n            this._contract = this._contractEncoder.decode(this._encodedContract)\n        }\n\n        return this._contract.bytecode\n    }\n\n    getFunctionId(funName) {\n        const {symbols} = this._bytecode\n\n        return Object.keys(symbols).find(key => symbols[key] === funName)\n    }\n\n    getFunction(id) {\n        const {functions} = this._bytecode\n\n        return functions.find(f => f.id === id)\n    }\n\n    getFunctionName(id) {\n        const {name} = this.getFunction(id)\n\n        return name\n    }\n\n    getCallTypes(funName) {\n        const fun = this.getFunction(this.getFunctionId(funName))\n\n        if (fun) {\n            const types = fun.args.valueTypes.map(t => this.resolveType(t))\n            return {\n                types,\n                required: types.length\n            }\n        }\n\n        if (funName === 'init') {\n            return {types: [], required: 0}\n        }\n\n        throw new TypeResolveError(`Unknown function ${funName}`)\n    }\n\n    getReturnType(funName) {\n        if (funName === 'init') {\n            return FateTypeVoid()\n        }\n\n        const fun = this.getFunction(this.getFunctionId(funName))\n\n        if (fun) {\n            return this.resolveType(fun.returnType)\n        }\n\n        throw new TypeResolveError(`Unknown function ${funName}`)\n    }\n\n    getEventType(topics) {\n        const fun = this.getFunction(this.getFunctionId('Chain.event'))\n\n        if (!fun) {\n            throw new TypeResolveError('The contract does not have event declaration')\n        }\n\n        const variantType = fun.args.valueTypes[0]\n\n        return FateTypeEvent(this.resolveType(variantType), topics)\n    }\n\n    resolveType(type) {\n        if (type.name === 'variant') {\n            const variants = type.variants.map((el, idx) => {\n                const valueTypes = el.valueTypes.map(v => this.resolveType(v))\n                return {[idx]: valueTypes}\n            })\n\n            return FateTypeVariant(variants)\n        }\n\n        let resolvedTypes = []\n        if (Array.isArray(type.valueTypes)) {\n            resolvedTypes = type.valueTypes.map(t => this.resolveType(t))\n        }\n\n        if (type.name === 'tuple') {\n            return FateTypeTuple(resolvedTypes)\n        }\n\n        if (type.name === 'list') {\n            return FateTypeList(...resolvedTypes)\n        }\n\n        if (type.name === 'map') {\n            return FateTypeMap(...resolvedTypes)\n        }\n\n        if (type.name === 'oracle') {\n            return FateTypeOracleAddress(...resolvedTypes)\n        }\n\n        if (type.name === 'oracle_query') {\n            return FateTypeOracleQueryAddress(...resolvedTypes)\n        }\n\n        return type\n    }\n}\n\nmodule.exports = BytecodeTypeResolver\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}