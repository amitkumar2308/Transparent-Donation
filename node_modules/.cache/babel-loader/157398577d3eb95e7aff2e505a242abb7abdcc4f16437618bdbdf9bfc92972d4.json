{"ast":null,"code":"const ApiEncoder = require('../ApiEncoder');\nconst {\n  int2MontBytes\n} = require('../utils/bls12381');\nconst FateTypeError = require('../Errors/FateTypeError');\n\n/**\n * Map Aesophia canonical structures and formats to internal representation FATE data structures.\n */\nclass InternalMapper {\n  constructor() {\n    this._apiEncoder = new ApiEncoder();\n  }\n  toInternal(type, value) {\n    switch (type.name) {\n      case 'account_pubkey':\n      case 'contract_pubkey':\n      case 'channel':\n      case 'oracle_pubkey':\n      case 'oracle_query_id':\n        return this.toAddress(type, value);\n      case 'variant':\n        return this.toVariant(type, value);\n      case 'map':\n        return this.toMap(type, value);\n      case 'set':\n        return this.toSet(type, value);\n      case 'record':\n        return this.toRecord(type, value);\n      case 'bls12_381.fr':\n        return this.toBls12381Fr(type, value);\n      case 'bls12_381.fp':\n        return this.toBls12381Fp(type, value);\n      default:\n        return value;\n    }\n  }\n  toAddress({\n    name,\n    _\n  }, value) {\n    return this._apiEncoder.decodeWithType(value, name);\n  }\n  toVariant(type, value) {\n    if (!this.isOptionVariant(type)) {\n      return value;\n    }\n    if ([undefined, null].includes(value)) {\n      return {\n        None: []\n      };\n    }\n    const [variantName] = Object.keys(value);\n    if (['Some', 'None'].includes(variantName)) {\n      return value;\n    }\n    return {\n      Some: [value]\n    };\n  }\n  isOptionVariant({\n    _name,\n    variants\n  }) {\n    return variants.some(({\n      None\n    }) => None && None.length === 0) && variants.some(({\n      Some\n    }) => Some);\n  }\n  toMap(type, value) {\n    if (typeof value !== 'object' || value === null) {\n      throw new FateTypeError('map', `Fate map must be one of: Map, Array, Object; got ${value} instead`);\n    }\n    return Array.isArray(value) || value instanceof Map ? value : Object.entries(value);\n  }\n  toSet(type, value) {\n    if (value instanceof Set) {\n      return value;\n    }\n    if (Array.isArray(value)) {\n      return new Set(value);\n    }\n    throw new FateTypeError('set', `Fate set must be a Set or Array, got \"${value}\" instead`);\n  }\n  toRecord(type, record) {\n    return type.keys.reduce((v, name) => ({\n      ...v,\n      [name]: record[name]\n    }), {});\n  }\n  validateBls12381Field(type, value) {\n    if (typeof value !== 'bigint' && !Number.isInteger(value)) {\n      throw new FateTypeError(type.name, `Should be one of: BigInt or Number; got ${value} instead`);\n    }\n  }\n  toBls12381Fr(type, value) {\n    this.validateBls12381Field(type, value);\n    return int2MontBytes(value, 'r');\n  }\n  toBls12381Fp(type, value) {\n    this.validateBls12381Field(type, value);\n    return int2MontBytes(value, 'p');\n  }\n}\nmodule.exports = InternalMapper;","map":{"version":3,"names":["ApiEncoder","require","int2MontBytes","FateTypeError","InternalMapper","constructor","_apiEncoder","toInternal","type","value","name","toAddress","toVariant","toMap","toSet","toRecord","toBls12381Fr","toBls12381Fp","_","decodeWithType","isOptionVariant","undefined","includes","None","variantName","Object","keys","Some","_name","variants","some","length","Array","isArray","Map","entries","Set","record","reduce","v","validateBls12381Field","Number","isInteger","module","exports"],"sources":["C:/Users/amitk/Desktop/Donation Project/donation-aeternity-blockchain-contract/node_modules/@aeternity/aepp-calldata/src/Mapper/InternalMapper.js"],"sourcesContent":["const ApiEncoder = require('../ApiEncoder')\nconst {int2MontBytes} = require('../utils/bls12381')\nconst FateTypeError = require('../Errors/FateTypeError')\n\n/**\n * Map Aesophia canonical structures and formats to internal representation FATE data structures.\n */\nclass InternalMapper {\n    constructor() {\n        this._apiEncoder = new ApiEncoder()\n    }\n\n    toInternal(type, value) {\n        switch (type.name) {\n        case 'account_pubkey':\n        case 'contract_pubkey':\n        case 'channel':\n        case 'oracle_pubkey':\n        case 'oracle_query_id':\n            return this.toAddress(type, value)\n        case 'variant':\n            return this.toVariant(type, value)\n        case 'map':\n            return this.toMap(type, value)\n        case 'set':\n            return this.toSet(type, value)\n        case 'record':\n            return this.toRecord(type, value)\n        case 'bls12_381.fr':\n            return this.toBls12381Fr(type, value)\n        case 'bls12_381.fp':\n            return this.toBls12381Fp(type, value)\n        default:\n            return value\n        }\n    }\n\n    toAddress({name, _}, value) {\n        return this._apiEncoder.decodeWithType(value, name)\n    }\n\n    toVariant(type, value) {\n        if (!this.isOptionVariant(type)) {\n            return value\n        }\n\n        if ([undefined, null].includes(value)) {\n            return {None: []}\n        }\n\n        const [variantName] = Object.keys(value)\n        if (['Some', 'None'].includes(variantName)) {\n            return value\n        }\n\n        return {Some: [value]}\n    }\n\n    isOptionVariant({ _name, variants }) {\n        return variants.some(({ None }) => None && None.length === 0)\n            && variants.some(({ Some }) => Some)\n    }\n\n    toMap(type, value) {\n        if (typeof value !== 'object' || value === null) {\n            throw new FateTypeError(\n                'map',\n                `Fate map must be one of: Map, Array, Object; got ${value} instead`\n            )\n        }\n\n        return Array.isArray(value) || value instanceof Map ? value : Object.entries(value)\n    }\n\n    toSet(type, value) {\n        if (value instanceof Set) {\n            return value\n        }\n\n        if (Array.isArray(value)) {\n            return new Set(value)\n        }\n\n        throw new FateTypeError(\n            'set',\n            `Fate set must be a Set or Array, got \"${value}\" instead`\n        )\n    }\n\n    toRecord(type, record) {\n        return type.keys.reduce((v, name) => ({ ...v, [name]: record[name] }), {})\n    }\n\n    validateBls12381Field(type, value) {\n        if (typeof value !== 'bigint' && !Number.isInteger(value)) {\n            throw new FateTypeError(\n                type.name,\n                `Should be one of: BigInt or Number; got ${value} instead`\n            )\n        }\n    }\n\n    toBls12381Fr(type, value) {\n        this.validateBls12381Field(type, value)\n\n        return int2MontBytes(value, 'r')\n    }\n\n    toBls12381Fp(type, value) {\n        this.validateBls12381Field(type, value)\n\n        return int2MontBytes(value, 'p')\n    }\n}\n\nmodule.exports = InternalMapper\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}