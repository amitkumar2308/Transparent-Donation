{"ast":null,"code":"const RLP = require('rlp');\nconst BaseSerializer = require('./BaseSerializer');\nconst TypeSerializer = require('./TypeSerializer');\nconst {\n  byteArray2Hex,\n  byteArray2Int\n} = require('../utils/int2ByteArray');\nconst OPCODES = require('../FateOpcodes');\nconst {\n  FateTypeByteArray,\n  FateTypeString,\n  FateTypeMap\n} = require('../FateTypes');\nconst MODIFIERS = {\n  0b11: 'immediate',\n  0b10: 'var',\n  0b01: 'arg',\n  0b00: 'stack'\n};\nconst splitArgs = (data, n = 1) => {\n  const args = [];\n  let bits = Number(byteArray2Int(data));\n  for (let i = 0; i < n * 2; i += 2) {\n    args.push(bits & 0b11);\n    bits >>= 2;\n  }\n  if (bits !== 0) {\n    throw new Error(`Invalid argument modifier data. Unexpected padding: 0b${bits.toString(2)}`);\n  }\n  return args;\n};\nclass BytecodeSerializer extends BaseSerializer {\n  constructor(globalSerializer) {\n    super(globalSerializer);\n    this._typeSerializer = new TypeSerializer();\n  }\n  deserialize(data) {\n    const codeBin = RLP.decode(data, true);\n    const symbolsBin = RLP.decode(codeBin.remainder, true);\n    const annotationsBin = RLP.decode(symbolsBin.remainder);\n    const symbols = this.deserializeSymbols(symbolsBin.data);\n    const functions = this.deserializeFunctions(codeBin.data, symbols);\n    const annotations = this.deserializeAnnotations(annotationsBin);\n    return {\n      functions,\n      symbols,\n      annotations\n    };\n  }\n  deserializeFunctions(data, symbols) {\n    let fun = {};\n    let rest = data;\n    const functions = [];\n    while (rest.length) {\n      [fun, rest] = this.deserializeFunction(rest, symbols);\n      functions.push(fun);\n    }\n    return functions;\n  }\n  deserializeFunction(data, symbols) {\n    const prefix = data[0];\n    const id = byteArray2Hex(data.slice(1, 5));\n    if (prefix !== 0xfe) {\n      throw new Error(`Wrong function prefix, expeted 0xfe got 0x${data[0].toString(16)}`);\n    }\n    const name = symbols[id];\n    const [attributes, rest2] = this.deserializeAttributes(data.slice(5));\n    const [args, returnType, rest3] = this.deserializeSignature(rest2);\n    const [instructions, rest4] = this.deserializeInstructions(rest3);\n    return [{\n      id,\n      name,\n      attributes,\n      args,\n      returnType,\n      instructions\n    }, rest4];\n  }\n  deserializeInstructions(data) {\n    let instruction = {};\n    let rest = data;\n    const instructions = [];\n    let block = 0;\n    let end = false;\n    while (rest.length && rest[0] !== 0xfe) {\n      if (instructions[block] === undefined) {\n        instructions[block] = [];\n      }\n      [instruction, rest, end] = this.deserializeInstruction(rest);\n      instructions[block].push(instruction);\n      if (end) {\n        block++;\n      }\n    }\n    return [instructions, rest];\n  }\n  deserializeInstruction(data) {\n    const opcode = data[0];\n    const rest = data.slice(1);\n    if (!OPCODES.hasOwnProperty(opcode)) {\n      throw new Error(`Unsupported opcode: 0x${opcode.toString(16)}`);\n    }\n    const instr = OPCODES[opcode];\n    const {\n      mnemonic,\n      end\n    } = instr;\n    if (instr.args === 0) {\n      return [{\n        mnemonic,\n        args: []\n      }, rest, end];\n    }\n    const [args, rest2] = this.deserializeArguments(rest, instr.args);\n    return [{\n      mnemonic,\n      args\n    }, rest2, end];\n  }\n  deserializeArguments(data, n) {\n    const numBytes = n <= 4 ? 1 : 2;\n    const modBytes = data.subarray(0, numBytes);\n    const rest = data.slice(numBytes);\n    const modifiers = splitArgs(modBytes, n);\n    const args = [];\n    let rest2 = rest;\n    let arg;\n    modifiers.forEach(mod => {\n      [arg, rest2] = this.deserializeArgument(mod, rest2);\n      args.push(arg);\n    });\n    return [args, rest2];\n  }\n  deserializeArgument(bits, stream) {\n    const mod = MODIFIERS[bits];\n    if (mod === 'stack') {\n      return [{\n        mod,\n        arg: 0\n      }, stream];\n    }\n    const [arg, rest] = this.globalSerializer.deserializeStream(stream);\n    return [{\n      mod,\n      arg: arg.valueOf()\n    }, rest];\n  }\n  deserializeSignature(data) {\n    const [args, rest] = this._typeSerializer.deserializeStream(data);\n    const [returnType, rest2] = this._typeSerializer.deserializeStream(rest);\n    return [args, returnType, rest2];\n  }\n  deserializeAttributes(data) {\n    const [attributesInt, rest] = this.globalSerializer.deserializeStream(data);\n    const attributesByte = Number(attributesInt.valueOf());\n    const attributes = [];\n    if (attributesByte & 0b0001) {\n      attributes.push('private');\n    }\n    if (attributesByte & 0b0010) {\n      attributes.push('payable');\n    }\n    return [attributes, rest];\n  }\n  deserializeSymbols(data) {\n    // Needs typehint with ByteArray otherwise deserializes to string\n    const type = FateTypeMap(FateTypeByteArray(), FateTypeString());\n    const symbols = this.globalSerializer.deserializeWithType(data, type).valueOf();\n    const symbolsMap = {};\n    symbols.forEach((val, key) => {\n      const hex = byteArray2Hex(key);\n      symbolsMap[hex] = val;\n    });\n    return symbolsMap;\n  }\n  deserializeAnnotations(data) {\n    const annotations = this.globalSerializer.deserialize(data).valueOf();\n    return annotations;\n  }\n}\nmodule.exports = BytecodeSerializer;","map":{"version":3,"names":["RLP","require","BaseSerializer","TypeSerializer","byteArray2Hex","byteArray2Int","OPCODES","FateTypeByteArray","FateTypeString","FateTypeMap","MODIFIERS","splitArgs","data","n","args","bits","Number","i","push","Error","toString","BytecodeSerializer","constructor","globalSerializer","_typeSerializer","deserialize","codeBin","decode","symbolsBin","remainder","annotationsBin","symbols","deserializeSymbols","functions","deserializeFunctions","annotations","deserializeAnnotations","fun","rest","length","deserializeFunction","prefix","id","slice","name","attributes","rest2","deserializeAttributes","returnType","rest3","deserializeSignature","instructions","rest4","deserializeInstructions","instruction","block","end","undefined","deserializeInstruction","opcode","hasOwnProperty","instr","mnemonic","deserializeArguments","numBytes","modBytes","subarray","modifiers","arg","forEach","mod","deserializeArgument","stream","deserializeStream","valueOf","attributesInt","attributesByte","type","deserializeWithType","symbolsMap","val","key","hex","module","exports"],"sources":["C:/Users/amitk/Desktop/Donation Project/donation-aeternity-blockchain-contract/node_modules/@aeternity/aepp-calldata/src/Serializers/BytecodeSerializer.js"],"sourcesContent":["const RLP = require('rlp')\nconst BaseSerializer = require('./BaseSerializer')\nconst TypeSerializer = require('./TypeSerializer')\nconst {byteArray2Hex, byteArray2Int} = require('../utils/int2ByteArray')\nconst OPCODES = require('../FateOpcodes')\nconst {\n    FateTypeByteArray,\n    FateTypeString,\n    FateTypeMap,\n} = require('../FateTypes')\n\nconst MODIFIERS = {\n    0b11: 'immediate',\n    0b10: 'var',\n    0b01: 'arg',\n    0b00: 'stack'\n}\n\nconst splitArgs = (data, n = 1) => {\n    const args = []\n    let bits = Number(byteArray2Int(data))\n\n    for (let i = 0; i < n * 2; i += 2) {\n        args.push(bits & 0b11)\n        bits >>= 2\n    }\n\n    if (bits !== 0) {\n        throw new Error(`Invalid argument modifier data. Unexpected padding: 0b${bits.toString(2)}`)\n    }\n\n    return args\n}\n\nclass BytecodeSerializer extends BaseSerializer {\n    constructor(globalSerializer) {\n        super(globalSerializer)\n\n        this._typeSerializer = new TypeSerializer()\n    }\n\n    deserialize(data) {\n        const codeBin = RLP.decode(data, true)\n        const symbolsBin = RLP.decode(codeBin.remainder, true)\n        const annotationsBin = RLP.decode(symbolsBin.remainder)\n\n        const symbols = this.deserializeSymbols(symbolsBin.data)\n        const functions = this.deserializeFunctions(codeBin.data, symbols)\n        const annotations = this.deserializeAnnotations(annotationsBin)\n\n        return {functions, symbols, annotations}\n    }\n\n    deserializeFunctions(data, symbols) {\n        let fun = {}\n        let rest = data\n        const functions = []\n\n        while (rest.length) {\n            [fun, rest] = this.deserializeFunction(rest, symbols)\n            functions.push(fun)\n        }\n\n        return functions\n    }\n\n    deserializeFunction(data, symbols) {\n        const prefix = data[0]\n        const id = byteArray2Hex(data.slice(1, 5))\n\n        if (prefix !== 0xfe) {\n            throw new Error(`Wrong function prefix, expeted 0xfe got 0x${data[0].toString(16)}`)\n        }\n\n        const name = symbols[id]\n        const [attributes, rest2] = this.deserializeAttributes(data.slice(5))\n        const [args, returnType, rest3] = this.deserializeSignature(rest2)\n        const [instructions, rest4] = this.deserializeInstructions(rest3)\n\n        return [\n            {\n                id,\n                name,\n                attributes,\n                args,\n                returnType,\n                instructions\n            },\n            rest4\n        ]\n    }\n\n    deserializeInstructions(data) {\n        let instruction = {}\n        let rest = data\n        const instructions = []\n\n        let block = 0\n        let end = false\n\n        while (rest.length && rest[0] !== 0xfe) {\n            if (instructions[block] === undefined) {\n                instructions[block] = []\n            }\n\n            [instruction, rest, end] = this.deserializeInstruction(rest)\n            instructions[block].push(instruction)\n\n            if (end) {\n                block++\n            }\n        }\n\n        return [instructions, rest]\n    }\n\n    deserializeInstruction(data) {\n        const opcode = data[0]\n        const rest = data.slice(1)\n\n        if (!OPCODES.hasOwnProperty(opcode)) {\n            throw new Error(`Unsupported opcode: 0x${opcode.toString(16)}`)\n        }\n\n        const instr = OPCODES[opcode]\n        const {mnemonic, end} = instr\n\n        if (instr.args === 0) {\n            return [{mnemonic, args: []}, rest, end]\n        }\n\n        const [args, rest2] = this.deserializeArguments(rest, instr.args)\n\n        return [{mnemonic, args}, rest2, end]\n    }\n\n    deserializeArguments(data, n) {\n        const numBytes = (n <= 4) ? 1 : 2\n        const modBytes = data.subarray(0, numBytes)\n        const rest = data.slice(numBytes)\n\n        const modifiers = splitArgs(modBytes, n)\n        const args = []\n        let rest2 = rest\n        let arg\n\n        modifiers.forEach(mod => {\n            [arg, rest2] = this.deserializeArgument(mod, rest2)\n            args.push(arg)\n        })\n\n        return [args, rest2]\n    }\n\n    deserializeArgument(bits, stream) {\n        const mod = MODIFIERS[bits]\n\n        if (mod === 'stack') {\n            return [{mod, arg: 0}, stream]\n        }\n\n        const [arg, rest] = this.globalSerializer.deserializeStream(stream)\n\n        return [{mod, arg: arg.valueOf()}, rest]\n    }\n\n    deserializeSignature(data) {\n        const [args, rest] = this._typeSerializer.deserializeStream(data)\n        const [returnType, rest2] = this._typeSerializer.deserializeStream(rest)\n\n        return [args, returnType, rest2]\n    }\n\n    deserializeAttributes(data) {\n        const [attributesInt, rest] = this.globalSerializer.deserializeStream(data)\n        const attributesByte = Number(attributesInt.valueOf())\n        const attributes = []\n\n        if (attributesByte & 0b0001) {\n            attributes.push('private')\n        }\n\n        if (attributesByte & 0b0010) {\n            attributes.push('payable')\n        }\n\n        return [attributes, rest]\n    }\n\n    deserializeSymbols(data) {\n        // Needs typehint with ByteArray otherwise deserializes to string\n        const type = FateTypeMap(FateTypeByteArray(), FateTypeString())\n        const symbols = this.globalSerializer.deserializeWithType(data, type).valueOf()\n        const symbolsMap = {}\n\n        symbols.forEach((val, key) => {\n            const hex = byteArray2Hex(key)\n            symbolsMap[hex] = val\n        })\n\n        return symbolsMap\n    }\n\n    deserializeAnnotations(data) {\n        const annotations = this.globalSerializer.deserialize(data).valueOf()\n\n        return annotations\n    }\n}\n\nmodule.exports = BytecodeSerializer\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}