{"ast":null,"code":"import _buffer from \"buffer\";\nconst {\n  Buffer: _Buffer\n} = _buffer;\nimport AccountBase from \"./Base.mjs\";\nimport { ArgumentError, NotImplementedError } from \"../utils/errors.mjs\";\nimport { decode } from \"../utils/encoder.mjs\";\nimport { buildTx } from \"../tx/builder/index.mjs\";\nimport { Tag } from \"../tx/builder/constants.mjs\";\nexport const CLA = 0xe0;\nexport const GET_ADDRESS = 0x02;\nexport const SIGN_TRANSACTION = 0x04;\nexport const GET_APP_CONFIGURATION = 0x06;\nexport const SIGN_PERSONAL_MESSAGE = 0x08;\n\n/**\n * Ledger wallet account class\n */\nexport default class AccountLedger extends AccountBase {\n  /**\n   * @param transport - Connection to Ledger to use\n   * @param index - Index of account\n   * @param address - Address of account\n   */\n  constructor(transport, index, address) {\n    super();\n    this.transport = transport;\n    this.index = index;\n    this.address = address;\n    const scrambleKey = 'w0w';\n    transport.decorateAppAPIMethods(this, ['signTransaction', 'signMessage'], scrambleKey);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async sign() {\n    throw new NotImplementedError('RAW signing using Ledger HW');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async signTypedData() {\n    throw new NotImplementedError('Typed data signing using Ledger HW');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async signDelegationToContract() {\n    throw new NotImplementedError('signing delegation to contract using Ledger HW');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async signNameDelegationToContract() {\n    throw new NotImplementedError('signing delegation to contract using Ledger HW');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async signOracleQueryDelegationToContract() {\n    throw new NotImplementedError('signing delegation to contract using Ledger HW');\n  }\n  async signTransaction(tx) {\n    let {\n      innerTx,\n      networkId\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (innerTx != null) throw new NotImplementedError('innerTx option in AccountLedger');\n    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);\n    const rawTx = decode(tx);\n    let offset = 0;\n    const headerLength = 4 + 1 + 4;\n    const networkIdBuffer = _Buffer.from(networkId);\n    const toSend = [];\n    while (offset !== rawTx.length) {\n      const maxChunkSize = offset === 0 ? 150 - headerLength - networkIdBuffer.length : 150;\n      const chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n      const buffer = _Buffer.alloc(offset === 0 ? headerLength + networkIdBuffer.length + chunkSize : chunkSize);\n      if (offset === 0) {\n        let bufferOffset = buffer.writeUInt32BE(this.index, 0);\n        bufferOffset = buffer.writeUInt32BE(rawTx.length, bufferOffset);\n        bufferOffset = buffer.writeUInt8(networkIdBuffer.length, bufferOffset);\n        bufferOffset += networkIdBuffer.copy(buffer, bufferOffset, 0, networkIdBuffer.length);\n        rawTx.copy(buffer, bufferOffset, 0, 150 - bufferOffset);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    const response = await toSend.reduce(async (previous, data, i) => {\n      await previous;\n      return this.transport.send(CLA, SIGN_TRANSACTION, i === 0 ? 0x00 : 0x80, 0x00, data);\n    }, Promise.resolve(_Buffer.alloc(0)));\n    const signatures = [response.subarray(0, 64)];\n    return buildTx({\n      tag: Tag.SignedTx,\n      encodedTx: rawTx,\n      signatures\n    });\n  }\n  async signMessage(messageStr) {\n    let offset = 0;\n    const message = _Buffer.from(messageStr);\n    const toSend = [];\n    while (offset !== message.length) {\n      const maxChunkSize = offset === 0 ? 150 - 4 - 4 : 150;\n      const chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      const buffer = _Buffer.alloc(offset === 0 ? 4 + 4 + chunkSize : chunkSize);\n      if (offset === 0) {\n        buffer.writeUInt32BE(this.index, 0);\n        buffer.writeUInt32BE(message.length, 4);\n        message.copy(buffer, 4 + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    const response = await toSend.reduce(async (previous, data, i) => {\n      await previous;\n      return this.transport.send(CLA, SIGN_PERSONAL_MESSAGE, i === 0 ? 0x00 : 0x80, 0x00, data);\n    }, Promise.resolve(_Buffer.alloc(0)));\n    return response.subarray(0, 64);\n  }\n}","map":{"version":3,"names":["AccountBase","ArgumentError","NotImplementedError","decode","buildTx","Tag","CLA","GET_ADDRESS","SIGN_TRANSACTION","GET_APP_CONFIGURATION","SIGN_PERSONAL_MESSAGE","AccountLedger","constructor","transport","index","address","scrambleKey","decorateAppAPIMethods","sign","signTypedData","signDelegationToContract","signNameDelegationToContract","signOracleQueryDelegationToContract","signTransaction","tx","innerTx","networkId","arguments","length","undefined","rawTx","offset","headerLength","networkIdBuffer","_Buffer","from","toSend","maxChunkSize","chunkSize","buffer","alloc","bufferOffset","writeUInt32BE","writeUInt8","copy","push","response","reduce","previous","data","i","send","Promise","resolve","signatures","subarray","tag","SignedTx","encodedTx","signMessage","messageStr","message"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\account\\Ledger.ts"],"sourcesContent":["import type Transport from '@ledgerhq/hw-transport';\nimport AccountBase from './Base';\nimport { ArgumentError, NotImplementedError } from '../utils/errors';\nimport { decode, Encoded } from '../utils/encoder';\nimport { buildTx } from '../tx/builder';\nimport { Tag } from '../tx/builder/constants';\n\nexport const CLA = 0xe0;\nexport const GET_ADDRESS = 0x02;\nexport const SIGN_TRANSACTION = 0x04;\nexport const GET_APP_CONFIGURATION = 0x06;\nexport const SIGN_PERSONAL_MESSAGE = 0x08;\n\n/**\n * Ledger wallet account class\n */\nexport default class AccountLedger extends AccountBase {\n  readonly transport: Transport;\n\n  override readonly address: Encoded.AccountAddress;\n\n  readonly index: number;\n\n  /**\n   * @param transport - Connection to Ledger to use\n   * @param index - Index of account\n   * @param address - Address of account\n   */\n  constructor(transport: Transport, index: number, address: Encoded.AccountAddress) {\n    super();\n    this.transport = transport;\n    this.index = index;\n    this.address = address;\n    const scrambleKey = 'w0w';\n    transport.decorateAppAPIMethods(this, ['signTransaction', 'signMessage'], scrambleKey);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override async sign(): Promise<Uint8Array> {\n    throw new NotImplementedError('RAW signing using Ledger HW');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override async signTypedData(): Promise<Encoded.Signature> {\n    throw new NotImplementedError('Typed data signing using Ledger HW');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override async signDelegationToContract(): Promise<Encoded.Signature> {\n    throw new NotImplementedError('signing delegation to contract using Ledger HW');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override async signNameDelegationToContract(): Promise<Encoded.Signature> {\n    throw new NotImplementedError('signing delegation to contract using Ledger HW');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  override async signOracleQueryDelegationToContract(): Promise<Encoded.Signature> {\n    throw new NotImplementedError('signing delegation to contract using Ledger HW');\n  }\n\n  override async signTransaction(\n    tx: Encoded.Transaction,\n    { innerTx, networkId }: { innerTx?: boolean; networkId?: string } = {},\n  ): Promise<Encoded.Transaction> {\n    if (innerTx != null) throw new NotImplementedError('innerTx option in AccountLedger');\n    if (networkId == null) throw new ArgumentError('networkId', 'provided', networkId);\n\n    const rawTx = decode(tx);\n    let offset = 0;\n    const headerLength = 4 + 1 + 4;\n    const networkIdBuffer = Buffer.from(networkId);\n    const toSend = [];\n    while (offset !== rawTx.length) {\n      const maxChunkSize = offset === 0 ? 150 - headerLength - networkIdBuffer.length : 150;\n      const chunkSize = offset + maxChunkSize > rawTx.length\n        ? rawTx.length - offset : maxChunkSize;\n      const buffer = Buffer.alloc(\n        offset === 0 ? headerLength + networkIdBuffer.length + chunkSize : chunkSize,\n      );\n      if (offset === 0) {\n        let bufferOffset = buffer.writeUInt32BE(this.index, 0);\n        bufferOffset = buffer.writeUInt32BE(rawTx.length, bufferOffset);\n        bufferOffset = buffer.writeUInt8(networkIdBuffer.length, bufferOffset);\n        bufferOffset += networkIdBuffer.copy(\n          buffer,\n          bufferOffset,\n          0,\n          networkIdBuffer.length,\n        );\n        rawTx.copy(buffer, bufferOffset, 0, 150 - bufferOffset);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    const response = await toSend.reduce(\n      async (previous, data, i) => {\n        await previous;\n        return this.transport.send(\n          CLA,\n          SIGN_TRANSACTION,\n          i === 0 ? 0x00 : 0x80,\n          0x00,\n          data,\n        );\n      },\n      Promise.resolve(Buffer.alloc(0)),\n    );\n    const signatures = [response.subarray(0, 64)];\n\n    return buildTx({ tag: Tag.SignedTx, encodedTx: rawTx, signatures });\n  }\n\n  override async signMessage(messageStr: string): Promise<Uint8Array> {\n    let offset = 0;\n    const message = Buffer.from(messageStr);\n    const toSend = [];\n    while (offset !== message.length) {\n      const maxChunkSize = offset === 0 ? 150 - 4 - 4 : 150;\n      const chunkSize = offset + maxChunkSize > message.length\n        ? message.length - offset : maxChunkSize;\n      const buffer = Buffer.alloc(offset === 0 ? 4 + 4 + chunkSize : chunkSize);\n      if (offset === 0) {\n        buffer.writeUInt32BE(this.index, 0);\n        buffer.writeUInt32BE(message.length, 4);\n        message.copy(buffer, 4 + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    const response = await toSend.reduce(\n      async (previous, data, i) => {\n        await previous;\n        return this.transport.send(\n          CLA,\n          SIGN_PERSONAL_MESSAGE,\n          i === 0 ? 0x00 : 0x80,\n          0x00,\n          data,\n        );\n      },\n      Promise.resolve(Buffer.alloc(0)),\n    );\n    return response.subarray(0, 64);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}