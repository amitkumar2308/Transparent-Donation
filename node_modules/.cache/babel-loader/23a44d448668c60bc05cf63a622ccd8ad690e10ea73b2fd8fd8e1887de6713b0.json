{"ast":null,"code":"import { buildTx, buildTxHash, unpackTx } from \"./builder/index.mjs\";\nimport { Tag } from \"./builder/constants.mjs\";\nimport { verify } from \"../utils/crypto.mjs\";\nimport { getBufferToSign } from \"../account/Memory.mjs\";\nimport { IllegalArgumentError, InternalError, TransactionError } from \"../utils/errors.mjs\";\nimport getTransactionSignerAddress from \"./transaction-signer.mjs\";\n/**\n * Calculates the cost of transaction execution\n * Provides an upper cost of contract-call-related transactions because of `gasLimit`.\n * Also assumes that oracle query fee is 0 unless it is provided in options.\n *\n * The idea is that if you need to show transaction details with some accuracy you can define\n * expense fields that you want to show separately. And to show `getExecutionCost` result as a fee,\n * subtracting all fields shown separately.\n *\n * @example\n * ```vue\n * <template>\n * Amount: {{ txUnpacked.amount }}\n * Name fee: {{ txUnpacked.nameFee }}\n * Other fees: {{ getExecutionCost(txEncoded) - txUnpacked.amount - txUnpacked.nameFee }}\n * </template>\n * ```\n *\n * Doing this way you won't worry to show wrong fee for a transaction you may not support. Because\n * the SDK calculates the overall price of any transaction on its side.\n *\n * @param transaction - Transaction to calculate the cost of\n * @param innerTx - Should be provided if transaction wrapped with Tag.PayingForTx\n * @param gasUsed - Amount of gas actually used to make calculation more accurate\n * @param queryFee - Oracle query fee\n * @param isInitiator - Is transaction signer an initiator of state channel\n */\nexport function getExecutionCost(transaction) {\n  let {\n    innerTx,\n    gasUsed,\n    queryFee,\n    isInitiator\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const params = unpackTx(transaction);\n  if (params.tag === Tag.SignedTx) {\n    throw new IllegalArgumentError('Transaction shouldn\\'t be a SignedTx, use `getExecutionCostBySignedTx` instead');\n  }\n  let res = 0n;\n  if ('fee' in params && innerTx !== 'freeloader') {\n    res += BigInt(params.fee);\n  }\n  if (params.tag === Tag.NameClaimTx) {\n    res += BigInt(params.nameFee);\n  }\n  if (params.tag === Tag.OracleQueryTx) {\n    res += BigInt(params.queryFee);\n  }\n  if (params.tag === Tag.OracleResponseTx) {\n    res -= BigInt(queryFee !== null && queryFee !== void 0 ? queryFee : 0);\n  }\n  if (params.tag === Tag.ChannelSettleTx) {\n    if (isInitiator === true) res -= BigInt(params.initiatorAmountFinal);\n    if (isInitiator === false) res -= BigInt(params.responderAmountFinal);\n  }\n  if ((params.tag === Tag.SpendTx && params.senderId !== params.recipientId || params.tag === Tag.ContractCreateTx || params.tag === Tag.ContractCallTx || params.tag === Tag.ChannelDepositTx) && innerTx !== 'fee-payer') {\n    res += BigInt(params.amount);\n  }\n  if (params.tag === Tag.ContractCreateTx) res += BigInt(params.deposit);\n  if ((params.tag === Tag.ContractCreateTx || params.tag === Tag.ContractCallTx || params.tag === Tag.GaAttachTx || params.tag === Tag.GaMetaTx) && innerTx !== 'freeloader') {\n    res += BigInt(params.gasPrice) * BigInt(gasUsed !== null && gasUsed !== void 0 ? gasUsed : params.gasLimit);\n  }\n  if (params.tag === Tag.GaMetaTx || params.tag === Tag.PayingForTx) {\n    res += getExecutionCost(buildTx(params.tx.encodedTx), params.tag === Tag.PayingForTx ? {\n      innerTx: 'fee-payer'\n    } : {});\n  }\n  return res;\n}\n\n/**\n * Calculates the cost of signed transaction execution\n * @param transaction - Transaction to calculate the cost of\n * @param networkId - Network id used to sign the transaction\n * @param options - Options\n */\nexport function getExecutionCostBySignedTx(transaction, networkId, options) {\n  const params = unpackTx(transaction, Tag.SignedTx);\n  if (params.encodedTx.tag === Tag.GaMetaTx) {\n    return getExecutionCost(buildTx(params.encodedTx), options);\n  }\n  const tx = buildTx(params.encodedTx);\n  const address = getTransactionSignerAddress(tx);\n  const [isInnerTx, isNotInnerTx] = [true, false].map(f => verify(getBufferToSign(tx, networkId, f), params.signatures[0], address));\n  if (!isInnerTx && !isNotInnerTx) throw new TransactionError('Can\\'t verify signature');\n  return getExecutionCost(buildTx(params.encodedTx), {\n    ...(isInnerTx && {\n      innerTx: 'freeloader'\n    }),\n    ...options\n  });\n}\n\n/**\n * Calculates the cost of signed and not signed transaction execution using node\n * @param transaction - Transaction to calculate the cost of\n * @param node - Node to use\n * @param isMined - Is transaction already mined or not\n * @param options - Options\n */\nexport async function getExecutionCostUsingNode(transaction, node) {\n  let {\n    isMined,\n    ...options\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let params = unpackTx(transaction);\n  const isSignedTx = params.tag === Tag.SignedTx;\n  const txHash = isSignedTx && isMined === true && buildTxHash(transaction);\n  if (params.tag === Tag.SignedTx) params = params.encodedTx;\n\n  // TODO: set gasUsed for PayingForTx after solving https://github.com/aeternity/aeternity/issues/4087\n  if (options.gasUsed == null && txHash !== false && [Tag.ContractCreateTx, Tag.ContractCallTx, Tag.GaAttachTx, Tag.GaMetaTx].includes(params.tag)) {\n    const {\n      callInfo,\n      gaInfo\n    } = await node.getTransactionInfoByHash(txHash);\n    const combinedInfo = callInfo !== null && callInfo !== void 0 ? callInfo : gaInfo;\n    if (combinedInfo == null) {\n      throw new InternalError(`callInfo and gaInfo is not available for transaction ${txHash}`);\n    }\n    options.gasUsed = combinedInfo.gasUsed;\n  }\n  if (options.queryFee == null && Tag.OracleResponseTx === params.tag) {\n    options.queryFee = (await node.getOracleByPubkey(params.oracleId)).queryFee.toString();\n  }\n  if (options.isInitiator == null && Tag.ChannelSettleTx === params.tag && isMined !== true) {\n    const {\n      initiatorId\n    } = await node.getChannelByPubkey(params.channelId);\n    options.isInitiator = params.fromId === initiatorId;\n  }\n  return isSignedTx ? getExecutionCostBySignedTx(transaction, await node.getNetworkId(), options) : getExecutionCost(transaction, options);\n}","map":{"version":3,"names":["buildTx","buildTxHash","unpackTx","Tag","verify","getBufferToSign","IllegalArgumentError","InternalError","TransactionError","getTransactionSignerAddress","getExecutionCost","transaction","innerTx","gasUsed","queryFee","isInitiator","arguments","length","undefined","params","tag","SignedTx","res","BigInt","fee","NameClaimTx","nameFee","OracleQueryTx","OracleResponseTx","ChannelSettleTx","initiatorAmountFinal","responderAmountFinal","SpendTx","senderId","recipientId","ContractCreateTx","ContractCallTx","ChannelDepositTx","amount","deposit","GaAttachTx","GaMetaTx","gasPrice","gasLimit","PayingForTx","tx","encodedTx","getExecutionCostBySignedTx","networkId","options","address","isInnerTx","isNotInnerTx","map","f","signatures","getExecutionCostUsingNode","node","isMined","isSignedTx","txHash","includes","callInfo","gaInfo","getTransactionInfoByHash","combinedInfo","getOracleByPubkey","oracleId","toString","initiatorId","getChannelByPubkey","channelId","fromId","getNetworkId"],"sources":["C:\\Users\\amitk\\Desktop\\Donation Project\\donation-aeternity-blockchain-contract\\node_modules\\@aeternity\\aepp-sdk\\src\\tx\\execution-cost.ts"],"sourcesContent":["import { Encoded } from '../utils/encoder';\nimport { buildTx, buildTxHash, unpackTx } from './builder';\nimport { Tag } from './builder/constants';\nimport { verify } from '../utils/crypto';\nimport { getBufferToSign } from '../account/Memory';\nimport { IllegalArgumentError, InternalError, TransactionError } from '../utils/errors';\nimport Node from '../Node';\nimport getTransactionSignerAddress from './transaction-signer';\n\n/**\n * Calculates the cost of transaction execution\n * Provides an upper cost of contract-call-related transactions because of `gasLimit`.\n * Also assumes that oracle query fee is 0 unless it is provided in options.\n *\n * The idea is that if you need to show transaction details with some accuracy you can define\n * expense fields that you want to show separately. And to show `getExecutionCost` result as a fee,\n * subtracting all fields shown separately.\n *\n * @example\n * ```vue\n * <template>\n * Amount: {{ txUnpacked.amount }}\n * Name fee: {{ txUnpacked.nameFee }}\n * Other fees: {{ getExecutionCost(txEncoded) - txUnpacked.amount - txUnpacked.nameFee }}\n * </template>\n * ```\n *\n * Doing this way you won't worry to show wrong fee for a transaction you may not support. Because\n * the SDK calculates the overall price of any transaction on its side.\n *\n * @param transaction - Transaction to calculate the cost of\n * @param innerTx - Should be provided if transaction wrapped with Tag.PayingForTx\n * @param gasUsed - Amount of gas actually used to make calculation more accurate\n * @param queryFee - Oracle query fee\n * @param isInitiator - Is transaction signer an initiator of state channel\n */\nexport function getExecutionCost(\n  transaction: Encoded.Transaction,\n  {\n    innerTx, gasUsed, queryFee, isInitiator,\n  }: {\n    innerTx?: 'fee-payer' | 'freeloader';\n    gasUsed?: number;\n    queryFee?: string;\n    isInitiator?: boolean;\n  } = {},\n): bigint {\n  const params = unpackTx(transaction);\n  if (params.tag === Tag.SignedTx) {\n    throw new IllegalArgumentError('Transaction shouldn\\'t be a SignedTx, use `getExecutionCostBySignedTx` instead');\n  }\n\n  let res = 0n;\n  if ('fee' in params && innerTx !== 'freeloader') {\n    res += BigInt(params.fee);\n  }\n  if (params.tag === Tag.NameClaimTx) {\n    res += BigInt(params.nameFee);\n  }\n  if (params.tag === Tag.OracleQueryTx) {\n    res += BigInt(params.queryFee);\n  }\n  if (params.tag === Tag.OracleResponseTx) {\n    res -= BigInt(queryFee ?? 0);\n  }\n  if (params.tag === Tag.ChannelSettleTx) {\n    if (isInitiator === true) res -= BigInt(params.initiatorAmountFinal);\n    if (isInitiator === false) res -= BigInt(params.responderAmountFinal);\n  }\n  if (\n    ((params.tag === Tag.SpendTx && params.senderId !== params.recipientId)\n    || params.tag === Tag.ContractCreateTx || params.tag === Tag.ContractCallTx\n    || params.tag === Tag.ChannelDepositTx) && innerTx !== 'fee-payer'\n  ) {\n    res += BigInt(params.amount);\n  }\n  if (params.tag === Tag.ContractCreateTx) res += BigInt(params.deposit);\n  if (\n    (params.tag === Tag.ContractCreateTx || params.tag === Tag.ContractCallTx\n      || params.tag === Tag.GaAttachTx || params.tag === Tag.GaMetaTx)\n    && innerTx !== 'freeloader'\n  ) {\n    res += BigInt(params.gasPrice) * BigInt(gasUsed ?? params.gasLimit);\n  }\n  if (params.tag === Tag.GaMetaTx || params.tag === Tag.PayingForTx) {\n    res += getExecutionCost(\n      buildTx(params.tx.encodedTx),\n      params.tag === Tag.PayingForTx ? { innerTx: 'fee-payer' } : {},\n    );\n  }\n  return res;\n}\n\n/**\n * Calculates the cost of signed transaction execution\n * @param transaction - Transaction to calculate the cost of\n * @param networkId - Network id used to sign the transaction\n * @param options - Options\n */\nexport function getExecutionCostBySignedTx(\n  transaction: Encoded.Transaction,\n  networkId: string,\n  options?: Omit<Parameters<typeof getExecutionCost>[1], 'innerTx'>,\n): bigint {\n  const params = unpackTx(transaction, Tag.SignedTx);\n  if (params.encodedTx.tag === Tag.GaMetaTx) {\n    return getExecutionCost(buildTx(params.encodedTx), options);\n  }\n\n  const tx = buildTx(params.encodedTx);\n  const address = getTransactionSignerAddress(tx);\n  const [isInnerTx, isNotInnerTx] = [true, false]\n    .map((f) => verify(getBufferToSign(tx, networkId, f), params.signatures[0], address));\n  if (!isInnerTx && !isNotInnerTx) throw new TransactionError('Can\\'t verify signature');\n  return getExecutionCost(\n    buildTx(params.encodedTx),\n    { ...isInnerTx && { innerTx: 'freeloader' }, ...options },\n  );\n}\n\n/**\n * Calculates the cost of signed and not signed transaction execution using node\n * @param transaction - Transaction to calculate the cost of\n * @param node - Node to use\n * @param isMined - Is transaction already mined or not\n * @param options - Options\n */\nexport async function getExecutionCostUsingNode(\n  transaction: Encoded.Transaction,\n  node: Node,\n  { isMined, ...options }: { isMined?: boolean } & Parameters<typeof getExecutionCost>[1] = {},\n): Promise<bigint> {\n  let params = unpackTx(transaction);\n  const isSignedTx = params.tag === Tag.SignedTx;\n  const txHash = isSignedTx && isMined === true && buildTxHash(transaction);\n  if (params.tag === Tag.SignedTx) params = params.encodedTx;\n\n  // TODO: set gasUsed for PayingForTx after solving https://github.com/aeternity/aeternity/issues/4087\n  if (\n    options.gasUsed == null && txHash !== false\n    && [Tag.ContractCreateTx, Tag.ContractCallTx, Tag.GaAttachTx, Tag.GaMetaTx].includes(params.tag)\n  ) {\n    const { callInfo, gaInfo } = await node.getTransactionInfoByHash(txHash);\n    const combinedInfo = callInfo ?? gaInfo;\n    if (combinedInfo == null) {\n      throw new InternalError(`callInfo and gaInfo is not available for transaction ${txHash}`);\n    }\n    options.gasUsed = combinedInfo.gasUsed;\n  }\n\n  if (options.queryFee == null && Tag.OracleResponseTx === params.tag) {\n    options.queryFee = (await node.getOracleByPubkey(params.oracleId)).queryFee.toString();\n  }\n\n  if (options.isInitiator == null && Tag.ChannelSettleTx === params.tag && isMined !== true) {\n    const { initiatorId } = await node.getChannelByPubkey(params.channelId);\n    options.isInitiator = params.fromId === initiatorId;\n  }\n\n  return isSignedTx\n    ? getExecutionCostBySignedTx(transaction, await node.getNetworkId(), options)\n    : getExecutionCost(transaction, options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}